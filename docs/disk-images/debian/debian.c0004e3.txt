hread.__init__() not called"
        return self._daemonic

    @daemon.setter
    def daemon(self, daemonic):
        if not self._initialized:
            raise RuntimeError("Thread.__init__() not called")
        if daemonic and not _daemon_threads_allowed():
            raise RuntimeError('daemon threads are disabled in this interpreter')
        if self._started.is_set():
            raise RuntimeError("cannot set daemon status of active thread")
        self._daemonic = daemonic

    def isDaemon(self):
        """Return whether this thread is a daemon.

        This method is deprecated, use the daemon attribute instead.

        """
        import warnings
        warnings.warn('isDaemon() is deprecated, get the daemon attribute instead',
                      DeprecationWarning, stacklevel=2)
        return self.daemon

    def setDaemon(self, daemonic):
        """Set whether this thread is a daemon.

        This method is deprecated, use the .daemon property instead.

        """
        import warnings
        warnings.warn('setDaemon() is deprecated, set the daemon attribute instead',
                      DeprecationWarning, stacklevel=2)
        self.daemon = daemonic

    def getName(self):
        """Return a string used for identification purposes only.

        This method is deprecated, use the name attribute instead.

        """
        import warnings
        warnings.warn('getName() is deprecated, get the name attribute instead',
                      DeprecationWarning, stacklevel=2)
        return self.name

    def setName(self, name):
        """Set the name string for this thread.

        This method is deprecated, use the name attribute instead.

        """
        import warnings
        warnings.warn('setName() is deprecated, set the name attribute instead',
                      DeprecationWarning, stacklevel=2)
        self.name = name


try:
    from _thread import (_excepthook as excepthook,
                         _ExceptHookArgs as ExceptHookArgs)
except ImportError:
    # Simple Python implementation if _thread._excepthook() is not available
    from traceback import print_exception as _print_exception
    from collections import namedtuple

    _ExceptHookArgs = namedtuple(
        'ExceptHookArgs',
        'exc_type exc_value exc_traceback thread')

    def ExceptHookArgs(args):
        return _ExceptHookArgs(*args)

    def excepthook(args, /):
        """
        Handle uncaught Thread.run() exception.
        """
        if args.exc_type == SystemExit:
            # silently ignore SystemExit
            return

        if _sys is not None and _sys.stderr is not None:
            stderr = _sys.stderr
        elif args.thread is not None:
            stderr = args.thread._stderr
            if stderr is None:
                # do nothing if sys.stderr is None and sys.stderr was None
                # when the thread was created
                return
        else:
            # do nothing if sys.stderr is None and args.thread is None
            return

        if args.thread is not None:
            name = args.thread.name
        else:
            name = get_ident()
        print(f"Exception in thread {name}:",
              file=stderr, flush=True)
        _print_exception(args.exc_type, args.exc_value, args.exc_traceback,
                         file=stderr)
        stderr.flush()


# Original value of threading.excepthook
__excepthook__ = excepthook


def _make_invoke_excepthook():
    # Create a local namespace to ensure that variables remain alive
    # when _invoke_excepthook() is called, even if it is called late during
    # Python shutdown. It is mostly needed for daemon threads.

    old_excepthook = excepthook
    old_sys_excepthook = _sys.excepthook
    if old_excepthook is None:
        raise RuntimeError("threading.excepthook is None")
    if old_sys_excepthook is None:
        raise RuntimeError("sys.excepthook is None")

    sys_exc_info = _sys.exc_info
    local_print = print
    local_sys = _sys

    def invoke_excepthook(thread):
        global excepthook
        try:
            hook = excepthook
            if hook is None:
                hook = old_excepthook

            args = ExceptHookArgs([*sys_exc_info(), thread])

            hook(args)
        except Exception as exc:
            exc.__suppress_context__ = True
            del exc

            if local_sys is not None and local_sys.stderr is not None:
                stderr = local_sys.stderr
            else:
                stderr = thread._stderr

            local_print("Exception in threading.excepthook:",
                        file=stderr, flush=True)

            if local_sys is not None and local_sys.excepthook is not None:
                sys_excepthook = local_sys.excepthook
            else:
                sys_excepthook = old_sys_excepthook

            sys_excepthook(*sys_exc_info())
        finally:
            # Break reference cycle (exception stored in a variable)
            args = None

    return invoke_excepthook


# The timer class was contributed by Itamar Shtull-Trauring

class Timer(Thread):
    """Call a function after a specified number of seconds:

            t = Timer(30.0, f, args=None, kwargs=None)
            t.start()
            t.cancel()     # stop the timer's action if it's still waiting

    """

    def __init__(self, interval, function, args=None, kwargs=None):
        Thread.__init__(self)
        self.interval = interval
        self.function = function
        self.args = args if args is not None else []
        self.kwargs = kwargs if kwargs is not None else {}
        self.finished = Event()

    def cancel(self):
        """Stop the timer if it hasn't finished yet."""
        self.finished.set()

    def run(self):
        self.finished.wait(self.interval)
        if not self.finished.is_set():
            self.function(*self.args, **self.kwargs)
        self.finished.set()


# Special thread class to represent the main thread

class _MainThread(Thread):

    def __init__(self):
        Thread.__init__(self, name="MainThread", daemon=False)
        self._started.set()
        self._ident = _get_main_thread_ident()
        self._handle = _make_thread_handle(self._ident)
        if _HAVE_THREAD_NATIVE_ID:
            self._set_native_id()
        with _active_limbo_lock:
            _active[self._ident] = self


# Helper thread-local instance to detect when a _DummyThread
# is collected. Not a part of the public API.
_thread_local_info = local()


class _DeleteDummyThreadOnDel:
    '''
    Helper class to remove a dummy thread from threading._active on __del__.
    '''

    def __init__(self, dummy_thread):
        self._dummy_thread = dummy_thread
        self._tident = dummy_thread.ident
        # Put the thread on a thread local variable so that when
        # the related thread finishes this instance is collected.
        #
        # Note: no other references to this instance may be created.
        # If any client code creates a reference to this instance,
        # the related _DummyThread will be kept forever!
        _thread_local_info._track_dummy_thread_ref = self

    def __del__(self):
        with _active_limbo_lock:
            if _active.get(self._tident) is self._dummy_thread:
                _active.pop(self._tident, None)


# Dummy thread class to represent threads not started here.
# These should be added to `_active` and removed automatically
# when they die, although they can't be waited for.
# Their purpose is to return *something* from current_thread().
# They are marked as daemon threads so we won't wait for them
# when we exit (conform previous semantics).

class _DummyThread(Thread):

    def __init__(self):
        Thread.__init__(self, name=_newname("Dummy-%d"),
                        daemon=_daemon_threads_allowed())
        self._started.set()
        self._set_ident()
        self._handle = _make_thread_handle(self._ident)
        if _HAVE_THREAD_NATIVE_ID:
            self._set_native_id()
        with _active_limbo_lock:
            _active[self._ident] = self
        _DeleteDummyThreadOnDel(self)

    def is_alive(self):
    cœ  dœ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              if not self._handle.is_done() and self._started.is_set():
            return True
        raise RuntimeError("thread is not alive")

    def join(self, timeout=None):
        raise RuntimeError("cannot join a dummy thread")

    def _after_fork(self, new_ident=None):
        if new_ident is not None:
            self.__class__ = _MainThread
            self._name = 'MainThread'
            self._daemonic = False
        Thread._after_fork(self, new_ident=new_ident)


# Global API functions

def current_thread():
    """Return the current Thread object, corresponding to the caller's thread of control.

    If the caller's thread of control was not created through the threading
    module, a dummy thread object with limited functionality is returned.

    """
    try:
        return _active[get_ident()]
    except KeyError:
        return _DummyThread()

def currentThread():
    """Return the current Thread object, corresponding to the caller's thread of control.

    This function is deprecated, use current_thread() instead.

    """
    import warnings
    warnings.warn('currentThread() is deprecated, use current_thread() instead',
                  DeprecationWarning, stacklevel=2)
    return current_thread()

def active_count():
    """Return the number of Thread objects currently alive.

    The returned count is equal to the length of the list returned by
    enumerate().

    """
    # NOTE: if the logic in here ever changes, update Modules/posixmodule.c
    # warn_about_fork_with_threads() to match.
    with _active_limbo_lock:
        return len(_active) + len(_limbo)

def activeCount():
    """Return the number of Thread objects currently alive.

    This function is deprecated, use active_count() instead.

    """
    import warnings
    warnings.warn('activeCount() is deprecated, use active_count() instead',
                  DeprecationWarning, stacklevel=2)
    return active_count()

def _enumerate():
    # Same as enumerate(), but without the lock. Internal use only.
    return list(_active.values()) + list(_limbo.values())

def enumerate():
    """Return a list of all Thread objects currently alive.

    The list includes daemonic threads, dummy thread objects created by
    current_thread(), and the main thread. It excludes terminated threads and
    threads that have not yet been started.

    """
    with _active_limbo_lock:
        return list(_active.values()) + list(_limbo.values())


_threading_atexits = []
_SHUTTING_DOWN = False

def _register_atexit(func, *arg, **kwargs):
    """CPython internal: register *func* to be called before joining threads.

    The registered *func* is called with its arguments just before all
    non-daemon threads are joined in `_shutdown()`. It provides a similar
    purpose to `atexit.register()`, but its functions are called prior to
    threading shutdown instead of interpreter shutdown.

    For similarity to atexit, the registered functions are called in reverse.
    """
    if _SHUTTING_DOWN:
        raise RuntimeError("can't register atexit after shutdown")

    _threading_atexits.append(lambda: func(*arg, **kwargs))


from _thread import stack_size

# Create the main thread object,
# and make it available for the interpreter
# (Py_Main) as threading._shutdown.

_main_thread = _MainThread()

def _shutdown():
    """
    Wait until the Python thread state of all non-daemon threads get deleted.
    """
    # Obscure: other threads may be waiting to join _main_thread.  That's
    # dubious, but some code does it. We can't wait for it to be marked as done
    # normally - that won't happen until the interpreter is nearly dead. So
    # mark it done here.
    if _main_thread._handle.is_done() and _is_main_interpreter():
        # _shutdown() was already called
        return

    global _SHUTTING_DOWN
    _SHUTTING_DOWN = True

    # Call registered threading atexit functions before threads are joined.
    # Order is reversed, similar to atexit.
    for atexit_call in reversed(_threading_atexits):
        atexit_call()

    if _is_main_interpreter():
        _main_thread._handle._set_done()

    # Wait for all non-daemon threads to exit.
    _thread_shutdown()


def main_thread():
    """Return the main thread object.

    In normal conditions, the main thread is the thread from which the
    Python interpreter was started.
    """
    # XXX Figure this out for subinterpreters.  (See gh-75698.)
    return _main_thread


def _after_fork():
    """
    Cleanup threading module state that should not exist after a fork.
    """
    # Reset _active_limbo_lock, in case we forked while the lock was held
    # by another (non-forked) thread.  http://bugs.python.org/issue874900
    global _active_limbo_lock, _main_thread
    _active_limbo_lock = RLock()

    # fork() only copied the current thread; clear references to others.
    new_active = {}

    try:
        current = _active[get_ident()]
    except KeyError:
        # fork() was called in a thread which was not spawned
        # by threading.Thread. For example, a thread spawned
        # by thread.start_new_thread().
        current = _MainThread()

    _main_thread = current

    with _active_limbo_lock:
        # Dangling thread instances must still have their locks reset,
        # because someone may join() them.
        threads = set(_enumerate())
        threads.update(_dangling)
        for thread in threads:
            # Any lock/condition variable may be currently locked or in an
            # invalid state, so we reinitialize them.
            if thread is current:
                # This is the one and only active thread.
                ident = get_ident()
                thread._after_fork(new_ident=ident)
                new_active[ident] = thread
            else:
                # All the others are already stopped.
                thread._after_fork()

        _limbo.clear()
        _active.clear()
        _active.update(new_active)
        assert len(_active) == 1


if hasattr(_os, "register_at_fork"):
    _os.register_at_fork(after_in_child=_after_fork)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #! /usr/bin/python3.13

"""Tool for measuring execution time of small code snippets.

This module avoids a number of common traps for measuring execution
times.  See also Tim Peters' introduction to the Algorithms chapter in
the Python Cookbook, published by O'Reilly.

Library usage: see the Timer class.

Command line usage:
    python timeit.py [-n N] [-r N] [-s S] [-p] [-h] [--] [statement]

Options:
  -n/--number N: how many times to execute 'statement' (default: see below)
  -r/--repeat N: how many times to repeat the timer (default 5)
  -s/--setup S: statement to be executed once initially (default 'pass').
                Execution time of this setup statement is NOT timed.
  -p/--process: use time.process_time() (default is time.perf_counter())
  -v/--verbose: print raw timing results; repeat for more digits precision
  -u/--unit: set the output time unit (nsec, usec, msec, or sec)
  -h/--help: print this usage message and exit
  --: separate options from statement, use when statement starts with -
  statement: statement to be timed (default 'pass')

A multi-line statement may be given by specifying each line as a
separate argument; indented lines are possible by enclosing an
argument in quotes and using leading spaces.  Multiple -s options are
treated similarly.

If -n is not given, a suitable number of loops is calculated by trying
increasing numbers from the sequence 1, 2, 5, 10, 20, 50, ... until the
total time is at least 0.2 seconds.

Note: there is a certain baseline overhead associated with executing a
pass statement.  It differs between versions.  The code here doesn't try
to hide it, but you should be aware of it.  The baseline overhead can be
measured by invoking the program without arguments.

Classes:

    Timer

Functions:

    timeit(string, string) -> float
    repeat(string, string) -> list
    default_timer() -> float

"""

import gc
import itertools
import sys
import time

__all__ = ["Timer", "timeit", "repeat", "default_timer"]

dummy_src_name = "<timeit-src>"
default_number = 1000000
default_repeat = 5
default_timer = time.perf_counter

_globals = globals

# Don't change the indentation of the template; the reindent() calls
# in Timer.__init__() depend on setup being indented 4 spaces and stmt
# being indented 8 spaces.
template = """
def inner(_it, _timer{init}):
    {setup}
    _t0 = _timer()
    for _i in _it:
        {stmt}
        pass
    _t1 = _timer()
    return _t1 - _t0
"""


def reindent(src, indent):
    """Helper to reindent a multi-line statement."""
    return src.replace("\n", "\n" + " " * indent)


class Timer:
    """Class for timing execution speed of small code snippets.

    The constructor takes a statement to be timed, an additional
    statement used for setup, and a timer function.  Both statements
    default to 'pass'; the timer function is platform-dependent (see
    module doc string).  If 'globals' is specified, the code will be
    executed within that namespace (as opposed to inside timeit's
    namespace).

    To measure the execution time of the first statement, use the
    timeit() method.  The repeat() method is a convenience to call
    timeit() multiple times and return a list of results.

    The statements may contain newlines, as long as they don't contain
    multi-line string literals.
    """

    def __init__(self, stmt="pass", setup="pass", timer=default_timer,
                 globals=None):
        """Constructor.  See class doc string."""
        self.timer = timer
        local_ns = {}
        global_ns = _globals() if globals is None else globals
        init = ''
        if isinstance(setup, str):
            # Check that the code can be compiled outside a function
            compile(setup, dummy_src_name, "exec")
            stmtprefix = setup + '\n'
            setup = reindent(setup, 4)
        elif callable(setup):
            local_ns['_setup'] = setup
            init += ', _setup=_setup'
            stmtprefix = ''
            setup = '_setup()'
        else:
            raise ValueError("setup is neither a string nor callable")
        if isinstance(stmt, str):
            # Check that the code can be compiled outside a function
            compile(stmtprefix + stmt, dummy_src_name, "exec")
            stmt = reindent(stmt, 8)
        elif callable(stmt):
            local_ns['_stmt'] = stmt
            init += ', _stmt=_stmt'
            stmt = '_stmt()'
        else:
            raise ValueError("stmt is neither a string nor callable")
        src = template.format(stmt=stmt, setup=setup, init=init)
        self.src = src  # Save for traceback display
        code = compile(src, dummy_src_name, "exec")
        exec(code, global_ns, local_ns)
        self.inner = local_ns["inner"]

    def print_exc(self, file=None):
        """Helper to print a traceback from the timed code.

        Typical use:

            t = Timer(...)       # outside the try/except
            try:
                t.timeit(...)    # or t.repeat(...)
            except:
                t.print_exc()

        The advantage over the standard traceback is that source lines
        in the compiled template will be displayed.

        The optional file argument directs where the traceback is
        sent; it defaults to sys.stderr.
        """
        import linecache, traceback
        if self.src is not None:
            linecache.cache[dummy_src_name] = (len(self.src),
                                               None,
                                               self.src.split("\n"),
                                               dummy_src_name)
        # else the source is already stored somewhere else

        traceback.print_exc(file=file)

    def timeit(self, number=default_number):
        """Time 'number' executions of the main statement.

        To be precise, this executes the setup statement once, and
        then returns the time it takes to execute the main statement
        a number of times, as float seconds if using the default timer.   The
        argument is the number of times through the loop, defaulting
        to one million.  The main statement, the setup statement and
        the timer function to be used are passed to the constructor.
        """
        it = itertools.repeat(None, number)
        gcold = gc.isenabled()
        gc.disable()
        try:
            timing = self.inner(it, self.timer)
        finally:
            if gcold:
                gc.enable()
        return timing

    def repeat(self, repeat=default_repeat, number=default_number):
        """Call timeit() a few times.

        This is a convenience function that calls the timeit()
        repeatedly, returning a list of results.  The first argument
        specifies how many times to call timeit(), defaulting to 5;
        the second argument specifies the timer argument, defaulting
        to one million.

        Note: it's tempting to calculate mean and standard deviation
        from the result vector and report these.  However, this is not
        very useful.  In a typical case, the lowest value gives a
        lower bound for how fast your machine can run the given code
        snippet; higher values in the result vector are typically not
        caused by variability in Python's speed, but by other
        processes interfering with your timing accuracy.  So the min()
        of the result is probably the only number you should be
        interested in.  After that, you should look at the entire
        vector and apply common sense rather than statistics.
        """
        r = []
        for i in range(repeat):
            t = self.timeit(number)
            r.append(t)
        return r

    def autorange(self, callback=None):
        """Return the number of loops and time taken so that total time >= 0.2.

        Calls the timeit method with increasing numbers from the sequence
        1, 2, 5, 10, 20, 50, ... until the time taken is at least 0.2
        second.  Returns (number, time_taken).

        If *callback* is given and is not None, it will be called after
        each trial with two arguments: ``callback(number, time_taken)``.
        """
        i = 1
        while True:
            for j in 1, 2, 5:
                number = i * j
                time_taken = self.timeit(number)
                if callback:
                    callback(number, time_taken)
                if time_taken >= 0.2:
                    return (number, time_taken)
            i *= 10


def timeit(stmt="pass", setup="pass", timer=default_timer,
           number=default_number, globals=None):
    """Convenience function to create Timer object and call timeit method."""
    return Timer(stmt, setup, timer, globals).timeit(number)


def repeat(stmt="pass", setup="pass", timer=default_timer,
           repeat=default_repeat, number=default_number, globals=None):
    """Convenience function to create Timer object and call repeat method."""
    return Timer(stmt, setup, timer, globals).repeat(repeat, number)


def main(args=None, *, _wrap_timer=None):
    """Main program, used when run as a script.

    The optional 'args' argument specifies the command line to be parsed,
    defaulting to sys.argv[1:].

    The return value is an exit code to be passed to sys.exit(); it
    may be None to indicate success.

    When an exception happens during timing, a traceback is printed to
    stderr and the return value is 1.  Exceptions at other times
    (including the template compilation) are not caught.

    '_wrap_timer' is an internal interface used for unit testing.  If it
    is not None, it must be a callable that accepts a timer function
    and returns another timer function (used for unit testing).
    """
    if args is None:
        args = sys.argv[1:]
    import getopt
    try:
        opts, args = getopt.getopt(args, "n:u:s:r:pvh",
                                   ["number=", "setup=", "repeat=",
                                    "process", "verbose", "unit=", "help"])
    except getopt.error as err:
        print(err)
        print("use -h/--help for command line help")
        return 2

    timer = default_timer
    stmt = "\n".join(args) or "pass"
    number = 0  # auto-determine
    setup = []
    repeat = default_repeat
    verbose = 0
    time_unit = None
    units = {"nsec": 1e-9, "usec": 1e-6, "msec": 1e-3, "sec": 1.0}
    precision = 3
    for o, a in opts:
        if o in ("-n", "--number"):
            number = int(a)
        if o in ("-s", "--setup"):
            setup.append(a)
        if o in ("-u", "--unit"):
            if a in units:
                time_unit = a
            else:
                print("Unrecognized unit. Please select nsec, usec, msec, or sec.",
                      file=sys.stderr)
                return 2
        if o in ("-r", "--repeat"):
            repeat = int(a)
            if repeat <= 0:
                repeat = 1
        if o in ("-p", "--process"):
            timer = time.process_time
        if o in ("-v", "--verbose"):
            if verbose:
                precision += 1
            verbose += 1
        if o in ("-h", "--help"):
            print(__doc__, end=' ')
            return 0
    setup = "\n".join(setup) or "pass"

    # Include the current directory, so that local imports work (sys.path
    # contains the directory of this script, rather than the current
    # directory)
    import os
    sys.path.insert(0, os.curdir)
    if _wrap_timer is not None:
        timer = _wrap_timer(timer)

    t = Timer(stmt, setup, timer)
    if number == 0:
        # determine number so that 0.2 <= total time < 2.0
        callback = None
        if verbose:
            def callback(number, time_taken):
                msg = "{num} loop{s} -> {secs:.{prec}g} secs"
                plural = (number != 1)
                print(msg.format(num=number, s='s' if plural else '',
                                 secs=time_taken, prec=precision))
        try:
            number, _ = t.autorange(callback)
        except:
            t.print_exc()
            return 1

        if verbose:
            print()

    try:
        raw_timings = t.repeat(repeat, number)
    except:
        t.print_exc()
        return 1

    def format_time(dt):
        unit = time_unit

        if unit is not None:
            scale = units[unit]
        else:
            scales = [(scale, unit) for unit, scale in units.items()]
            scales.sort(reverse=True)
            for scale, unit in scales:
                if dt >= scale:
                    break

        return "%.*g %s" % (precision, dt / scale, unit)

    if verbose:
        print("raw times: %s" % ", ".join(map(format_time, raw_timings)))
        print()
    timings = [dt / number for dt in raw_timings]

    best = min(timings)
    print("%d loop%s, best of %d: %s per loop"
          % (number, 's' if number != 1 else '',
             repeat, format_time(best)))

    best = min(timings)
    worst = max(timings)
    if worst >= best * 4:
        import warnings
        warnings.warn_explicit("The test results are likely unreliable. "
                               "The worst time (%s) was more than four times "
                               "slower than the best time (%s)."
                               % (format_time(worst), format_time(best)),
                               UserWarning, '', 0)
    return None


if __name__ == "__main__":
    sys.exit(main())
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         """Token constants."""
# Auto-generated by Tools/build/generate_token.py

__all__ = ['tok_name', 'ISTERMINAL', 'ISNONTERMINAL', 'ISEOF',
           'EXACT_TOKEN_TYPES']

ENDMARKER = 0
NAME = 1
NUMBER = 2
STRING = 3
NEWLINE = 4
INDENT = 5
DEDENT = 6
LPAR = 7
RPAR = 8
LSQB = 9
RSQB = 10
COLON = 11
COMMA = 12
SEMI = 13
PLUS = 14
MINUS = 15
STAR = 16
SLASH = 17
VBAR = 18
AMPER = 19
LESS = 20
GREATER = 21
EQUAL = 22
DOT = 23
PERCENT = 24
LBRACE = 25
RBRACE = 26
EQEQUAL = 27
NOTEQUAL = 28
LESSEQUAL = 29
GREATEREQUAL = 30
TILDE = 31
CIRCUMFLEX = 32
LEFTSHIFT = 33
RIGHTSHIFT = 34
DOUBLESTAR = 35
PLUSEQUAL = 36
MINEQUAL = 37
STAREQUAL = 38
SLASHEQUAL = 39
PERCENTEQUAL = 40
AMPEREQUAL = 41
VBAREQUAL = 42
CIRCUMFLEXEQUAL = 43
LEFTSHIFTEQUAL = 44
RIGHTSHIFTEQUAL = 45
DOUBLESTAREQUAL = 46
DOUBLESLASH = 47
DOUBLESLASHEQUAL = 48
AT = 49
ATEQUAL = 50
RARROW = 51
ELLIPSIS = 52
COLONEQUAL = 53
EXCLAMATION = 54
OP = 55
TYPE_IGNORE = 56
TYPE_COMMENT = 57
SOFT_KEYWORD = 58
FSTRING_START = 59
FSTRING_MIDDLE = 60
FSTRING_END = 61
COMMENT = 62
NL = 63
# These aren't used by the C tokenizer but are needed for tokenize.py
ERRORTOKEN = 64
ENCODING = 65
N_TOKENS = 66
# Special definitions for cooperation with parser
NT_OFFSET = 256

tok_name = {value: name
            for name, value in globals().items()
            if isinstance(value, int) and not name.startswith('_')}
__all__.extend(tok_name.values())

EXACT_TOKEN_TYPES = {
    '!': EXCLAMATION,
    '!=': NOTEQUAL,
    '%': PERCENT,
    '%=': PERCENTEQUAL,
    '&': AMPER,
    '&=': AMPEREQUAL,
    '(': LPAR,
    ')': RPAR,
    '*': STAR,
    '**': DOUBLESTAR,
    '**=': DOUBLESTAREQUAL,
    '*=': STAREQUAL,
    '+': PLUS,
    '+=': PLUSEQUAL,
    ',': COMMA,
    '-': MINUS,
    '-=': MINEQUAL,
    '->': RARROW,
    '.': DOT,
    '...': ELLIPSIS,
    '/': SLASH,
    '//': DOUBLESLASH,
    '//=': DOUBLESLASHEQUAL,
    '/=': SLASHEQUAL,
    ':': COLON,
    ':=': COLONEQUAL,
    ';': SEMI,
    '<': LESS,
    '<<': LEFTSHIFT,
    '<<=': LEFTSHIFTEQUAL,
    '<=': LESSEQUAL,
    '=': EQUAL,
    '==': EQEQUAL,
    '>': GREATER,
    '>=': GREATEREQUAL,
    '>>': RIGHTSHIFT,
    '>>=': RIGHTSHIFTEQUAL,
    '@': AT,
    '@=': ATEQUAL,
    '[': LSQB,
    ']': RSQB,
    '^': CIRCUMFLEX,
    '^=': CIRCUMFLEXEQUAL,
    '{': LBRACE,
    '|': VBAR,
    '|=': VBAREQUAL,
    '}': RBRACE,
    '~': TILDE,
}

def ISTERMINAL(x):
    return x < NT_OFFSET

def ISNONTERMINAL(x):
    return x >= NT_OFFSET

def ISEOF(x):
    return x == ENDMARKER
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       """Tokenization help for Python programs.

tokenize(readline) is a generator that breaks a stream of bytes into
Python tokens.  It decodes the bytes according to PEP-0263 for
determining source file encoding.

It accepts a readline-like method which is called repeatedly to get the
next line of input (or b"" for EOF).  It generates 5-tuples with these
members:

    the token type (see token.py)
    the token (a string)
    the starting (row, column) indices of the token (a 2-tuple of ints)
    the ending (row, column) indices of the token (a 2-tuple of ints)
    the original line (string)

It is designed to match the working of the Python tokenizer exactly, except
that it produces COMMENT tokens for comments and gives type OP for all
operators.  Additionally, all token lists start with an ENCODING token
which tells you which encoding was used to decode the bytes stream.
"""

__author__ = 'Ka-Ping Yee <ping@lfw.org>'
__credits__ = ('GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, '
               'Skip Montanaro, Raymond Hettinger, Trent Nelson, '
               'Michael Foord')
from builtins import open as _builtin_open
from codecs import lookup, BOM_UTF8
import collections
import functools
from io import TextIOWrapper
import itertools as _itertools
import re
import sys
from token import *
from token import EXACT_TOKEN_TYPES
import _tokenize

cookie_re = re.compile(r'^[ \t\f]*#.*?coding[:=][ \t]*([-\w.]+)', re.ASCII)
blank_re = re.compile(br'^[ \t\f]*(?:[#\r\n]|$)', re.ASCII)

import token
__all__ = token.__all__ + ["tokenize", "generate_tokens", "detect_encoding",
                           "untokenize", "TokenInfo", "open", "TokenError"]
del token

class TokenInfo(collections.namedtuple('TokenInfo', 'type string start end line')):
    def __repr__(self):
        annotated_type = '%d (%s)' % (self.type, tok_name[self.type])
        return ('TokenInfo(type=%s, string=%r, start=%r, end=%r, line=%r)' %
                self._replace(type=annotated_type))

    @property
    def exact_type(self):
        if self.type == OP and self.string in EXACT_TOKEN_TYPES:
            return EXACT_TOKEN_TYPES[self.string]
        else:
            return self.type

def group(*choices): return '(' + '|'.join(choices) + ')'
def any(*choices): return group(*choices) + '*'
def maybe(*choices): return group(*choices) + '?'

# Note: we use unicode matching for names ("\w") but ascii matching for
# number literals.
Whitespace = r'[ \f\t]*'
Comment = r'#[^\r\n]*'
Ignore = Whitespace + any(r'\\\r?\n' + Whitespace) + maybe(Comment)
Name = r'\w+'

Hexnumber = r'0[xX](?:_?[0-9a-fA-F])+'
Binnumber = r'0[bB](?:_?[01])+'
Octnumber = r'0[oO](?:_?[0-7])+'
Decnumber = r'(?:0(?:_?0)*|[1-9](?:_?[0-9])*)'
Intnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber)
Exponent = r'[eE][-+]?[0-9](?:_?[0-9])*'
Pointfloat = group(r'[0-9](?:_?[0-9])*\.(?:[0-9](?:_?[0-9])*)?',
                   r'\.[0-9](?:_?[0-9])*') + maybe(Exponent)
Expfloat = r'[0-9](?:_?[0-9])*' + Exponent
Floatnumber = group(Pointfloat, Expfloat)
Imagnumber = group(r'[0-9](?:_?[0-9])*[jJ]', Floatnumber + r'[jJ]')
Number = group(Imagnumber, Floatnumber, Intnumber)

# Return the empty string, plus all of the valid string prefixes.
def _all_string_prefixes():
    # The valid string prefixes. Only contain the lower case versions,
    #  and don't contain any permutations (include 'fr', but not
    #  'rf'). The various permutations will be generated.
    _valid_string_prefixes = ['b', 'r', 'u', 'f', 'br', 'fr']
    # if we add binary f-strings, add: ['fb', 'fbr']
    result = {''}
    for prefix in _valid_string_prefixes:
        for t in _itertools.permutations(prefix):
            # create a list with upper and lower versions of each
            #  character
            for u in _itertools.product(*[(c, c.upper()) for c in t]):
                result.add(''.join(u))
    return result

@functools.lru_cache
def _compile(expr):
    return re.compile(expr, re.UNICODE)

# Note that since _all_string_prefixes includes the empty string,
#  StringPrefix can be the empty string (making it optional).
StringPrefix = group(*_all_string_prefixes())

# Tail end of ' string.
Single = r"[^'\\]*(?:\\.[^'\\]*)*'"
# Tail end of " string.
Double = r'[^"\\]*(?:\\.[^"\\]*)*"'
# Tail end of ''' string.
Single3 = r"[^'\\]*(?:(?:\\.|'(?!''))[^'\\]*)*'''"
# Tail end of """ string.
Double3 = r'[^"\\]*(?:(?:\\.|"(?!""))[^"\\]*)*"""'
Triple = group(StringPrefix + "'''", StringPrefix + '"""')
# Single-line ' or " string.
String = group(StringPrefix + r"'[^\n'\\]*(?:\\.[^\n'\\]*)*'",
               StringPrefix + r'"[^\n"\\]*(?:\\.[^\n"\\]*)*"')

# Sorting in reverse order puts the long operators before their prefixes.
# Otherwise if = came before ==, == would get recognized as two instances
# of =.
Special = group(*map(re.escape, sorted(EXACT_TOKEN_TYPES, reverse=True)))
Funny = group(r'\r?\n', Special)

PlainToken = group(Number, Funny, String, Name)
Token = Ignore + PlainToken

# First (or only) line of ' or " string.
ContStr = group(StringPrefix + r"'[^\n'\\]*(?:\\.[^\n'\\]*)*" +
                group("'", r'\\\r?\n'),
                StringPrefix + r'"[^\n"\\]*(?:\\.[^\n"\\]*)*' +
                group('"', r'\\\r?\n'))
PseudoExtras = group(r'\\\r?\n|\Z', Comment, Triple)
PseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)

# For a given string prefix plus quotes, endpats maps it to a regex
#  to match the remainder of that string. _prefix can be empty, for
#  a normal single or triple quoted string (with no prefix).
endpats = {}
for _prefix in _all_string_prefixes():
    endpats[_prefix + "'"] = Single
    endpats[_prefix + '"'] = Double
    endpats[_prefix + "'''"] = Single3
    endpats[_prefix + '"""'] = Double3
del _prefix

# A set of all of the single and triple quoted string prefixes,
#  including the opening quotes.
single_quoted = set()
triple_quoted = set()
for t in _all_string_prefixes():
    for u in (t + '"', t + "'"):
        single_quoted.add(u)
    for u in (t + '"""', t + "'''"):
        triple_quoted.add(u)
del t, u

tabsize = 8

class TokenError(Exception): pass


class Untokenizer:

    def __init__(self):
        self.tokens = []
        self.prev_row = 1
        self.prev_col = 0
        self.prev_type = None
        self.prev_line = ""
        self.encoding = None

    def add_whitespace(self, start):
        row, col = start
        if row < self.prev_row or row == self.prev_row and col < self.prev_col:
            raise ValueError("start ({},{}) precedes previous end ({},{})"
                             .format(row, col, self.prev_row, self.prev_col))
        self.add_backslash_continuation(start)
        col_offset = col - self.prev_col
        if col_offset:
            self.tokens.append(" " * col_offset)

    def add_backslash_continuation(self, start):
        """Add backslash continuation characters if the row has increased
        without encountering a newline token.

        This also inserts the correct amount of whitespace before the backslash.
        """
        row = start[0]
        row_offset = row - self.prev_row
        if row_offset == 0:
            return

        newline = '\r\n' if self.prev_line.endswith('\r\n') else '\n'
        line = self.prev_line.rstrip('\\\r\n')
        ws = ''.join(_itertools.takewhile(str.isspace, reversed(line)))
        self.tokens.append(ws + f"\\{newline}" * row_offset)
        self.prev_col = 0

    def escape_brackets(self, token):
        characters = []
        consume_until_next_bracket = False
        for character in token:
            if character == "}":
                if consume_until_next_bracket:
                    consume_until_next_bracket = False
                else:
                    characters.append(character)
            if character == "{":
                n_backslashes = sum(
                    1 for char in _itertools.takewhile(
                        "\\".__eq__,
                        characters[-2::-1]
                    )
                )
                if n_backslashes % 2 == 0 or characters[-1] != "N":
                    characters.append(character)
                else:
                    consume_until_next_bracket = True
            characters.append(character)
        return "".join(characters)

    def untokenize(self, iterable):
        it = iter(iterable)
        indents = []
        startline = False
        for t in it:
            if len(t) == 2:
                self.compat(t, it)
                break
            tok_type, token, start, end, line = t
            if tok_type == ENCODING:
                self.encoding = token
                continue
            if tok_type == ENDMARKER:
                break
            if tok_type == INDENT:
                indents.append(token)
                continue
            elif tok_type == DEDENT:
                indents.pop()
                self.prev_row, self.prev_col = end
                continue
            elif tok_type in (NEWLINE, NL):
                startline = True
            elif startline and indents:
                indent = indents[-1]
                if start[1] >= len(indent):
                    self.tokens.append(indent)
                    self.prev_col = len(indent)
                startline = False
            elif tok_type == FSTRING_MIDDLE:
                if '{' in token or '}' in token:
                    token = self.escape_brackets(token)
                    last_line = token.splitlines()[-1]
                    end_line, end_col = end
                    extra_chars = last_line.count("{{") + last_line.count("}}")
                    end = (end_line, end_col + extra_chars)

            self.add_whitespace(start)
            self.tokens.append(token)
            self.prev_row, self.prev_col = end
            if tok_type in (NEWLINE, NL):
                self.prev_row += 1
                self.prev_col = 0
            self.prev_type = tok_type
            self.prev_line = line
        return "".join(self.tokens)

    def compat(self, token, iterable):
        indents = []
        toks_append = self.tokens.append
        startline = token[0] in (NEWLINE, NL)
        prevstring = False
        in_fstring = 0

        for tok in _itertools.chain([token], iterable):
            toknum, tokval = tok[:2]
            if toknum == ENCODING:
                self.encoding = tokval
                continue

            if toknum in (NAME, NUMBER):
                tokval += ' '

            # Insert a space between two consecutive strings
            if toknum == STRING:
                if prevstring:
                    tokval = ' ' + tokval
                prevstring = True
            else:
                prevstring = False

            if toknum == FSTRING_START:
                in_fstring += 1
            elif toknum == FSTRING_END:
                in_fstring -= 1
            if toknum == INDENT:
                indents.append(tokval)
                continue
            elif toknum == DEDENT:
                indents.pop()
                continue
            elif toknum in (NEWLINE, NL):
                startline = True
            elif startline and indents:
                toks_append(indents[-1])
                startline = False
            elif toknum == FSTRING_MIDDLE:
                tokval = self.escape_brackets(tokval)

            # Insert a space between two consecutive brackets if we are in an f-string
            if tokval in {"{", "}"} and self.tokens and self.tokens[-1] == tokval and in_fstring:
                tokval = ' ' + tokval

            # Insert a space between two consecutive f-strings
            if toknum in (STRING, FSTRING_START) and self.prev_type in (STRING, FSTRING_END):
                self.tokens.append(" ")

            toks_append(tokval)
            self.prev_type = toknum


def untokenize(iterable):
    """Transform tokens back into Python source code.
    It returns a bytes object, encoded using the ENCODING
    token, which is the first token sequence output by tokenize.

    Each element returned by the iterable must be a token sequence
    with at least two elements, a token number and token value.  If
    only two tokens are passed, the resulting output is poor.

    The result is guaranteed to tokenize back to match the input so
    that the conversion is lossless and round-trips are assured.
    The guarantee applies only to the token type and token string as
    the spacing between tokens (column positions) may change.
    """
    ut = Untokenizer()
    out = ut.untokenize(iterable)
    if ut.encoding is not None:
        out = out.encode(ut.encoding)
    return out


def _get_normal_name(orig_enc):
    """Imitates get_normal_name in Parser/tokenizer/helpers.c."""
    # Only care about the first 12 characters.
    enc = orig_enc[:12].lower().replace("_", "-")
    if enc == "utf-8" or enc.startswith("utf-8-"):
        return "utf-8"
    if enc in ("latin-1", "iso-8859-1", "iso-latin-1") or \
       enc.startswith(("latin-1-", "iso-8859-1-", "iso-latin-1-")):
        return "iso-8859-1"
    return orig_enc

def detect_encoding(readline):
    """
    The detect_encoding() function is used to detect the encoding that should
    be used to decode a Python source file.  It requires one argument, readline,
    in the same way as the tokenize() generator.

    It will call readline a maximum of twice, and return the encoding used
    (as a string) and a list of any lines (left as bytes) it has read in.

    It detects the encoding from the presence of a utf-8 bom or an encoding
    cookie as specified in pep-0263.  If both a bom and a cookie are present,
    but disagree, a SyntaxError will be raised.  If the encoding cookie is an
    invalid charset, raise a SyntaxError.  Note that if a utf-8 bom is found,
    'utf-8-sig' is returned.

    If no encoding is specified, then the default of 'utf-8' will be returned.
    """
    try:
        filename = readline.__self__.name
    except AttributeError:
        filename = None
    bom_found = False
    encoding = None
    default = 'utf-8'
    def read_or_stop():
        try:
            return readline()
        except StopIteration:
            return b''

    def find_cookie(line):
        try:
            # Decode as UTF-8. Either the line is an encoding declaration,
            # in which case it should be pure ASCII, or it must be UTF-8
            # per default encoding.
            line_string = line.decode('utf-8')
        except UnicodeDecodeError:
            msg = "invalid or missing encoding declaration"
            if filename is not None:
                msg = '{} for {!r}'.format(msg, filename)
            raise SyntaxError(msg)

        match = cookie_re.match(line_string)
        if not match:
            return None
        encoding = _get_normal_name(match.group(1))
        try:
            codec = lookup(encoding)
        except LookupError:
            # This behaviour mimics the Python interpreter
            if filename is None:
                msg = "unknown encoding: " + encoding
            else:
                msg = "unknown encoding for {!r}: {}".format(filename,
                        encoding)
            raise SyntaxError(msg)

        if bom_found:
            if encoding != 'utf-8':
                # This behaviour mimics the Python interpreter
                if filename is None:
                    msg = 'encoding problem: utf-8'
                else:
                    msg = 'encoding problem for {!r}: utf-8'.format(filename)
                raise SyntaxError(msg)
            encoding += '-sig'
        return encoding

    first = read_or_stop()
    if first.startswith(BOM_UTF8):
        bom_found = True
        first = first[3:]
        default = 'utf-8-sig'
    if not first:
        return default, []

    encoding = find_cookie(first)
    if encoding:
        return encoding, [first]
    if not blank_re.match(first):
        return default, [first]

    second = read_or_stop()
    if not second:
        return default, [first]

    encoding = find_cookie(second)
    if encoding:
        return encoding, [first, second]

    return default, [first, second]


def open(filename):
    """Open a file in read only mode using the encoding detected by
    detect_encoding().
    """
    buffer = _builtin_open(filename, 'rb')
    try:
        encoding, lines = detect_encoding(buffer.readline)
        buffer.seek(0)
        text = TextIOWrapper(buffer, encoding, line_buffering=True)
        text.mode = 'r'
        return text
    except:
        buffer.close()
        raise

def tokenize(readline):
    """
    The tokenize() generator requires one argument, readline, which
    must be a callable object which provides the same interface as the
    readline() method of built-in file objects.  Each call to the function
    should return one line of input as bytes.  Alternatively, readline
    can be a callable function terminating with StopIteration:
        readline = open(myfile, 'rb').__next__  # Example of alternate readline

    The generator produces 5-tuples with these members: the token type; the
    token string; a 2-tuple (srow, scol) of ints specifying the row and
    column where the token begins in the source; a 2-tuple (erow, ecol) of
    ints specifying the row and column where the token ends in the source;
    and the line on which the token was found.  The line passed is the
    physical line.

    The first token sequence will always be an ENCODING token
    which tells you which encoding was used to decode the bytes stream.
    """
    encoding, consumed = detect_encoding(readline)
    rl_gen = _itertools.chain(consumed, iter(readline, b""))
    if encoding is not None:
        if encoding == "utf-8-sig":
            # BOM will already have been stripped.
            encoding = "utf-8"
        yield TokenInfo(ENCODING, encoding, (0, 0), (0, 0), '')
    yield from _generate_tokens_from_c_tokenizer(rl_gen.__next__, encoding, extra_tokens=True)

def generate_tokens(readline):
    """Tokenize a source reading Python code as unicode strings.

    This has the same API as tokenize(), except that it expects the *readline*
    callable to return str objects instead of bytes.
    """
    return _generate_tokens_from_c_tokenizer(readline, extra_tokens=True)

def main():
    import argparse

    # Helper error handling routines
    def perror(message):
        sys.stderr.write(message)
        sys.stderr.write('\n')

    def error(message, filename=None, location=None):
        if location:
            args = (filename,) + location + (message,)
            perror("%s:%d:%d: error: %s" % args)
        elif filename:
            perror("%s: error: %s" % (filename, message))
        else:
            perror("error: %s" % message)
        sys.exit(1)

    # Parse the arguments and options
    parser = argparse.ArgumentParser(prog='python -m tokenize')
    parser.add_argument(dest='filename', nargs='?',
                        metavar='filename.py',
                        help='the file to tokenize; defaults to stdin')
    parser.add_argument('-e', '--exact', dest='exact', action='store_true',
                        help='display token names using the exact type')
    args = parser.parse_args()

    try:
        # Tokenize the input
        if args.filename:
            filename = args.filename
            with _builtin_open(filename, 'rb') as f:
                tokens = list(tokenize(f.readline))
        else:
            filename = "<stdin>"
            tokens = _generate_tokens_from_c_tokenizer(
                sys.stdin.readline, extra_tokens=True)


        # Output the tokenization
        for token in tokens:
            token_type = token.type
            if args.exact:
                token_type = token.exact_type
            token_range = "%d,%d-%d,%d:" % (token.start + token.end)
            print("%-20s%-15s%-15r" %
                  (token_range, tok_name[token_type], token.string))
    except IndentationError as err:
        line, column = err.args[1][1:3]
        error(err.args[0], filename, (line, column))
    except TokenError as err:
        line, column = err.args[1]
        error(err.args[0], filename, (line, column))
    except SyntaxError as err:
        error(err, filename)
    except OSError as err:
        error(err)
    except KeyboardInterrupt:
        print("interrupted\n")
    except Exception as err:
        perror("unexpected error: %s" % err)
        raise

def _transform_msg(msg):
    """Transform error messages from the C tokenizer into the Python tokenize

    The C tokenizer is more picky than the Python one, so we need to massage
    the error messages a bit for backwards compatibility.
    """
    if "unterminated triple-quoted string literal" in msg:
        return "EOF in multi-line string"
    return msg

def _generate_tokens_from_c_tokenizer(source, encoding=None, extra_tokens=False):
    """Tokenize a source reading Python code as unicode strings using the internal C tokenizer"""
    if encoding is None:
        it = _tokenize.TokenizerIter(source, extra_tokens=extra_tokens)
    else:
        it = _tokenize.TokenizerIter(source, encoding=encoding, extra_tokens=extra_tokens)
    try:
        for info in it:
            yield TokenInfo._make(info)
    except SyntaxError as e:
        if type(e) != SyntaxError:
            raise e from None
        msg = _transform_msg(e.msg)
        raise TokenError(msg, (e.lineno, e.offset)) from None


if __name__ == "__main__":
    main()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Ž   .   ú   ..     __init__.py    __pycache__ •   
_parser.py  –   _re.py  —   	_types.py   ˜  ˆmypy.ini                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2021 Taneli Hukkinen
# Licensed to PSF under a Contributor Agreement.

__all__ = ("loads", "load", "TOMLDecodeError")

from ._parser import TOMLDecodeError, load, loads

# Pretend this exception was created here.
TOMLDecodeError.__module__ = __name__
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .   Ž   ..  ‘    __init__.cpython-313.pyc’    _parser.cpython-313.pyc “   _re.cpython-313.pyc ”  Œ_types.cpython-313.pyc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ó
    F\h4  ã                   ó*   • S r SSKJrJrJr  \\l        g))ÚloadsÚloadÚTOMLDecodeErroré   )r   r   r   N)Ú__all__Ú_parserr   r   r   Ú__name__Ú
__module__© ó    Ú'/usr/lib/python3.13/tomllib/__init__.pyÚ<module>r      s   ðð
 /€ç 1Ñ 1ð &€Õ r                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ó
    F\hŠX  ã            
      ó€  • S SK Jr  S SKJr  S SKrS SKJr  S SKJrJ	r	J
r
  SSKJrJrJrJrJrJr  SSKJrJrJr  \" S	 \" S
5       5       5      \" \" S5      5      -  r\\" S5      -
  r\\" S5      -
  r\r\r\r\" S5      r\\" S5      -  r \" \RB                  \RD                  -   S-   5      r#\#\" S5      -  r$\" \RJ                  5      r&\" SSSSSSSS.5      r' " S S\(5      r)\*S.S<S jjr+\*S.S=S jjr, " S S5      r- " S S 5      r. " S! S"\
5      r/S>S# jr0            S?S$ jr1S@S% jr2S@S& jr3SAS' jr4SAS( jr5            SBS) jr6        SCS* jr7SDS+ jr8SES, jr9SES- jr:SFS. jr;SGS/ jr<S0S1.       SHS2 jjr=SES3 jr>SIS4 jr?SES5 jr@SJS6 jrASHS7 jrB        SKS8 jrCSLS9 jrDSMS: jrESNS; jrFg)Oé    )Úannotations)ÚIterableN)ÚMappingProxyType)ÚAnyÚBinaryIOÚ
NamedTupleé   )ÚRE_DATETIMEÚRE_LOCALTIMEÚ	RE_NUMBERÚmatch_to_datetimeÚmatch_to_localtimeÚmatch_to_number)ÚKeyÚ
ParseFloatÚPosc              #  ó8   #   • U  H  n[        U5      v •  M     g 7f©N)Úchr)Ú.0Úis     Ú&/usr/lib/python3.13/tomllib/_parser.pyÚ	<genexpr>r      s   é € Ð1¢y !”s˜1—vv¢yùs   ‚é    é   Ú	z	
z 	Ú
z-_z"'ÚÚÚÚ"Ú\)z\bz\tz\nz\fz\rz\"z\\c                  ó   • \ rS rSrSrSrg)ÚTOMLDecodeErroré5   z0An error raised if a document is not valid TOML.© N)Ú__name__Ú
__module__Ú__qualname__Ú__firstlineno__Ú__doc__Ú__static_attributes__r&   ó    r   r$   r$   5   s   † Ü:r-   r$   ©Úparse_floatc              óŠ   • U R                  5       n UR                  5       n[	        X1S9$ ! [         a    [        S5      Sef = f)z%Parse TOML from a binary file object.zEFile must be opened in binary mode, e.g. use `open('foo.toml', 'rb')`Nr.   )ÚreadÚdecodeÚAttributeErrorÚ	TypeErrorÚloads)Úfpr/   ÚbÚss       r   Úloadr9   9   sN   € à
‰‹	€AðØH‰H‹Jˆô
 Ñ,Ð,øô	 ó ÜØSó
àð	ðús	   ’+ «Ac              óø  • U R                  SS5      nSn[        [        5       [        5       5      nSn[	        U5      n [        X#[        5      n X#   nUS:X  a  US-  nM#  U[        ;   a  [        X#XEU5      n[        X#[        5      nOnUS:X  aV   X#S-      nUR                  R                  5         US:X  a  [        X#U5      u  p5O[        X#U5      u  p5[        X#[        5      nOUS:w  a  [        X#S	5      e[        X#5      n X#   nUS:w  a  [        X#S
5      eUS-  nMá  ! [         a     UR                   R"                  $ f = f! [         a    Sn N¼f = f! [         a     UR                   R"                  $ f = f)zParse TOML from a string.z
r   r   r&   r	   Ú[NÚ#zInvalid statementz5Expected newline or end of document after a statement)ÚreplaceÚOutputÚ
NestedDictÚFlagsÚmake_safe_parse_floatÚ
skip_charsÚTOML_WSÚ
IndexErrorÚKEY_INITIAL_CHARSÚkey_value_ruleÚflagsÚfinalize_pendingÚcreate_list_ruleÚcreate_dict_ruleÚsuffixed_errÚskip_commentÚdataÚdict)r8   r/   ÚsrcÚposÚoutÚheaderÚcharÚsecond_chars           r   r5   r5   E   s   € ð
 )‰)F˜DÓ
!€CØ
€CÜ
”“œu›wÓ
'€CØ€FÜ'¨Ó4€Kð ä˜¤7Ó+ˆð	Ø‘8ˆDð 4‹<Ø1‰HˆCÙØÔ$Ó$Ü  ¨3¸ÓDˆCÜ˜S¤wÓ/‰CØS‹[ð#Ø*-°A©g©,ð I‰I×&Ñ&Ô(Ø˜cÓ!Ü.¨s¸Ó=‘Vä.¨s¸Ó=‘Ü˜S¤wÓ/‰CØS‹[Ü˜sÐ)<Ó=Ð=ô ˜3Ó$ˆð	Ø‘8ˆDð 4‹<ÜØÐQóð ð 	ˆq‰ˆña øô ó 	ØðF 8‰8=‰=ÐðI	ûô ó #Ø"’ð#ûô" ó 	Øð 8‰8=‰=Ðð	ús6   ÁD  ÂE ÄE Ä 
EÅEÅEÅEÅ
E9Å8E9c                  ó\   • \ rS rSrSrSrSrSS jrSS jrSS jr	SS jr
SS	 jrSS
 jrSrg)r@   é‡   z)Flags that map to parsed keys/namespaces.r   r	   c                ó0   • 0 U l         [        5       U l        g r   )Ú_flagsÚsetÚ_pending_flags©Úselfs    r   Ú__init__ÚFlags.__init__   s   € Ø13ˆŒÜ47³EˆÕr-   c                ó<   • U R                   R                  X45        g r   )rZ   Úadd©r\   ÚkeyÚflags      r   Úadd_pendingÚFlags.add_pending”   s   € Ø×Ñ×Ñ  Õ,r-   c                ó‚   • U R                    H  u  pU R                  XSS9  M     U R                   R                  5         g )NF©Ú	recursive)rZ   rY   Úclearra   s      r   rH   ÚFlags.finalize_pending—   s6   € Ø×,Ô,‰IˆCØH‰HS¨%ˆHÓ0ñ -à×Ñ×!Ñ!Õ#r-   c                óz   • U R                   nUS S  H  nX2;  a    g X#   S   nM     UR                  US   S 5        g )NéÿÿÿÿÚnested)rX   Úpop)r\   rb   ÚcontÚks       r   Ú	unset_allÚFlags.unset_allœ   sC   € Ø{‰{ˆØSb“ˆAØ‹}ÙØ‘7˜8Ñ$ŠDñ ð 	‰R‘˜$Õr-   c               ó   • U R                   nUS S US   peU H'  nXt;  a  [        5       [        5       0 S.XG'   XG   S   nM)     Xd;  a  [        5       [        5       0 S.XF'   XF   U(       a  SOS   R                  U5        g )Nrl   )rG   Úrecursive_flagsrm   rm   rt   rG   )rX   rY   r`   )r\   rb   rc   rh   ro   Ú
key_parentÚkey_stemrp   s           r   rY   Ú	Flags.set¤   s~   € Ø{‰{ˆØ" 3 B˜x¨¨R©HÛˆAØ‹}Ü$'£E¼c»eÈrÑR‘Ø‘7˜8Ñ$ŠDñ ð ÓÜ'*£uÄÃÐRTÑUˆD‰NØ‰®IÑ(¸7ÑC×GÑGÈÕMr-   c                ó¾   • U(       d  gU R                   nUS S  H  nXC;  a    gX4   nX%S   ;   a    gUS   nM     US   nXc;   a  X6   nX#S   ;   =(       d    X#S   ;   $ g)NFrl   rt   Trm   rG   )rX   )r\   rb   rc   ro   rp   Ú
inner_contrv   s          r   Úis_Ú	Flags.is_¯   s   € ÞØØ{‰{ˆØSb“ˆAØ‹}ÙØ™ˆJØÐ"3Ñ4Ó4ÙØ˜hÑ'ŠDñ ð r‘7ˆØÓØ‘>ˆDØ ™=Ñ(×K¨DÐ9JÑ4KÑ,KÐKØr-   )rX   rZ   N©ÚreturnÚNone)rb   r   rc   Úintr}   r~   ©rb   r   r}   r~   )rb   r   rc   r   rh   Úboolr}   r~   )rb   r   rc   r   r}   r   )r'   r(   r)   r*   r+   ÚFROZENÚEXPLICIT_NESTr]   rd   rH   rq   rY   rz   r,   r&   r-   r   r@   r@   ‡   s2   † Ù3ð €Fð €Mô:ô-ô$ô
 ô	N÷r-   r@   c                  óD   • \ rS rSrS	S jrSS.     S
S jjrSS jrSrg)r?   éÁ   c                ó   • 0 U l         g r   ©rN   r[   s    r   r]   ÚNestedDict.__init__Â   s	   € à$&ˆ	r-   T©Úaccess_listsc               óÌ   • U R                   nU HQ  nXC;  a  0 X4'   X4   nU(       a  [        U[        5      (       a  US   n[        U[         5      (       a  MH  [        S5      e   U$ )Nrl   z There is no nest behind this key)rN   Ú
isinstanceÚlistÚKeyError)r\   rb   rŠ   ro   rp   s        r   Úget_or_create_nestÚNestedDict.get_or_create_nestÆ   sb   € ð —I‘IˆÛˆAØ‹}Ø‘Ø‘7ˆDÞ¤
¨4´× 6Ñ 6Ø˜B‘xÜ˜d¤D×)Ó)ÜÐAÓBÐBñ ð ˆr-   c                ó¶   • U R                  US S 5      nUS   nX2;   a6  X#   n[        U[        5      (       d  [        S5      eUR	                  0 5        g 0 /X#'   g )Nrl   z/An object other than list found behind this key)r   rŒ   r   rŽ   Úappend)r\   rb   ro   Úlast_keyÚlist_s        r   Úappend_nest_to_listÚNestedDict.append_nest_to_list×   s\   € Ø×&Ñ& s¨3¨B xÓ0ˆØr‘7ˆØÓØ‘NˆEÜ˜e¤T×*Ñ*ÜÐPÓQÐQØL‰L˜Õà ˜TˆDŠNr-   r‡   Nr|   )rb   r   rŠ   r   r}   údict[str, Any]r€   )r'   r(   r)   r*   r]   r   r•   r,   r&   r-   r   r?   r?   Á   s2   † ô'ð "ñ	àðð ð	ð
 
õ÷"	"r-   r?   c                  ó*   • \ rS rSr% S\S'   S\S'   Srg)r>   éã   r?   rM   r@   rG   r&   N)r'   r(   r)   r*   Ú__annotations__r,   r&   r-   r   r>   r>   ã   s   ‡ Ø
ÓØ†Lr-   r>   c                óX   •  X   U;   a  US-  nX   U;   a  M  U$ ! [          a     U$ f = f)Nr	   )rD   )rO   rP   Úcharss      r   rB   rB   è   sF   € ðØ‰h˜%ÓØ1‰HˆCð ‰h˜%Õð €Jøô ó ØØ€Jðús   ‚ ›
)¨)c               ó  •  U R                  X!5      nUR	                  XU 5      (       d)  X   U;  a  US-  nX   U;  a  M  [        XSX   < 35      eU$ ! [         a&    [        U 5      nU(       a  [        XSU< 35      S e Nrf = f)Nz	Expected r	   zFound invalid character )ÚindexÚ
ValueErrorÚlenrK   Ú
isdisjoint)rO   rP   ÚexpectÚerror_onÚerror_on_eofÚnew_poss         r   Ú
skip_untilr¦   ñ   s£   € ðOØ—)‘)˜FÓ(ˆð ×Ñ˜s wÐ/×0Ñ0Ø‰h˜hÓ&Ø1‰HˆCð ‰h˜hÕ&ä˜3Ð'?ÀÁ¹|Ð%LÓMÐMØ€Nøô ó OÜc“(ˆÞÜ˜s¨y¸¹
Ð-CÓDÈ$ÐNñ ðOús   ‚A Á-BÂBc                óf   •  X   nUS:X  a  [        XS-   S[        SS9$ U$ ! [          a    S n N)f = f)Nr<   r	   r   F©r£   r¤   )rD   r¦   ÚILLEGAL_COMMENT_CHARS)rO   rP   rS   s      r   rL   rL     sO   € ðØ™8ˆð ˆsƒ{ÜØq‘˜$Ô)>ÈUñ
ð 	
ð €Jøô ó ØŠðús   ‚! ¡0¯0c                óP   •  Un[        X[        5      n[        X5      nX:X  a  U$ M&  r   )rB   ÚTOML_WS_AND_NEWLINErL   )rO   rP   Úpos_before_skips      r   Úskip_comments_and_array_wsr­     s1   € Ø
ØˆÜ˜Ô#6Ó7ˆÜ˜3Ó$ˆØÓ!ØˆJñ r-   c                ó6  • US-  n[        X[        5      n[        X5      u  pUR                  R	                  U[
        R                  5      (       d/  UR                  R	                  U[
        R                  5      (       a  [        XSU S35      eUR                  R                  U[
        R                  SS9   UR                  R                  U5        U R                  SU5      (       d  [        XS5      eUS-   U4$ ! [         a    [        XS5      S ef = f)	Nr	   zCannot declare z twiceFrg   úCannot overwrite a valueÚ]z.Expected ']' at the end of a table declaration)rB   rC   Ú	parse_keyrG   rz   r@   rƒ   r‚   rK   rY   rM   r   rŽ   Ú
startswith©rO   rP   rQ   rb   s       r   rJ   rJ     sò   € Øˆ1H€CÜ
SœwÓ
'€CÜ˜Ó"H€Cà
‡yy‡}}Sœ%×-Ñ-×.Ñ.°#·)±)·-±-ÀÄUÇ\Á\×2RÑ2RÜ˜3 °s°e¸6Ð%BÓCÐCØ‡II‡MM#”u×*Ñ*°e€MÑ<ðKØ‰×#Ñ# CÔ(ð >‰>˜#˜s×#Ñ#Ü˜3Ð%UÓVÐVØ‰7Cˆ<Ðøô ó KÜ˜3Ð%?Ó@ÀdÐJðKús   Â;D  Ä Dc                ó  • US-  n[        X[        5      n[        X5      u  pUR                  R	                  U[
        R                  5      (       a  [        XSU 35      eUR                  R                  U5        UR                  R                  U[
        R                  SS9   UR                  R                  U5        U R                  SU5      (       d  [        XS5      eUS-   U4$ ! [         a    [        XS5      S ef = f)Né   ú"Cannot mutate immutable namespace Frg   r¯   z]]z0Expected ']]' at the end of an array declaration)rB   rC   r±   rG   rz   r@   r‚   rK   rq   rY   rƒ   rM   r•   rŽ   r²   r³   s       r   rI   rI   .  sé   € Øˆ1H€CÜ
SœwÓ
'€CÜ˜Ó"H€Cà
‡yy‡}}Sœ%Ÿ,™,×'Ñ'Ü˜3Ð'IÈ#ÈÐ%OÓPÐPà‡II×Ñ˜Ôà‡II‡MM#”u×*Ñ*°e€MÑ<ðKØ‰×$Ñ$ SÔ)ð >‰>˜$ ×$Ñ$Ü˜3Ð%WÓXÐXØ‰7Cˆ<Ðøô ó KÜ˜3Ð%?Ó@ÀdÐJðKús   Â&C+ Ã+Dc                ó
  ^^• [        XU5      u  nmnTS S TS   pvTU-   nUU4S j[        S[        T5      5       5       n	U	 Hk  n
UR                  R	                  U
[
        R                  5      (       a  [        XSU
 35      eUR                  R                  U
[
        R                  5        Mm     UR                  R	                  U[
        R                  5      (       a  [        XSU 35      e UR                  R                  U5      nX{;   a  [        XS5      e[        U[        [        45      (       a,  UR                  R!                  TT-   [
        R                  SS9  X[U'   U$ ! [         a    [        XS5      S ef = f)	Nrl   c              3  ó4   >#   • U  H  nTTS U -   v •  M     g 7fr   r&   )r   r   rR   rb   s     €€r   r   Ú!key_value_rule.<locals>.<genexpr>J  s   øé € ÐLÒ9K°A˜v¨¨B¨Q¨Ö/Ò9Kùs   ƒr	   zCannot redefine namespace r¶   r¯   Trg   )Úparse_key_value_pairÚranger    rG   rz   r@   rƒ   rK   rd   r‚   rM   r   rŽ   rŒ   rN   r   rY   )rO   rP   rQ   rR   r/   Úvalueru   rv   Úabs_key_parentÚrelative_path_cont_keysÚcont_keyÚnestrb   s      `        @r   rF   rF   C  sb  ù€ ô +¨3°[ÓAO€CˆˆeØ˜s ˜8 S¨¡WØ˜jÑ(€NåL¼¸qÄ#ÀcÃ(Ô9KÓLÐÛ+ˆà9‰9=‰=˜¤5×#6Ñ#6×7Ñ7Ü˜sÐ+EÀhÀZÐ)PÓQÐQð 		‰	×Ñ˜h¬×(;Ñ(;Ö<ñ ,ð ‡yy‡}}^¤U§\¡\×2Ñ2ÜØÐ:¸>Ð:JÐKó
ð 	
ðKØx‰x×*Ñ*¨>Ó:ˆð ÓÜ˜3Ð%?Ó@Ð@ä%œ$¤˜×&Ñ&Ø	‰	‰f˜s‘l¤E§L¡L¸DˆÑAØˆNØ€Jøô ó KÜ˜3Ð%?Ó@ÀdÐJðKús   Ã1E* Å*Fc                ó¼   • [        X5      u  p X   nUS:w  a  [        XS5      eUS-  n[        X[        5      n[        XU5      u  pXU4$ ! [         a    S n NGf = f)NÚ=z,Expected '=' after a key in a key/value pairr	   )r±   rD   rK   rB   rC   Úparse_value)rO   rP   r/   rb   rS   r¼   s         r   rº   rº   e  sv   € ô ˜Ó"H€CðØ™8ˆð ˆsƒ{Ü˜3Ð%SÓTÐTØˆ1H€CÜ
SœwÓ
'€CÜ˜S {Ó3J€CØUˆ?Ðøô ó ØŠðús   A ÁAÁAc                óö   • [        X5      u  pU4n[        X[        5      n  X   nUS:w  a  X4$ US-  n[        X[        5      n[        X5      u  pX24-  n[        X[        5      nMG  ! [         a    S n NPf = f)NÚ.r	   )Úparse_key_partrB   rC   rD   )rO   rP   Úkey_partrb   rS   s        r   r±   r±   u  s’   € Ü" 3Ó,M€CØˆ{€CÜ
SœwÓ
'€CØ
ð	Ø"™xˆDð 3‹;Ø8ˆOØˆq‰ˆÜ˜¤7Ó+ˆÜ& sÓ0‰ˆØˆ{ÑˆÜ˜¤7Ó+ˆñ øô ó 	ØŠDð	ús   £A) Á)A8Á7A8c                óÎ   •  X   nU[        ;   a  Un[        X[        5      nXX1 4$ US:X  a  [        X5      $ US:X  a  [	        X5      $ [        XS5      e! [          a    S n N]f = f)NÚ'r!   z(Invalid initial character for a key part)rD   ÚBARE_KEY_CHARSrB   Úparse_literal_strÚparse_one_line_basic_strrK   )rO   rP   rS   Ú	start_poss       r   rÆ   rÆ   ‡  s   € ðØ™8ˆð Œ~ÓØˆ	Ü˜¤>Ó2ˆØ˜	Ð&Ð&Ð&Øˆsƒ{Ü  Ó*Ð*Øˆsƒ{Ü'¨Ó1Ð1Ü
sÐ!KÓ
LÐLøô ó ØŠðús   ‚A ÁA$Á#A$c                ó    • US-  n[        XSS9$ )Nr	   F©Ú	multiline)Úparse_basic_str©rO   rP   s     r   rÌ   rÌ   —  s   € Øˆ1H€CÜ˜3¨uÑ5Ð5r-   c                ód  • US-  n/ n[        X5      nU R                  SU5      (       a  US-   U4$  [        XU5      u  pUR                  U5        [        X5      nXUS-    nUS:X  a  US-   U4$ US:w  a  [	        XS5      eUS-  n[        X5      nU R                  SU5      (       a  US-   U4$ M€  )Nr	   r°   Ú,zUnclosed array)r­   r²   rÃ   r’   rK   )rO   rP   r/   ÚarrayÚvalÚcs         r   Úparse_arrayrØ   œ  sÏ   € Øˆ1H€CØ€Eä
$ SÓ
.€CØ
‡~~c˜3×ÑØQ‰w˜ˆ~ÐØ
Ü˜s¨Ó5‰ˆØ‰SÔÜ(¨Ó2ˆàc˜A‘gÐˆØ‹8Ø˜‘7˜E>Ð!Ø‹8Ü˜sÐ)9Ó:Ð:Øˆq‰ˆä(¨Ó2ˆØ>‰>˜#˜s×#Ñ#Ø˜‘7˜E>Ð!ñ r-   c                óì  • US-  n[        5       n[        5       n[        X[        5      nU R	                  SU5      (       a  US-   UR
                  4$  [        XU5      u  pnUS S US   p‡UR                  U[        R                  5      (       a  [        XSU 35      e UR                  USS9n	X‰;   a  [        XS	U< 35      eXiU'   [        X[        5      nXUS-    n
U
S:X  a  US-   UR
                  4$ U
S
:w  a  [        XS5      e[        U[
        [        45      (       a  UR                  U[        R                  SS9  US-  n[        X[        5      nGM  ! [         a    [        XS5      S ef = f)Nr	   Ú}Trl   r¶   Fr‰   r¯   zDuplicate inline table key rÔ   zUnclosed inline tablerg   )r?   r@   rB   rC   r²   rN   rº   rz   r‚   rK   r   rŽ   rŒ   r   rY   )rO   rP   r/   Únested_dictrG   rb   r¼   ru   rv   rÀ   r×   s              r   Úparse_inline_tablerÜ   ´  s‡  € Øˆ1H€CÜ“,€KÜ‹G€Eä
SœwÓ
'€CØ
‡~~c˜3×ÑØQ‰w˜×(Ñ(Ð(Ð(Ø
Ü.¨s¸ÓE‰ˆ%Ø" 3 B˜x¨¨R©HØ9‰9Sœ%Ÿ,™,×'Ñ'Ü˜sÐ+MÈcÈUÐ)SÓTÐTð	OØ×1Ñ1°*È5Ð1ÐQˆDð ÓÜ˜sÐ+FÀxÁlÐ)SÓTÐTØˆX‰Ü˜¤7Ó+ˆØc˜A‘gÐˆØ‹8Ø˜‘7˜K×,Ñ,Ð,Ð,Ø‹8Ü˜sÐ)@ÓAÐAÜeœd¤D˜\×*Ñ*ØI‰Icœ5Ÿ<™<°4ˆIÑ8Øˆq‰ˆÜ˜¤7Ó+ˆò+ øô ó 	OÜ˜sÐ)CÓDÈ$ÐNð	Oús   Â E ÅE3FrÏ   c               ó~  • XUS-    nUS-  nU(       aL  US;   aF  US:w  a,  [        X[        5      n X   nUS:w  a  [        XS5      eUS-  n[        X[        5      nUS4$ US:X  a  [        XS	5      $ US
:X  a  [        XS5      $  U[        U   4$ ! [         a    US4s $ f = f! [         a    [        XS5      S ef = f)Nrµ   >   ú\	ú\
ú\ rß   Ú r   zUnescaped '\' in a stringr	   z\ué   z\Ué   )rB   rC   rD   rK   r«   Úparse_hex_charÚBASIC_STR_ESCAPE_REPLACEMENTSrŽ   )rO   rP   rÐ   Ú	escape_idrS   s        r   Úparse_basic_str_escaperç   Ô  sû   € ð ˜# ™'Ð"€IØˆ1H€CÞYÐ"9Ó9ð ˜ÓÜ˜S¤wÓ/ˆCðØ‘xð t‹|Ü" 3Ð-IÓJÐJØ1‰HˆCÜ˜Ô#6Ó7ˆØBˆwˆØEÓÜ˜c¨Ó*Ð*ØEÓÜ˜c¨Ó*Ð*ðMØÔ1°)Ñ<Ð<Ð<øô ó Ø˜Bw’ðûô ó MÜ˜3Ð%AÓBÈÐLðMús   ±B Â
B$ ÂB!Â B!Â$B<c                ó   • [        XSS9$ )NTrÏ   )rç   rÒ   s     r   Ú parse_basic_str_escape_multilineré   ñ  s   € Ü! #°dÑ;Ð;r-   c                óê   • XX-    n[        U5      U:w  d  [        R                  U5      (       d  [        XS5      eX-  n[	        US5      n[        U5      (       d  [        XS5      eU[        U5      4$ )NzInvalid hex valueé   z/Escaped character is not a Unicode scalar value)r    ÚHEXDIGIT_CHARSÚ
issupersetrK   r   Úis_unicode_scalar_valuer   )rO   rP   Úhex_lenÚhex_strÚhex_ints        r   rä   rä   õ  ss   € Ø˜™Ð&€GÜ
ˆ7ƒ|wÓ¤n×&?Ñ&?À×&HÑ&HÜ˜3Ð%8Ó9Ð9ØN€CÜ'˜2Ó€GÜ" 7×+Ñ+Ü˜3Ð%VÓWÐWØ”G“ÐÐr-   c                óB   • US-  nUn[        XS[        SS9nUS-   XU 4$ )Nr	   rÉ   Tr¨   )r¦   ÚILLEGAL_LITERAL_STR_CHARS)rO   rP   rÍ   s      r   rË   rË      s:   € Øˆ1H€CØ€IÜ
Ø#Ô 9Èñ€Cð ‰7C #Ð&Ð&Ð&r-   c               ó8  • US-  nU R                  SU5      (       a  US-  nU(       a  Sn[        U US[        SS9nXU nUS-   nOSn[        XSS	9u  pU R                  X15      (       d  X4$ US-  nU R                  X15      (       d  XU-   4$ US-  nXUS
-  -   4$ )Né   r   r	   rÉ   ú'''Tr¨   r!   rÏ   rµ   )r²   r¦   Ú#ILLEGAL_MULTILINE_LITERAL_STR_CHARSrÑ   )rO   rP   ÚliteralÚdelimÚend_posÚresults         r   Úparse_multiline_strrü   	  sÇ   € Øˆ1H€CØ
‡~~d˜C× Ñ Øˆq‰ˆæØˆÜØØØÜ8Øñ
ˆð ˜Ð!ˆØ˜‰k‰àˆÜ% c¸$Ñ?‰ˆð >‰>˜%×%Ñ%Øˆ{ÐØˆ1H€CØ>‰>˜%×%Ñ%Ø˜U‘NÐ"Ð"Øˆ1H€CØ˜% !™)Ñ$Ð$Ð$r-   c               ó‚  • U(       a  [         n[        nO[        n[        nSnUn  X   nUS:X  a;  U(       d  US-   XPXa -   4$ U R                  SU5      (       a  US-   XPXa -   4$ US-  nMG  US:X  a  XPXa -  nU" X5      u  pXX-  nUnMe  Xs;   a  [        XSU< 35      eUS-  nM€  ! [         a    [        XS5      S ef = f)	Nrá   zUnterminated stringr!   r	   ú"""rõ   r"   zIllegal character )Ú!ILLEGAL_MULTILINE_BASIC_STR_CHARSré   ÚILLEGAL_BASIC_STR_CHARSrç   rD   rK   r²   )	rO   rP   rÐ   r£   Úparse_escapesrû   rÍ   rS   Úparsed_escapes	            r   rÑ   rÑ   (  s  € ÞÜ4ˆÜ8‰ä*ˆÜ.ˆØ€FØ€IØ
ð	JØ‘8ˆDð 3‹;ÞØ˜Q‘w ¨YÐ);Ñ ;Ð;Ð;Ø~‰~˜e S×)Ñ)Ø˜Q‘w ¨YÐ);Ñ ;Ð;Ð;Ø1‰HˆCÙØ4‹<Ø˜)Ð(Ñ(ˆFÙ!.¨sÓ!8ÑˆCØÑ#ˆFØˆIÙØÓÜ˜sÐ+=¸d¹XÐ)FÓGÐGØˆq‰ˆñ) øô ó 	JÜ˜sÐ)>Ó?ÀTÐIð	Jús   §B& Â&B>c                óæ  •  X   nUS:X  a,  U R                  SU5      (       a
  [        XSS9$ [        X5      $ US:X  a,  U R                  SU5      (       a
  [        XSS9$ [	        X5      $ US:X  a  U R                  S	U5      (       a  US
-   S4$ US:X  a  U R                  SU5      (       a  US-   S4$ US:X  a  [        XU5      $ US:X  a  [        XU5      $ [        R                  " X5      nU(       a   [        U5      nUR                  5       U4$ [        R                  " X5      nU(       a  UR                  5       [        U5      4$ [        R                  " X5      nU(       a  UR                  5       [!        X‚5      4$ XUS-    n	U	S;   a  US-   U" U	5      4$ XUS
-    n
U
S;   a  US
-   U" U
5      4$ [        XS5      e! [          a    S n GNÊf = f! [         a  n[        XS5      UeS nAff = f)Nr!   rþ   F)rø   rÉ   rö   TÚtÚtruerâ   ÚfÚfalseé   r;   Ú{zInvalid date or datetimerõ   >   ÚinfÚnan>   ú+infú+nanú-infú-nanzInvalid value)rD   r²   rü   rÌ   rË   rØ   rÜ   r
   Úmatchr   rŸ   rK   Úendr   r   r   r   )rO   rP   r/   rS   Údatetime_matchÚdatetime_objÚeÚlocaltime_matchÚnumber_matchÚfirst_threeÚ
first_fours              r   rÃ   rÃ   H  s  € ðØ™8ˆð ˆsƒ{Ø>‰>˜% ×%Ñ%Ü& s¸Ñ?Ð?Ü'¨Ó1Ð1ð ˆsƒ{Ø>‰>˜% ×%Ñ%Ü& s¸Ñ>Ð>Ü  Ó*Ð*ð ˆsƒ{Ø>‰>˜& #×&Ñ&Ø˜‘7˜D=Ð Øˆsƒ{Ø>‰>˜' 3×'Ñ'Ø˜‘7˜E>Ð!ð ˆsƒ{Ü˜3 [Ó1Ð1ð ˆsƒ{Ü! #¨KÓ8Ð8ô !×&Ò& sÓ0€NÞð	LÜ,¨^Ó<ˆLð ×!Ñ!Ó# \Ð1Ð1Ü"×(Ò(¨Ó2€OÞØ×"Ñ"Ó$Ô&8¸Ó&IÐIÐIô
 —?’? 3Ó,€LÞØ×ÑÓ!¤?°<Ó#MÐMÐMð ˜C !™GÐ$€KØnÓ$ØQ‰w™ KÓ0Ð0Ð0Ø˜3 ™7Ð#€JØÐ5Ó5ØQ‰w™ JÓ/Ð/Ð/ä
s Ó
1Ð1øôy ó Ø‹ðûôL ó 	LÜ˜sÐ)CÓDÈ!ÐKûð	Lús)   ‚G Ã4G ÇGÇGÇ
G0ÇG+Ç+G0c                ó:   • SS jn[        U SU" X5       S35      $ )zVReturn a `TOMLDecodeError` where error message is suffixed with
coordinates in source.c                ó    • U[        U 5      :¼  a  gU R                  SSU5      S-   nUS:X  a  US-   nOXR                  SSU5      -
  nSU SU 3$ )Nzend of documentr   r   r	   zline z	, column )r    ÚcountÚrindex)rO   rP   ÚlineÚcolumns       r   Ú
coord_reprÚ suffixed_err.<locals>.coord_repr  s_   € Ø”#c“(‹?Ø$Øy‰y˜˜q #Ó&¨Ñ*ˆØ1‹9Ø˜1‘W‰FàŸ:™: d¨A¨sÓ3Ñ3ˆFØtf˜I f XÐ.Ð.r-   z (at Ú))rO   ÚstrrP   r   r}   r"  )r$   )rO   rP   Úmsgr  s       r   rK   rK   Œ  s'   € ô/ô ˜c˜U %©
°3Ó(<Ð'=¸QÐ?Ó@Ð@r-   c                ód   • SU s=:*  =(       a    S:*  Os  =(       d    SU s=:*  =(       a    S:*  $ s  $ )Nr   iÿ×  i à  iÿÿ r&   )Ú	codepoints    r   rî   rî     s-   € Ø×#Ó#˜eÔ#×G¨°)×)FÓ)F¸wÑ)FÐGÑ)FÐGr-   c                ó6   ^ • T [         L a  [         $ SU 4S jjnU$ )a  A decorator to make `parse_float` safe.

`parse_float` must not return dicts or lists, because these types
would be mixed with parsed TOML tables and arrays, thus confusing
the parser. The returned decorated callable raises `ValueError`
instead of returning illegal types.
c                ód   >• T" U 5      n[        U[        [        45      (       a  [        S5      eU$ )Nz*parse_float must not return dicts or lists)rŒ   rN   r   rŸ   )Ú	float_strÚfloat_valuer/   s     €r   Úsafe_parse_floatÚ/make_safe_parse_float.<locals>.safe_parse_float­  s0   ø€ Ù! )Ó,ˆÜk¤D¬$ <×0Ñ0ÜÐIÓJÐJØÐr-   )r(  r"  r}   r   )Úfloat)r/   r*  s   ` r   rA   rA   ¡  s   ø€ ð ”eÒÜˆ÷ð Ðr-   )r6   r   r/   r   r}   r—   )r8   r"  r/   r   r}   r—   )rO   r"  rP   r   rœ   zIterable[str]r}   r   )rO   r"  rP   r   r¢   r"  r£   zfrozenset[str]r¤   r   r}   r   )rO   r"  rP   r   r}   r   )rO   r"  rP   r   rQ   r>   r}   útuple[Pos, Key])rO   r"  rP   r   rQ   r>   rR   r   r/   r   r}   r   )rO   r"  rP   r   r/   r   r}   ztuple[Pos, Key, Any])rO   r"  rP   r   r}   r-  )rO   r"  rP   r   r}   útuple[Pos, str])rO   r"  rP   r   r/   r   r}   ztuple[Pos, list[Any]])rO   r"  rP   r   r/   r   r}   ztuple[Pos, dict[str, Any]])rO   r"  rP   r   rÐ   r   r}   r.  )rO   r"  rP   r   rï   r   r}   r.  )rO   r"  rP   r   rø   r   r}   r.  )rO   r"  rP   r   r/   r   r}   ztuple[Pos, Any])rO   r"  rP   r   r#  r"  r}   r$   )r%  r   r}   r   )r/   r   r}   r   )GÚ
__future__r   Úcollections.abcr   ÚstringÚtypesr   Útypingr   r   r   Ú_rer
   r   r   r   r   r   Ú_typesr   r   r   Ú	frozensetr»   r   Ú
ASCII_CTRLr   rÿ   ró   r÷   r©   rC   r«   Úascii_lettersÚdigitsrÊ   rE   Ú	hexdigitsrì   rå   rŸ   r$   r,  r9   r5   r@   r?   r>   rB   r¦   rL   r­   rJ   rI   rF   rº   r±   rÆ   rÌ   rØ   rÜ   rç   ré   rä   rË   rü   rÑ   rÃ   rK   rî   rA   r&   r-   r   Ú<module>r;     s  ðõ
 #å $Û Ý "ß ,Ñ ,÷÷ ÷ )Ñ (áÑ1¡u¨R¤yÓ1Ó1±I¹cÀ#»hÓ4GÑG€
ð %¡y°£Ñ6Ð Ø$.±¸6Ó1BÑ$BÐ !à3Ð Ø&GÐ #à/Ð á
EÓ
€Ø¡	¨$£Ñ/Ð Ù˜6×/Ñ/°&·-±-Ñ?À$ÑFÓG€Ø"¡Y¨uÓ%5Ñ5Ð Ù˜6×+Ñ+Ó,€á 0àØØØØØØñó
!Ð ô;jô ;ð 8=÷ 	-ð 38÷ ?÷D7ñ 7÷t"ñ "ôDˆZô ô
ðØ	ðà	ðð ðð
 ðð ðð 	ôô,	ôôô$ð*Ø	ðØðØ#ðØ-0ðØ?IðàôðDØ	ðØðØ%/ðàôô ,ô$Mô 6ô
"ô0,ðB .3ñMØ	ðMØðMØ&*ðMàõMô:<ôô'ô%ô>ð@A2Ø	ðA2ØðA2Ø%/ðA2àôA2ôHAô"Hõr-                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ó
    F\hŽ  ã                  ó2  • S SK Jr  S SKJrJrJrJrJrJr  S SKJ	r	  S SK
r
S SKJr  SSKJr  Sr\
R                   " S	\
R"                  S
9r\
R                   " \5      r\
R                   " S\ S3\
R"                  S
9rSS jr\	" SS9SS j5       rSS jrSS jrg)é    )Úannotations)ÚdateÚdatetimeÚtimeÚ	timedeltaÚtimezoneÚtzinfo)Ú	lru_cacheN)ÚAnyé   )Ú
ParseFloatzE([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(?:\.([0-9]{1,6})[0-9]*)?a`  
0
(?:
    x[0-9A-Fa-f](?:_?[0-9A-Fa-f])*   # hex
    |
    b[01](?:_?[01])*                 # bin
    |
    o[0-7](?:_?[0-7])*               # oct
)
|
[+-]?(?:0|[1-9](?:_?[0-9])*)         # dec, integer part
(?P<floatpart>
    (?:\.[0-9](?:_?[0-9])*)?         # optional fractional part
    (?:[eE][+-]?[0-9](?:_?[0-9])*)?  # optional exponent part
)
)Úflagsz`
([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])  # date, e.g. 1988-10-27
(?:
    [Tt ]
    zR
    (?:([Zz])|([+-])([01][0-9]|2[0-3]):([0-5][0-9]))?  # optional time offset
)?
c                óš  • U R                  5       u  nnnnnnnnn	n
n[        U5      [        U5      [        U5      pínUc  [        XÍU5      $ [        U5      [        U5      [        U5      nnnU(       a  [        UR                  SS5      5      OSnU	(       a  [	        X«U	5      nOU(       a  [
        R                  nOSn[        XÍXïUUUUS9$ )zšConvert a `RE_DATETIME` match to `datetime.datetime` or `datetime.date`.

Raises ValueError if the match does not correspond to a valid date
or datetime.
Né   Ú0r   )r	   )ÚgroupsÚintr   ÚljustÚ	cached_tzr   Úutcr   )ÚmatchÚyear_strÚ	month_strÚday_strÚhour_strÚ
minute_strÚsec_strÚ
micros_strÚ	zulu_timeÚoffset_sign_strÚoffset_hour_strÚoffset_minute_strÚyearÚmonthÚdayÚhourÚminuteÚsecÚmicrosÚtzs                       Ú"/usr/lib/python3.13/tomllib/_re.pyÚmatch_to_datetimer,   4   sË   € ð$ 	‰‹ñØØØØØØØØØØØä˜8“}¤c¨)£n´c¸'³l€DØÑÜD Ó%Ð%Ü˜H›¤s¨:£¼¸G»#ˆ&€DÞ.8ŒS×!Ñ! ! SÓ)Ô*¸a€FÞÜ%Ø°ó
‰ö 
Ü\‰\‰àˆÜD ¨F°C¸ÈÑKÐKó    )Úmaxsizec           	     ól   • US:X  a  SOSn[        [        U[        U 5      -  U[        U5      -  S95      $ )NÚ+r   éÿÿÿÿ)ÚhoursÚminutes)r   r   r   )r   r   Úsign_strÚsigns       r+   r   r   W   s<   € à˜C“‰1 R€DÜÜØœ˜X›Ñ&Øœ3˜z›?Ñ*ñ	
óð r-   c                óÂ   • U R                  5       u  pp4U(       a  [        UR                  SS5      5      OSn[        [        U5      [        U5      [        U5      U5      $ )Nr   r   r   )r   r   r   r   )r   r   r   r   r   r)   s         r+   Úmatch_to_localtimer7   b   sJ   € Ø05·±³Ñ-€H˜'Þ.8ŒS×!Ñ! ! SÓ)Ô*¸a€FÜ”H“œs :›´°G³¸fÓEÐEr-   c                óŽ   • U R                  S5      (       a  U" U R                  5       5      $ [        U R                  5       S5      $ )NÚ	floatpartr   )Úgroupr   )r   Úparse_floats     r+   Úmatch_to_numberr<   h   s5   € Ø‡{{;×ÑÙ˜5Ÿ;™;›=Ó)Ð)Üˆu{‰{‹}˜aÓ Ð r-   )r   úre.Match[str]Úreturnzdatetime | date)r   Ústrr   r?   r4   r?   r>   r   )r   r=   r>   r   )r   r=   r;   r   r>   r   )Ú
__future__r   r   r   r   r   r   r	   Ú	functoolsr
   ÚreÚtypingr   Ú_typesr   Ú_TIME_RE_STRÚcompileÚVERBOSEÚ	RE_NUMBERÚRE_LOCALTIMEÚRE_DATETIMEr,   r   r7   r<   © r-   r+   Ú<module>rL      s¨   ðõ
 #ç F× FÝ Û 	Ý å ð
 X€àJŠJðð  *‰*ñ#€	ð& zŠz˜,Ó'€ØjŠjð
ð €Nð ð	ð *‰*ñ
€ô LñF 4Ñóó ðôFõ!r-                                                                                                                                                                                                                                                          ó
    F\hþ   ã                   ó:   • S SK JrJrJr  \\/\4   r\\S4   r\rg)é    )ÚAnyÚCallableÚTuple.N)	Útypingr   r   r   ÚstrÚ
ParseFloatÚKeyÚintÚPos© ó    Ú%/usr/lib/python3.13/tomllib/_types.pyÚ<module>r      s1   ð÷
 (Ñ 'ð se˜SjÑ!€
ØˆCˆHo€Ø	r                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         # SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2021 Taneli Hukkinen
# Licensed to PSF under a Contributor Agreement.

from __future__ import annotations

from collections.abc import Iterable
import string
from types import MappingProxyType
from typing import Any, BinaryIO, NamedTuple

from ._re import (
    RE_DATETIME,
    RE_LOCALTIME,
    RE_NUMBER,
    match_to_datetime,
    match_to_localtime,
    match_to_number,
)
from ._types import Key, ParseFloat, Pos

ASCII_CTRL = frozenset(chr(i) for i in range(32)) | frozenset(chr(127))

# Neither of these sets include quotation mark or backslash. They are
# currently handled as separate cases in the parser functions.
ILLEGAL_BASIC_STR_CHARS = ASCII_CTRL - frozenset("\t")
ILLEGAL_MULTILINE_BASIC_STR_CHARS = ASCII_CTRL - frozenset("\t\n")

ILLEGAL_LITERAL_STR_CHARS = ILLEGAL_BASIC_STR_CHARS
ILLEGAL_MULTILINE_LITERAL_STR_CHARS = ILLEGAL_MULTILINE_BASIC_STR_CHARS

ILLEGAL_COMMENT_CHARS = ILLEGAL_BASIC_STR_CHARS

TOML_WS = frozenset(" \t")
TOML_WS_AND_NEWLINE = TOML_WS | frozenset("\n")
BARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + "-_")
KEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset("\"'")
HEXDIGIT_CHARS = frozenset(string.hexdigits)

BASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(
    {
        "\\b": "\u0008",  # backspace
        "\\t": "\u0009",  # tab
        "\\n": "\u000A",  # linefeed
        "\\f": "\u000C",  # form feed
        "\\r": "\u000D",  # carriage return
        '\\"': "\u0022",  # quote
        "\\\\": "\u005C",  # backslash
    }
)


class TOMLDecodeError(ValueError):
    """An error raised if a document is not valid TOML."""


def load(fp: BinaryIO, /, *, parse_float: ParseFloat = float) -> dict[str, Any]:
    """Parse TOML from a binary file object."""
    b = fp.read()
    try:
        s = b.decode()
    except AttributeError:
        raise TypeError(
            "File must be opened in binary mode, e.g. use `open('foo.toml', 'rb')`"
        ) from None
    return loads(s, parse_float=parse_float)


def loads(s: str, /, *, parse_float: ParseFloat = float) -> dict[str, Any]:  # noqa: C901
    """Parse TOML from a string."""

    # The spec allows converting "\r\n" to "\n", even in string
    # literals. Let's do so to simplify parsing.
    src = s.replace("\r\n", "\n")
    pos = 0
    out = Output(NestedDict(), Flags())
    header: Key = ()
    parse_float = make_safe_parse_float(parse_float)

    # Parse one statement at a time
    # (typically means one line in TOML source)
    while True:
        # 1. Skip line leading whitespace
        pos = skip_chars(src, pos, TOML_WS)

        # 2. Parse rules. Expect one of the following:
        #    - end of file
        #    - end of line
        #    - comment
        #    - key/value pair
        #    - append dict to list (and move to its namespace)
        #    - create dict (and move to its namespace)
        # Skip trailing whitespace when applicable.
        try:
            char = src[pos]
        except IndexError:
            break
        if char == "\n":
            pos += 1
            continue
        if char in KEY_INITIAL_CHARS:
            pos = key_value_rule(src, pos, out, header, parse_float)
            pos = skip_chars(src, pos, TOML_WS)
        elif char == "[":
            try:
                second_char: str | None = src[pos + 1]
            except IndexError:
                second_char = None
            out.flags.finalize_pending()
            if second_char == "[":
                pos, header = create_list_rule(src, pos, out)
            else:
                pos, header = create_dict_rule(src, pos, out)
            pos = skip_chars(src, pos, TOML_WS)
        elif char != "#":
            raise suffixed_err(src, pos, "Invalid statement")

        # 3. Skip comment
        pos = skip_comment(src, pos)

        # 4. Expect end of line or end of file
        try:
            char = src[pos]
        except IndexError:
            break
        if char != "\n":
            raise suffixed_err(
                src, pos, "Expected newline or end of document after a statement"
            )
        pos += 1

    return out.data.dict


class Flags:
    """Flags that map to parsed keys/namespaces."""

    # Marks an immutable namespace (inline array or inline table).
    FROZEN = 0
    # Marks a nest that has been explicitly created and can no longer
    # be opened using the "[table]" syntax.
    EXPLICIT_NEST = 1

    def __init__(self) -> None:
        self._flags: dict[str, dict[Any, Any]] = {}
        self._pending_flags: set[tuple[Key, int]] = set()

    def add_pending(self, key: Key, flag: int) -> None:
        self._pending_flags.add((key, flag))

    def finalize_pending(self) -> None:
        for key, flag in self._pending_flags:
            self.set(key, flag, recursive=False)
        self._pending_flags.clear()

    def unset_all(self, key: Key) -> None:
        cont = self._flags
        for k in key[:-1]:
            if k not in cont:
                return
            cont = cont[k]["nested"]
        cont.pop(key[-1], None)

    def set(self, key: Key, flag: int, *, recursive: bool) -> None:  # noqa: A003
        cont = self._flags
        key_parent, key_stem = key[:-1], key[-1]
        for k in key_parent:
            if k not in cont:
                cont[k] = {"flags": set(), "recursive_flags": set(), "nested": {}}
            cont = cont[k]["nested"]
        if key_stem not in cont:
            cont[key_stem] = {"flags": set(), "recursive_flags": set(), "nested": {}}
        cont[key_stem]["recursive_flags" if recursive else "flags"].add(flag)

    def is_(self, key: Key, flag: int) -> bool:
        if not key:
            return False  # document root has no flags
        cont = self._flags
        for k in key[:-1]:
            if k not in cont:
                return False
            inner_cont = cont[k]
            if flag in inner_cont["recursive_flags"]:
                return True
            cont = inner_cont["nested"]
        key_stem = key[-1]
        if key_stem in cont:
            cont = cont[key_stem]
            return flag in cont["flags"] or flag in cont["recursive_flags"]
        return False


class NestedDict:
    def __init__(self) -> None:
        # The parsed content of the TOML document
        self.dict: dict[str, Any] = {}

    def get_or_create_nest(
        self,
        key: Key,
        *,
        access_lists: bool = True,
    ) -> dict[str, Any]:
        cont: Any = self.dict
        for k in key:
            if k not in cont:
                cont[k] = {}
            cont = cont[k]
            if access_lists and isinstance(cont, list):
                cont = cont[-1]
            if not isinstance(cont, dict):
                raise KeyError("There is no nest behind this key")
        return cont  # type: ignore[no-any-return]

    def append_nest_to_list(self, key: Key) -> None:
        cont = self.get_or_create_nest(key[:-1])
        last_key = key[-1]
        if last_key in cont:
            list_ = cont[last_key]
            if not isinstance(list_, list):
                raise KeyError("An object other than list found behind this key")
            list_.append({})
        else:
            cont[last_key] = [{}]


class Output(NamedTuple):
    data: NestedDict
    flags: Flags


def skip_chars(src: str, pos: Pos, chars: Iterable[str]) -> Pos:
    try:
        while src[pos] in chars:
            pos += 1
    except IndexError:
        pass
    return pos


def skip_until(
    src: str,
    pos: Pos,
    expect: str,
    *,
    error_on: frozenset[str],
    error_on_eof: bool,
) -> Pos:
    try:
        new_pos = src.index(expect, pos)
    except ValueError:
        new_pos = len(src)
        if error_on_eof:
            raise suffixed_err(src, new_pos, f"Expected {expect!r}") from None

    if not error_on.isdisjoint(src[pos:new_pos]):
        while src[pos] not in error_on:
            pos += 1
        raise suffixed_err(src, pos, f"Found invalid character {src[pos]!r}")
    return new_pos


def skip_comment(src: str, pos: Pos) -> Pos:
    try:
        char: str | None = src[pos]
    except IndexError:
        char = None
    if char == "#":
        return skip_until(
            src, pos + 1, "\n", error_on=ILLEGAL_COMMENT_CHARS, error_on_eof=False
        )
    return pos


def skip_comments_and_array_ws(src: str, pos: Pos) -> Pos:
    while True:
        pos_before_skip = pos
        pos = skip_chars(src, pos, TOML_WS_AND_NEWLINE)
        pos = skip_comment(src, pos)
        if pos == pos_before_skip:
            return pos


def create_dict_rule(src: str, pos: Pos, out: Output) -> tuple[Pos, Key]:
    pos += 1  # Skip "["
    pos = skip_chars(src, pos, TOML_WS)
    pos, key = parse_key(src, pos)

    if out.flags.is_(key, Flags.EXPLICIT_NEST) or out.flags.is_(key, Flags.FROZEN):
        raise suffixed_err(src, pos, f"Cannot declare {key} twice")
    out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)
    try:
        out.data.get_or_create_nest(key)
    except KeyError:
        raise suffixed_err(src, pos, "Cannot overwrite a value") from None

    if not src.startswith("]", pos):
        raise suffixed_err(src, pos, "Expected ']' at the end of a table declaration")
    return pos + 1, key


def create_list_rule(src: str, pos: Pos, out: Output) -> tuple[Pos, Key]:
    pos += 2  # Skip "[["
    pos = skip_chars(src, pos, TOML_WS)
    pos, key = parse_key(src, pos)

    if out.flags.is_(key, Flags.FROZEN):
        raise suffixed_err(src, pos, f"Cannot mutate immutable namespace {key}")
    # Free the namespace now that it points to another empty list item...
    out.flags.unset_all(key)
    # ...but this key precisely is still prohibited from table declaration
    out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)
    try:
        out.data.append_nest_to_list(key)
    except KeyError:
        raise suffixed_err(src, pos, "Cannot overwrite a value") from None

    if not src.startswith("]]", pos):
        raise suffixed_err(src, pos, "Expected ']]' at the end of an array declaration")
    return pos + 2, key


def key_value_rule(
    src: str, pos: Pos, out: Output, header: Key, parse_float: ParseFloat
) -> Pos:
    pos, key, value = parse_key_value_pair(src, pos, parse_float)
    key_parent, key_stem = key[:-1], key[-1]
    abs_key_parent = header + key_parent

    relative_path_cont_keys = (header + key[:i] for i in range(1, len(key)))
    for cont_key in relative_path_cont_keys:
        # Check that dotted key syntax does not redefine an existing table
        if out.flags.is_(cont_key, Flags.EXPLICIT_NEST):
            raise suffixed_err(src, pos, f"Cannot redefine namespace {cont_key}")
        # Containers in the relative path can't be opened with the table syntax or
        # dotted key/value syntax in following table sections.
        out.flags.add_pending(cont_key, Flags.EXPLICIT_NEST)

    if out.flags.is_(abs_key_parent, Flags.FROZEN):
        raise suffixed_err(
            src, pos, f"Cannot mutate immutable namespace {abs_key_parent}"
        )

    try:
        nest = out.data.get_or_create_nest(abs_key_parent)
    except KeyError:
        raise suffixed_err(src, pos, "Cannot overwrite a value") from None
    if key_stem in nest:
        raise suffixed_err(src, pos, "Cannot overwrite a value")
    # Mark inline table and array namespaces recursively immutable
    if isinstance(value, (dict, list)):
        out.flags.set(header + key, Flags.FROZEN, recursive=True)
    nest[key_stem] = value
    return pos


def parse_key_value_pair(
    src: str, pos: Pos, parse_float: ParseFloat
) -> tuple[Pos, Key, Any]:
    pos, key = parse_key(src, pos)
    try:
        char: str | None = src[pos]
    except IndexError:
        char = None
    if char != "=":
        raise suffixed_err(src, pos, "Expected '=' after a key in a key/value pair")
    pos += 1
    pos = skip_chars(src, pos, TOML_WS)
    pos, value = parse_value(src, pos, parse_float)
    return pos, key, value


def parse_key(src: str, pos: Pos) -> tuple[Pos, Key]:
    pos, key_part = parse_key_part(src, pos)
    key: Key = (key_part,)
    pos = skip_chars(src, pos, TOML_WS)
    while True:
        try:
            char: str | None = src[pos]
        except In