ction and class docstrings are tested even if the name is private;
    strings are tested directly, as if they were docstrings.

    Return (#failures, #tests).

    See help(doctest) for an overview.

    Optional keyword arg "name" gives the name of the module; by default
    use m.__name__.

    Optional keyword arg "globs" gives a dict to be used as the globals
    when executing examples; by default, use m.__dict__.  A copy of this
    dict is actually used for each docstring, so that each docstring's
    examples start with a clean slate.

    Optional keyword arg "extraglobs" gives a dictionary that should be
    merged into the globals that are used to execute examples.  By
    default, no extra globals are used.  This is new in 2.4.

    Optional keyword arg "verbose" prints lots of stuff if true, prints
    only failures if false; by default, it's true iff "-v" is in sys.argv.

    Optional keyword arg "report" prints a summary at the end when true,
    else prints nothing at the end.  In verbose mode, the summary is
    detailed, else very brief (in fact, empty if all tests passed).

    Optional keyword arg "optionflags" or's together module constants,
    and defaults to 0.  This is new in 2.3.  Possible values (see the
    docs for details):

        DONT_ACCEPT_TRUE_FOR_1
        DONT_ACCEPT_BLANKLINE
        NORMALIZE_WHITESPACE
        ELLIPSIS
        SKIP
        IGNORE_EXCEPTION_DETAIL
        REPORT_UDIFF
        REPORT_CDIFF
        REPORT_NDIFF
        REPORT_ONLY_FIRST_FAILURE

    Optional keyword arg "raise_on_error" raises an exception on the
    first unexpected exception or failure. This allows failures to be
    post-mortem debugged.

    Advanced tomfoolery:  testmod runs methods of a local instance of
    class doctest.Tester, then merges the results into (or creates)
    global Tester instance doctest.master.  Methods of doctest.master
    can be called directly too, if you want to do something unusual.
    Passing report=0 to testmod is especially useful then, to delay
    displaying a summary.  Invoke doctest.master.summarize(verbose)
    when you're done fiddling.
    """
    global master

    # If no module was given, then use __main__.
    if m is None:
        # DWA - m will still be None if this wasn't invoked from the command
        # line, in which case the following TypeError is about as good an error
        # as we should expect
        m = sys.modules.get('__main__')

    # Check that we were actually given a module.
    if not inspect.ismodule(m):
        raise TypeError("testmod: module required; %r" % (m,))

    # If no name was given, then use the module's name.
    if name is None:
        name = m.__name__

    # Find, parse, and run all tests in the given module.
    finder = DocTestFinder(exclude_empty=exclude_empty)

    if raise_on_error:
        runner = DebugRunner(verbose=verbose, optionflags=optionflags)
    else:
        runner = DocTestRunner(verbose=verbose, optionflags=optionflags)

    for test in finder.find(m, name, globs=globs, extraglobs=extraglobs):
        runner.run(test)

    if report:
        runner.summarize()

    if master is None:
        master = runner
    else:
        master.merge(runner)

    return TestResults(runner.failures, runner.tries, skipped=runner.skips)


def testfile(filename, module_relative=True, name=None, package=None,
             globs=None, verbose=None, report=True, optionflags=0,
             extraglobs=None, raise_on_error=False, parser=DocTestParser(),
             encoding=None):
    """
    Test examples in the given file.  Return (#failures, #tests).

    Optional keyword arg "module_relative" specifies how filenames
    should be interpreted:

      - If "module_relative" is True (the default), then "filename"
         specifies a module-relative path.  By default, this path is
         relative to the calling module's directory; but if the
         "package" argument is specified, then it is relative to that
         package.  To ensure os-independence, "filename" should use
         "/" characters to separate path segments, and should not
         be an absolute path (i.e., it may not begin with "/").

      - If "module_relative" is False, then "filename" specifies an
        os-specific path.  The path may be absolute or relative (to
        the current working directory).

    Optional keyword arg "name" gives the name of the test; by default
    use the file's basename.

    Optional keyword argument "package" is a Python package or the
    name of a Python package whose directory should be used as the
    base directory for a module relative filename.  If no package is
    specified, then the calling module's directory is used as the base
    directory for module relative filenames.  It is an error to
    specify "package" if "module_relative" is False.

    Optional keyword arg "globs" gives a dict to be used as the globals
    when executing examples; by default, use {}.  A copy of this dict
    is actually used for each docstring, so that each docstring's
    examples start with a clean slate.

    Optional keyword arg "extraglobs" gives a dictionary that should be
    merged into the globals that are used to execute examples.  By
    default, no extra globals are used.

    Optional keyword arg "verbose" prints lots of stuff if true, prints
    only failures if false; by default, it's true iff "-v" is in sys.argv.

    Optional keyword arg "report" prints a summary at the end when true,
    else prints nothing at the end.  In verbose mode, the summary is
    detailed, else very brief (in fact, empty if all tests passed).

    Optional keyword arg "optionflags" or's together module constants,
    and defaults to 0.  Possible values (see the docs for details):

        DONT_ACCEPT_TRUE_FOR_1
        DONT_ACCEPT_BLANKLINE
        NORMALIZE_WHITESPACE
        ELLIPSIS
        SKIP
        IGNORE_EXCEPTION_DETAIL
        REPORT_UDIFF
        REPORT_CDIFF
        REPORT_NDIFF
        REPORT_ONLY_FIRST_FAILURE

    Optional keyword arg "raise_on_error" raises an exception on the
    first unexpected exception or failure. This allows failures to be
    post-mortem debugged.

    Optional keyword arg "parser" specifies a DocTestParser (or
    subclass) that should be used to extract tests from the files.

    Optional keyword arg "encoding" specifies an encoding that should
    be used to convert the file to unicode.

    Advanced tomfoolery:  testmod runs methods of a local instance of
    class doctest.Tester, then merges the results into (or creates)
    global Tester instance doctest.master.  Methods of doctest.master
    can be called directly too, if you want to do something unusual.
    Passing report=0 to testmod is especially useful then, to delay
    displaying a summary.  Invoke doctest.master.summarize(verbose)
    when you're done fiddling.
    """
    global master

    if package and not module_relative:
        raise ValueError("Package may only be specified for module-"
                         "relative paths.")

    # Relativize the path
    text, filename = _load_testfile(filename, package, module_relative,
                                    encoding or "utf-8")

    # If no name was given, then use the file's name.
    if name is None:
        name = os.path.basename(filename)

    # Assemble the globals.
    if globs is None:
        globs = {}
    else:
        globs = globs.copy()
    if extraglobs is not None:
        globs.update(extraglobs)
    if '__name__' not in globs:
        globs['__name__'] = '__main__'

    if raise_on_error:
        runner = DebugRunner(verbose=verbose, optionflags=optionflags)
    else:
        runner = DocTestRunner(verbose=verbose, optionflags=optionflags)

    # Read the file, convert it to a test, and run it.
    test = parser.get_doctest(text, globs, name, filename, 0)
    runner.run(test)

    if report:
        runner.summarize()

    if master is None:
        master = runner
    else:
        master.merge(runner)

    return TestResults(runner.failures, runner.tries, skipped=runner.skips)


def run_docstring_examples(f, globs, verbose=False, name="NoName",
                           compileflags=None, optionflags=0):
    """
    Test examples in the given object's docstring (`f`), using `globs`
    as globals.  Optional argument `name` is used in failure messages.
    If the optional argument `verbose` is true, then generate output
    even if there are no failures.

    `compileflags` gives the set of flags that should be used by the
    Python compiler when running the examples.  If not specified, then
    it will default to the set of future-import flags that apply to
    `globs`.

    Optional keyword arg `optionflags` specifies options for the
    testing and output.  See the documentation for `testmod` for more
    information.
    """
    # Find, parse, and run all tests in the given module.
    finder = DocTestFinder(verbose=verbose, recurse=False)
    runner = DocTestRunner(verbose=verbose, optionflags=optionflags)
    for test in finder.find(f, name, globs=globs):
        runner.run(test, compileflags=compileflags)

######################################################################
## 7. Unittest Support
######################################################################

_unittest_reportflags = 0

def set_unittest_reportflags(flags):
    """Sets the unittest option flags.

    The old flag is returned so that a runner could restore the old
    value if it wished to:

      >>> import doctest
      >>> old = doctest._unittest_reportflags
      >>> doctest.set_unittest_reportflags(REPORT_NDIFF |
      ...                          REPORT_ONLY_FIRST_FAILURE) == old
      True

      >>> doctest._unittest_reportflags == (REPORT_NDIFF |
      ...                                   REPORT_ONLY_FIRST_FAILURE)
      True

    Only reporting flags can be set:

      >>> doctest.set_unittest_reportflags(ELLIPSIS)
      Traceback (most recent call last):
      ...
      ValueError: ('Only reporting flags allowed', 8)

      >>> doctest.set_unittest_reportflags(old) == (REPORT_NDIFF |
      ...                                   REPORT_ONLY_FIRST_FAILURE)
      True
    """
    global _unittest_reportflags

    if (flags & REPORTING_FLAGS) != flags:
        raise ValueError("Only reporting flags allowed", flags)
    old = _unittest_reportflags
    _unittest_reportflags = flags
    return old


class DocTestCase(unittest.TestCase):

    def __init__(self, test, optionflags=0, setUp=None, tearDown=None,
                 checker=None):

        unittest.TestCase.__init__(self)
        self._dt_optionflags = optionflags
        self._dt_checker = checker
        self._dt_test = test
        self._dt_setUp = setUp
        self._dt_tearDown = tearDown

    def setUp(self):
        test = self._dt_test
        self._dt_globs = test.globs.copy()

        if self._dt_setUp is not None:
            self._dt_setUp(test)

    def tearDown(self):
        test = self._dt_test

        if self._dt_tearDown is not None:
            self._dt_tearDown(test)

        # restore the original globs
        test.globs.clear()
        test.globs.update(self._dt_globs)

    def runTest(self):
        test = self._dt_test
        old = sys.stdout
        new = StringIO()
        optionflags = self._dt_optionflags

        if not (optionflags & REPORTING_FLAGS):
            # The option flags don't include any reporting flags,
            # so add the default reporting flags
            optionflags |= _unittest_reportflags

        runner = DocTestRunner(optionflags=optionflags,
                               checker=self._dt_checker, verbose=False)

        try:
            runner.DIVIDER = "-"*70
            results = runner.run(test, out=new.write, clear_globs=False)
            if results.skipped == results.attempted:
                raise unittest.SkipTest("all examples were skipped")
        finally:
            sys.stdout = old

        if results.failed:
            raise self.failureException(self.format_failure(new.getvalue()))

    def format_failure(self, err):
        test = self._dt_test
        if test.lineno is None:
            lineno = 'unknown line number'
        else:
            lineno = '%s' % test.lineno
        lname = '.'.join(test.name.split('.')[-1:])
        return ('Failed doctest test for %s\n'
                '  File "%s", line %s, in %s\n\n%s'
                % (test.name, test.filename, lineno, lname, err)
                )

    def debug(self):
        r"""Run the test case without results and without catching exceptions

           The unit test framework includes a debug method on test cases
           and test suites to support post-mortem debugging.  The test code
           is run in such a way that errors are not caught.  This way a
           caller can catch the errors and initiate post-mortem debugging.

           The DocTestCase provides a debug method that raises
           UnexpectedException errors if there is an unexpected
           exception:

             >>> test = DocTestParser().get_doctest('>>> raise KeyError\n42',
             ...                {}, 'foo', 'foo.py', 0)
             >>> case = DocTestCase(test)
             >>> try:
             ...     case.debug()
             ... except UnexpectedException as f:
             ...     failure = f

           The UnexpectedException contains the test, the example, and
           the original exception:

             >>> failure.test is test
             True

             >>> failure.example.want
             '42\n'

             >>> exc_info = failure.exc_info
             >>> raise exc_info[1] # Already has the traceback
             Traceback (most recent call last):
             ...
             KeyError

           If the output doesn't match, then a DocTestFailure is raised:

             >>> test = DocTestParser().get_doctest('''
             ...      >>> x = 1
             ...      >>> x
             ...      2
             ...      ''', {}, 'foo', 'foo.py', 0)
             >>> case = DocTestCase(test)

             >>> try:
             ...    case.debug()
             ... except DocTestFailure as f:
             ...    failure = f

           DocTestFailure objects provide access to the test:

             >>> failure.test is test
             True

           As well as to the example:

             >>> failure.example.want
             '2\n'

           and the actual output:

             >>> failure.got
             '1\n'

           """

        self.setUp()
        runner = DebugRunner(optionflags=self._dt_optionflags,
                             checker=self._dt_checker, verbose=False)
        runner.run(self._dt_test, clear_globs=False)
        self.tearDown()

    def id(self):
        return self._dt_test.name

    def __eq__(self, other):
        if type(self) is not type(other):
            return NotImplemented

        return self._dt_test == other._dt_test and \
               self._dt_optionflags == other._dt_optionflags and \
               self._dt_setUp == other._dt_setUp and \
               self._dt_tearDown == other._dt_tearDown and \
               self._dt_checker == other._dt_checker

    def __hash__(self):
        return hash((self._dt_optionflags, self._dt_setUp, self._dt_tearDown,
                     self._dt_checker))

    def __repr__(self):
        name = self._dt_test.name.split('.')
        return "%s (%s)" % (name[-1], '.'.join(name[:-1]))

    __str__ = object.__str__

    def shortDescription(self):
        return "Doctest: " + self._dt_test.name

class SkipDocTestCase(DocTestCase):
    def __init__(self, module):
        self.module = module
        DocTestCase.__init__(self, None)

    def setUp(self):
        self.skipTest("DocTestSuite will not work with -O2 and above")

    def test_skip(self):
        pass

    def shortDescription(self):
        return "Skipping tests from %s" % self.module.__name__

    __str__ = shortDescription


class _DocTestSuite(unittest.TestSuite):

    def _removeTestAtIndex(self, index):
        pass


def DocTestSuite(module=None, globs=None, extraglobs=None, test_finder=None,
                 **options):
    """
    Convert doctest tests for a module to a unittest test suite.

    This converts each documentation string in a module that
    contains doctest tests to a unittest test case.  If any of the
    tests in a doc string fail, then the test case fails.  An exception
    is raised showing the name of the file containing the test and a
    (sometimes approximate) line number.

    The `module` argument provides the module to be tested.  The argument
    can be either a module or a module name.

    If no argument is given, the calling module is used.

    A number of options may be provided as keyword arguments:

    setUp
      A set-up function.  This is called before running the
      tests in each file. The setUp function will be passed a DocTest
      object.  The setUp function can access the test globals as the
      globs attribute of the test passed.

    tearDown
      A tear-down function.  This is called after running the
      tests in each file.  The tearDown function will be passed a DocTest
      object.  The tearDown function can access the test globals as the
      globs attribute of the test passed.

    globs
      A dictionary containing initial global variables for the tests.

    optionflags
       A set of doctest option flags expressed as an integer.
    """

    if test_finder is None:
        test_finder = DocTestFinder()

    module = _normalize_module(module)
    tests = test_finder.find(module, globs=globs, extraglobs=extraglobs)

    if not tests and sys.flags.optimize >=2:
        # Skip doctests when running with -O2
        suite = _DocTestSuite()
        suite.addTest(SkipDocTestCase(module))
        return suite

    tests.sort()
    suite = _DocTestSuite()

    for test in tests:
        if len(test.examples) == 0:
            continue
        if not test.filename:
            filename = module.__file__
            if filename[-4:] == ".pyc":
                filename = filename[:-1]
            test.filename = filename
        suite.addTest(DocTestCase(test, **options))

    return suite

class DocFileCase(DocTestCase):

    def id(self):
        return '_'.join(self._dt_test.name.split('.'))

    def __repr__(self):
        return self._dt_test.filename

    def format_failure(self, err):
        return ('Failed doctest test for %s\n  File "%s", line 0\n\n%s'
                % (self._dt_test.name, self._dt_test.filename, err)
                )

def DocFileTest(path, module_relative=True, package=None,
                globs=None, parser=DocTestParser(),
                encoding=None, **options):
    if globs is None:
        globs = {}
    else:
        globs = globs.copy()

    if package and not module_relative:
        raise ValueError("Package may only be specified for module-"
                         "relative paths.")

    # Relativize the path.
    doc, path = _load_testfile(path, package, module_relative,
                               encoding or "utf-8")

    if "__file__" not in globs:
        globs["__file__"] = path

    # Find the file and read it.
    name = os.path.basename(path)

    # Convert it to a test, and wrap it in a DocFileCase.
    test = parser.get_doctest(doc, globs, name, path, 0)
    return DocFileCase(test, **options)

def DocFileSuite(*paths, **kw):
    """A unittest suite for one or more doctest files.

    The path to each doctest file is given as a string; the
    interpretation of that string depends on the keyword argument
    "module_relative".

    A number of options may be provided as keyword arguments:

    module_relative
      If "module_relative" is True, then the given file paths are
      interpreted as os-independent module-relative paths.  By
      default, these paths are relative to the calling module's
      directory; but if the "package" argument is specified, then
      they are relative to that package.  To ensure os-independence,
      "filename" should use "/" characters to separate path
      segments, and may not be an absolute path (i.e., it may not
      begin with "/").

      If "module_relative" is False, then the given file paths are
      interpreted as os-specific paths.  These paths may be absolute
      or relative (to the current working directory).

    package
      A Python package or the name of a Python package whose directory
      should be used as the base directory for module relative paths.
      If "package" is not specified, then the calling module's
      directory is used as the base directory for module relative
      filenames.  It is an error to specify "package" if
      "module_relative" is False.

    setUp
      A set-up function.  This is called before running the
      tests in each file. The setUp function will be passed a DocTest
      object.  The setUp function can access the test globals as the
      globs attribute of the test passed.

    tearDown
      A tear-down function.  This is called after running the
      tests in each file.  The tearDown function will be passed a DocTest
      object.  The tearDown function can access the test globals as the
      globs attribute of the test passed.

    globs
      A dictionary containing initial global variables for the tests.

    optionflags
      A set of doctest option flags expressed as an integer.

    parser
      A DocTestParser (or subclass) that should be used to extract
      tests from the files.

    encoding
      An encoding that will be used to convert the files to unicode.
    """
    suite = _DocTestSuite()

    # We do this here so that _normalize_module is called at the right
    # level.  If it were called in DocFileTest, then this function
    # would be the caller and we might guess the package incorrectly.
    if kw.get('module_relative', True):
        kw['package'] = _normalize_module(kw.get('package'))

    for path in paths:
        suite.addTest(DocFileTest(path, **kw))

    return suite

######################################################################
## 8. Debugging Support
######################################################################

def script_from_examples(s):
    r"""Extract script from text with examples.

       Converts text with examples to a Python script.  Example input is
       converted to regular code.  Example output and all other words
       are converted to comments:

       >>> text = '''
       ...       Here are examples of simple math.
       ...
       ...           Python has super accurate integer addition
       ...
       ...           >>> 2 + 2
       ...           5
       ...
       ...           And very friendly error messages:
       ...
       ...           >>> 1/0
       ...           To Infinity
       ...           And
       ...           Beyond
       ...
       ...           You can use logic if you want:
       ...
       ...           >>> if 0:
       ...           ...    blah
       ...           ...    blah
       ...           ...
       ...
       ...           Ho hum
       ...           '''

       >>> print(script_from_examples(text))
       # Here are examples of simple math.
       #
       #     Python has super accurate integer addition
       #
       2 + 2
       # Expected:
       ## 5
       #
       #     And very friendly error messages:
       #
       1/0
       # Expected:
       ## To Infinity
       ## And
       ## Beyond
       #
       #     You can use logic if you want:
       #
       if 0:
          blah
          blah
       #
       #     Ho hum
       <BLANKLINE>
       """
    output = []
    for piece in DocTestParser().parse(s):
        if isinstance(piece, Example):
            # Add the example's source code (strip trailing NL)
            output.append(piece.source[:-1])
            # Add the expected output:
            want = piece.want
            if want:
                output.append('# Expected:')
                output += ['## '+l for l in want.split('\n')[:-1]]
        else:
            # Add non-example text.
            output += [_comment_line(l)
                       for l in piece.split('\n')[:-1]]

    # Trim junk on both ends.
    while output and output[-1] == '#':
        output.pop()
    while output and output[0] == '#':
        output.pop(0)
    # Combine the output, and return it.
    # Add a courtesy newline to prevent exec from choking (see bug #1172785)
    return '\n'.join(output) + '\n'

def testsource(module, name):
    """Extract the test sources from a doctest docstring as a script.

    Provide the module (or dotted name of the module) containing the
    test to be debugged and the name (within the module) of the object
    with the doc string with tests to be debugged.
    """
    module = _normalize_module(module)
    tests = DocTestFinder().find(module)
    test = [t for t in tests if t.name == name]
    if not test:
        raise ValueError(name, "not found in tests")
    test = test[0]
    testsrc = script_from_examples(test.docstring)
    return testsrc

def debug_src(src, pm=False, globs=None):
    """Debug a single doctest docstring, in argument `src`'"""
    testsrc = script_from_examples(src)
    debug_script(testsrc, pm, globs)

def debug_script(src, pm=False, globs=None):
    "Debug a test script.  `src` is the script, as a string."
    import pdb

    if globs:
        globs = globs.copy()
    else:
        globs = {}

    if pm:
        try:
            exec(src, globs, globs)
        except:
            print(sys.exc_info()[1])
            p = pdb.Pdb(nosigint=True)
            p.reset()
            p.interaction(None, sys.exc_info()[2])
    else:
        pdb.Pdb(nosigint=True).run("exec(%r)" % src, globs, globs)

def debug(module, name, pm=False):
    """Debug a single doctest docstring.

    Provide the module (or dotted name of the module) containing the
    test to be debugged and the name (within the module) of the object
    with the docstring with tests to be debugged.
    """
    module = _normalize_module(module)
    testsrc = testsource(module, name)
    debug_script(testsrc, pm, module.__dict__)

######################################################################
## 9. Example Usage
######################################################################
class _TestClass:
    """
    A pointless class, for sanity-checking of docstring testing.

    Methods:
        square()
        get()

    >>> _TestClass(13).get() + _TestClass(-12).get()
    1
    >>> hex(_TestClass(13).square().get())
    '0xa9'
    """

    def __init__(self, val):
        """val -> _TestClass object with associated value val.

        >>> t = _TestClass(123)
        >>> print(t.get())
        123
        """

        self.val = val

    def square(self):
        """square() -> square TestClass's associated value

        >>> _TestClass(13).square().get()
        169
        """

        self.val = self.val ** 2
        return self

    def get(self):
        """get() -> return TestClass's associated value.

        >>> x = _TestClass(-42)
        >>> print(x.get())
        -42
        """

        return self.val

__test__ = {"_TestClass": _TestClass,
            "string": r"""
                      Example of a string object, searched as-is.
                      >>> x = 1; y = 2
                      >>> x + y, x * y
                      (3, 2)
                      """,

            "bool-int equivalence": r"""
                                    In 2.2, boolean expressions displayed
                                    0 or 1.  By default, we still accept
                                    them.  This can be disabled by passing
                                    DONT_ACCEPT_TRUE_FOR_1 to the new
                                    optionflags argument.
                                    >>> 4 == 4
                                    1
                                    >>> 4 == 4
                                    True
                                    >>> 4 > 4
                                    0
                                    >>> 4 > 4
                                    False
                                    """,

            "blank lines": r"""
                Blank lines can be marked with <BLANKLINE>:
                    >>> print('foo\n\nbar\n')
                    foo
                    <BLANKLINE>
                    bar
                    <BLANKLINE>
            """,

            "ellipsis": r"""
                If the ellipsis flag is used, then '...' can be used to
                elide substrings in the desired output:
                    >>> print(list(range(1000))) #doctest: +ELLIPSIS
                    [0, 1, 2, ..., 999]
            """,

            "whitespace normalization": r"""
                If the whitespace normalization flag is used, then
                differences in whitespace are ignored.
                    >>> print(list(range(30))) #doctest: +NORMALIZE_WHITESPACE
                    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
                     15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
                     27, 28, 29]
            """,
           }


def _test():
    import argparse

    parser = argparse.ArgumentParser(description="doctest runner")
    parser.add_argument('-v', '--verbose', action='store_true', default=False,
                        help='print very verbose output for all tests')
    parser.add_argument('-o', '--option', action='append',
                        choices=OPTIONFLAGS_BY_NAME.keys(), default=[],
                        help=('specify a doctest option flag to apply'
                              ' to the test run; may be specified more'
                              ' than once to apply multiple options'))
    parser.add_argument('-f', '--fail-fast', action='store_true',
                        help=('stop running tests after first failure (this'
                              ' is a shorthand for -o FAIL_FAST, and is'
                              ' in addition to any other -o options)'))
    parser.add_argument('file', nargs='+',
                        help='file containing the tests to run')
    args = parser.parse_args()
    testfiles = args.file
    # Verbose used to be handled by the "inspect argv" magic in DocTestRunner,
    # but since we are using argparse we are passing it manually now.
    verbose = args.verbose
    options = 0
    for option in args.option:
        options |= OPTIONFLAGS_BY_NAME[option]
    if args.fail_fast:
        options |= FAIL_FAST
    for filename in testfiles:
        if filename.endswith(".py"):
            # It is a module -- insert its dir into sys.path and try to
            # import it. If it is part of a package, that possibly
            # won't work because of package imports.
            dirname, filename = os.path.split(filename)
            sys.path.insert(0, dirname)
            m = __import__(filename[:-3])
            del sys.path[0]
            failures, _ = testmod(m, verbose=verbose, optionflags=options)
        else:
            failures, _ = testfile(filename, module_relative=False,
                                     verbose=verbose, optionflags=options)
        if failures:
            return 1
    return 0


if __name__ == "__main__":
    sys.exit(_test())
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Ñ
   .   ˙   ..  Ö
   __init__.py Ü
   __pycache__ õ
   _encoded_words.py   ú
    _header_value_parser.py ù
   _parseaddr.py   û
   _policybase.py  ü
   architecture.rst†
   base64mime.py   °
   
charset.py  ¢
   contentmanager.py   £
   encoders.py §
   	errors.py   •
   feedparser.py   ¶
   generator.pyß
   	header.py   ®
   headerregistry.py   ©
   iterators.py™
   
message.py  ´
   mimeø
   	parser.py   ¿
   	policy.py   ¡
   quoprimime.py   ¬
  ¸utils.py                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Copyright (C) 2001-2007 Python Software Foundation
# Author: Barry Warsaw
# Contact: email-sig@python.org

"""A package for parsing, handling, and generating email messages."""

__all__ = [
    'base64mime',
    'charset',
    'encoders',
    'errors',
    'feedparser',
    'generator',
    'header',
    'iterators',
    'message',
    'message_from_file',
    'message_from_binary_file',
    'message_from_string',
    'message_from_bytes',
    'mime',
    'parser',
    'quoprimime',
    'utils',
    ]


# Some convenience routines.  Don't import Parser and Message as side-effects
# of importing email since those cascadingly import most of the rest of the
# email package.
def message_from_string(s, *args, **kws):
    """Parse a string into a Message object model.

    Optional _class and strict are passed to the Parser constructor.
    """
    from email.parser import Parser
    return Parser(*args, **kws).parsestr(s)

def message_from_bytes(s, *args, **kws):
    """Parse a bytes string into a Message object model.

    Optional _class and strict are passed to the Parser constructor.
    """
    from email.parser import BytesParser
    return BytesParser(*args, **kws).parsebytes(s)

def message_from_file(fp, *args, **kws):
    """Read a file and parse its contents into a Message object model.

    Optional _class and strict are passed to the Parser constructor.
    """
    from email.parser import Parser
    return Parser(*args, **kws).parse(fp)

def message_from_binary_file(fp, *args, **kws):
    """Read a binary file and parse its contents into a Message object model.

    Optional _class and strict are passed to the Parser constructor.
    """
    from email.parser import BytesParser
    return BytesParser(*args, **kws).parse(fp)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Ü
   .   Ñ
   ..  á
    __init__.cpython-313.pycà
  ( _encoded_words.cpython-313.pyc  â
  , $_header_value_parser.cpython-313.pycä
  $ _parseaddr.cpython-313.pyc  ã
  $ _policybase.cpython-313.pyc å
  $ base64mime.cpython-313.pyc  ç
    charset.cpython-313.pyc é
  ( contentmanager.cpython-313.pyc  è
    encoders.cpython-313.pycê
    errors.cpython-313.pyc  ë
  $ feedparser.cpython-313.pyc  í
  $ generator.cpython-313.pyc   ì
    header.cpython-313.pyc  î
  ( headerregistry.cpython-313.pyc  ï
  $ iterators.cpython-313.pyc   ñ
    message.cpython-313.pyc ó
    parser.cpython-313.pyc  ò
    policy.cpython-313.pyc  ô
  $ quoprimime.cpython-313.pyc  ö
  Hutils.cpython-313.pyc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Û
    F\h‰  „                   Û(   ï S r / SQrS rS rS rS rg)z?A package for parsing, handling, and generating email messages.)⁄
base64mime⁄charset⁄encoders⁄errors⁄
feedparser⁄	generator⁄header⁄	iterators⁄message⁄message_from_file⁄message_from_binary_file⁄message_from_string⁄message_from_bytes⁄mime⁄parser⁄
quoprimime⁄utilsc                 Û<   ï SSK Jn  U" U0 UD6R                  U 5      $ )znParse a string into a Message object model.

Optional _class and strict are passed to the Parser constructor.
È    ©⁄Parser)⁄email.parserr   ⁄parsestr)⁄s⁄args⁄kwsr   s       ⁄%/usr/lib/python3.13/email/__init__.pyr   r      s"   Ä ı
 $Ÿê4–ò3—◊(—(®”+–+Û    c                 Û<   ï SSK Jn  U" U0 UD6R                  U 5      $ )ztParse a bytes string into a Message object model.

Optional _class and strict are passed to the Parser constructor.
r   ©⁄BytesParser)r   r    ⁄
parsebytes)r   r   r   r    s       r   r   r   '   s"   Ä ı
 )Ÿò–$†—$◊/—/∞”2–2r   c                 Û<   ï SSK Jn  U" U0 UD6R                  U 5      $ )zÇRead a file and parse its contents into a Message object model.

Optional _class and strict are passed to the Parser constructor.
r   r   )r   r   ⁄parse)⁄fpr   r   r   s       r   r   r   /   s"   Ä ı
 $Ÿê4–ò3—◊%—%†b”)–)r   c                 Û<   ï SSK Jn  U" U0 UD6R                  U 5      $ )zâRead a binary file and parse its contents into a Message object model.

Optional _class and strict are passed to the Parser constructor.
r   r   )r   r    r#   )r$   r   r   r    s       r   r   r   7   s"   Ä ı
 )Ÿò–$†—$◊*—*®2”.–.r   N)⁄__doc__⁄__all__r   r   r   r   © r   r   ⁄<module>r)      s&   Ò
 FÚÄÚ0,Ú3Ú*Û/r                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Û
    F\h]!  „                   Û4  ï S r SSKrSSKrSSKrSSKrSSKJrJr  SSKJ	r	  / SQr
\R                  " \R                  " S5      R                  S 5      rS r " S	 S
\5      r\" 5       rS\\" S5      '   S rS rS rS rS r\\S.rS r\\S.r\\S.rSS jrg)z•Routines for manipulating RFC2047 encoded words.

This is currently a package-private API, but will be considered for promotion
to a public API if there is demand.

È    N)⁄ascii_letters⁄digits)⁄errors)⁄decode_q⁄encode_q⁄decode_b⁄encode_b⁄len_q⁄len_b⁄decode⁄encodes   =([a-fA-F0-9]{2})c                 Ûf   ï [         R                  U R                  S5      R                  5       5      $ )NÈ   )⁄bytes⁄fromhex⁄groupr   )⁄ms    ⁄+/usr/lib/python3.13/email/_encoded_words.py⁄<lambda>r   A   s   Ä î%ó-ë-†ß°®£
◊ 1— 1” 3‘4Û    c                 Û@   ï U R                  SS5      n [        U 5      / 4$ )NÛ   _Û    )⁄replace⁄_q_byte_subber)⁄encodeds    r   r   r   C   s"   Ä ÿèoâoòd†D”)ÄG‹ò'”"†B–&–&r   c                   Ûj   ï \ rS rSrS\R
                  " S5      -   \R
                  " S5      -   rS rSr	g)⁄	_QByteMapÈI   s   -!*+/⁄asciic                 Ûp   ï XR                   ;   a  [        U5      X'   X   $ SR                  U5      X'   X   $ )Nz={:02X})⁄safe⁄chr⁄format)⁄self⁄keys     r   ⁄__missing__⁄_QByteMap.__missing__M   s=   Ä ÿó)ë)”‹òCõàDâI ây– "◊(—(®”-àDâIÿây–r   © N)
⁄__name__⁄
__module__⁄__qualname__⁄__firstlineno__r   r   r   r"   r'   ⁄__static_attributes__r)   r   r   r   r   I   s*   Ü ‡êm◊*“*®7”3—3∞f∑m≤m¿G”6L—LÄDır   r   ⁄_⁄ c                 Û2   ï SR                  S U  5       5      $ )N⁄ c              3   Û4   #   ï U  H  n[         U   v ï  M     g 7f©N)⁄_q_byte_map©⁄.0⁄xs     r   ⁄	<genexpr>⁄encode_q.<locals>.<genexpr>Z   s   È Ä –3™7†aî;òqñ>™7˘s   Ç)⁄join©⁄bstrings    r   r   r   Y   s   Ä ÿè7â7—3©7”3”3–3r   c                 Û&   ï [        S U  5       5      $ )Nc              3   ÛF   #   ï U  H  n[        [        U   5      v ï  M     g 7fr4   )⁄lenr5   r6   s     r   r9   ⁄len_q.<locals>.<genexpr>]   s   È Ä –4™G†qåsî;òqë>◊"–"™G˘s   Ç!)⁄sumr<   s    r   r
   r
   \   s   Ä ‹—4©G”4”4–4r   c                 Ûf  ï [        U 5      S-  nU(       a  SS SU-
   OSn [        R                  " X-   SS9U(       a  [        R                  " 5       /4$ / 4$ ! [
        R                   aƒ     [        R                  " U SS9[        R                  " 5       /4s $ ! [
        R                   a~     [        R                  " U S-   SS9[        R                  " 5       [        R                  " 5       /4s s $ ! [
        R                   a    U [        R                  " 5       /4s s s $ f = ff = ff = f)NÈ   s   ===r   T)⁄validateFs   ==)	r@   ⁄base64⁄	b64decoder   ⁄InvalidBase64PaddingDefect⁄binascii⁄Error⁄InvalidBase64CharactersDefect⁄InvalidBase64LengthDefect)r   ⁄pad_err⁄missing_paddings      r   r   r   d   s5  Ä Ù ê'ãlòQ—ÄGﬁ,3êfòZòa†ôi—(∏ÄOE‰◊“òW—6¿—Fﬁ5<åV◊.“.”0–1
 	
‡BD
 	
¯Ù è>â>Û E	E‰◊ “ †∞5—9‹◊5“5”7–8Ú ¯Ù è~â~Û 	EE‰◊$“$†W®u°_∏u—E‹◊9“9”;‹◊6“6”8:Ù ¯Ù
 ó>ë>Û E §◊!A“!A”!C– D–D÷DE˙	E˙E˙sZ   °3A ¡A ¡D0¡-*B¬D0¬D,¬/AC5√0D,√1D0√5,D(ƒ!D,ƒ#D0ƒ'D(ƒ(D,ƒ,D0c                 ÛL   ï [         R                  " U 5      R                  S5      $ )Nr    )rF   ⁄	b64encoder   r<   s    r   r	   r	   ä   s   Ä ‹◊“òG”$◊+—+®G”4–4r   c                 ÛV   ï [        [        U 5      S5      u  pUS-  U(       a  S-   $ S-   $ )NÈ   rD   r   )⁄divmodr@   )r=   ⁄groups_of_3⁄leftovers      r   r   r   ç   s.   Ä ‹"§3†w£<∞”3—ÄK‡òâ?¶8òa—3–3∞—3–3r   )⁄q⁄bc                 Û@  ï U R                  S5      u  pp4nUR                  S5      u  p!nUR                  5       nUR                  SS5      n[        U   " U5      u  pg UR                  U5      nXÇXW4$ ! [         a?    UR                  [        R                  " SU< S35      5        UR                  US5      n NL[        [        4 aS    UR                  SS5      nUR                  5       S:w  a*  UR                  [        R                  " SU< S	35      5         N≠f = f)
a[  Decode encoded word and return (string, charset, lang, defects) tuple.

An RFC 2047/2243 encoded word has the form:

    =?charset*lang?cte?encoded_string?=

where '*lang' may be omitted but the other parts may not be.

This function expects exactly such a string (that is, it does not check the
syntax and may raise errors if the string is not well formed), and returns
the encoded_string decoded first from its Content Transfer Encoding and
then from the resulting bytes into unicode using the specified charset.  If
the cte-decoded string does not successfully decode using the specified
character set, a defect is added to the defects list and the unknown octets
are replaced by the unicode 'unknown' character \uFDFF.

The specified charset and language are returned.  The default for language,
which is rarely if ever encountered, is the empty string.

⁄?⁄*r    ⁄surrogateescapez0Encoded word contains bytes not decodable using z charset˙unknown-8bitzUnknown charset z* in encoded word; decoded as unknown bytes)⁄split⁄	partition⁄lowerr   ⁄_cte_decodersr   ⁄UnicodeDecodeError⁄appendr   ⁄UndecodableBytesDefect⁄LookupError⁄UnicodeEncodeError⁄CharsetError)	⁄ewr/   ⁄charset⁄cte⁄
cte_string⁄langr=   ⁄defects⁄strings	            r   r   r   ò   s%  Ä * &(ßX°X®c£]—"ÄAê†ÿ◊(—(®”-—ÄGêÿ
è)â)ã+ÄC‡◊—†–):”;ÄG‹$†S“)®'”2—ÄG
?ÿóë†”(à òD–)–)¯Ù Û <ÿèâîv◊4“4 62ÿ29±∏H6FÛ GÙ 	H‡óë†–):”;ä‹‘+–,Û ?ÿóë†–):”;àÿè=â=ã?òn”,ÿèNâNú6◊.“.–1A¿'¡ M< 0=Û >Ù ?˘?˙s   ¡A3 ¡3AD¬;ADƒDc                 Û
  ï US:X  a  U R                  SS5      nOU R                  U5      nUc*  [        S   " U5      n[        S   " U5      nXV-
  S:  a  SOSn[        U   " U5      nU(       a  SU-   nSR                  XX'5      $ )	a„  Encode string using the CTE encoding that produces the shorter result.

Produces an RFC 2047/2243 encoded word of the form:

    =?charset*lang?cte?encoded_string?=

where '*lang' is omitted unless the 'lang' parameter is given a value.
Optional argument charset (defaults to utf-8) specifies the charset to use
to encode the string to binary before CTE encoding it.  Optional argument
'encoding' is the cte specifier for the encoding that should be used ('q'
or 'b'); if it is None (the default) the encoding which produces the
shortest encoded sequence is used, except that 'q' is preferred if it is up
to five characters longer.  Optional argument 'lang' (default '') gives the
RFC 2243 language string to specify in the encoded word.

r\   r    r[   rV   rW   È   rZ   z=?{}{}?{}?{}?=)r   ⁄_cte_encode_length⁄_cte_encodersr$   )rm   rh   ⁄encodingrk   r=   ⁄qlen⁄blenr   s           r   r   r   Ã   så   Ä " ê.” ÿó-ë-†–):”;â‡ó-ë-†”(àÿ—‹!†#“&†w”/à‹!†#“&†w”/à‡ô+®õ/ë3®sà‹òH“%†g”.ÄGﬁÿêTâzàÿ◊"—"†7∞(”D–Dr   )zutf-8Nr2   )⁄__doc__⁄rerF   rI   ⁄	functoolsrm   r   r   ⁄emailr   ⁄__all__⁄partial⁄compile⁄subr   r   ⁄dictr   r5   ⁄ordr   r
   r   r	   r   r`   r   rq   rp   r   r)   r   r   ⁄<module>r      sÃ   ÒÛR 
€ € € ﬂ (› ÚÄ ◊"“"†2ß:¢:–.C”#D◊#H—#HŸ4Û6ÄÚ'Ù	êÙ 	Ò ãkÄ ÄâCêãH— Ú4Ú5Ú$EÚL5Ú4 
ÿ	ÒÄÚ
'*V 
ÿ	ÒÄ 
ÿ	Ò– ı
Er                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Û
    F\hG≤ „            	       Û‹
  ï S r SSKrSSKrSSKrSSKJr  SSKJr  SSKJ	r
  SSKJr  SSKJr  \" S5      r\\" S	5      -  r\" S
5      r\\-  r\\" S5      -
  r\\" S5      -
  r\\" S5      -  \" S5      -
  r\\-  r\\" S5      -  r\\-  r\\" S5      -
  rSS1r\\-  rS rS r\R:                  " S\R<                  \R>                  -  5      r  " S S\!5      r" " S S\"5      r# " S S\"5      r$ " S S\"5      r% " S S\"5      r& " S S \#5      r' " S! S"\"5      r( " S# S$\"5      r) " S% S&\"5      r* " S' S(\"5      r+ " S) S*\+5      r, " S+ S,\#5      r- " S- S.\"5      r. " S/ S0\"5      r/ " S1 S2\"5      r0 " S3 S4\"5      r1 " S5 S6\"5      r2 " S7 S8\"5      r3 " S9 S:\"5      r4 " S; S<\"5      r5 " S= S>\"5      r6 " S? S@\"5      r7 " SA SB\"5      r8 " SC SD\"5      r9 " SE SF\"5      r: " SG SH\"5      r; " SI SJ\"5      r< " SK SL\"5      r= " SM SN\%5      r> " SO SP\"5      r? " SQ SR\"5      r@ " SS ST\"5      rA " SU SV\"5      rB " SW SX\B5      rC " SY SZ\"5      rD " S[ S\\"5      rE " S] S^\"5      rF " S_ S`\"5      rG " Sa Sb\"5      rH " Sc Sd\H5      rI " Se Sf\H5      rJ " Sg Sh\"5      rK " Si Sj\"5      rL " Sk Sl\"5      rM " Sm Sn\M5      rN " So Sp\N5      rO " Sq Sr\"5      rP " Ss St\Q5      rR " Su Sv\R5      rS " Sw Sx\R5      rT " Sy Sz\S5      rU " S{ S|\R¨                  5      rW\T" SS}5      rX\T" S~S5      rYSÄ\YlZ        SÄ\Yl[        \T" SÅSÇ5      r\\R:                  " SÉRª                  SÑRΩ                  \5      5      5      Ræ                  r`\R:                  " SÖRª                  \R¬                  " SÑRΩ                  \5      5      5      5      Rƒ                  rc\R:                  " SÜ5      R»                  re\R:                  " SÖRª                  \R¬                  " SÑRΩ                  \5      5      5      5      Rƒ                  rf\R:                  " SÖRª                  \R¬                  " SÑRΩ                  \5      5      5      5      Rƒ                  rg\R:                  " SÖRª                  \R¬                  " SÑRΩ                  \5      5      5      5      Rƒ                  rhSá riSà rjSâ rkS¡Sä jrlSã rmSå rnSç roSé rpSè rqSê rrSë rsSí rtSì ruSî rvSï rwSñ rxSó rySò rzSô r{Sö r|Sõ r}Sú r~Sù rSû rÄSü rÅS† rÇS° rÉS¢ rÑS£ rÖS§ rÜS• ráS¶ ràSß râS® räS© rãS™ råS´ rçS¨ réS≠ rèSÆ rêSØ rëS∞ ríS± rìS≤ rîS≥ rïS¥ rñSµ róS∂ ròS∑ rôS∏ röSπ rõS∫ rúSª rùSº rûSΩ rüSæ r†Sø r°S¿ r¢g)¬al  Header value parser implementing various email-related RFC parsing rules.

The parsing methods defined in this module implement various email related
parsing rules.  Principal among them is RFC 5322, which is the followon
to RFC 2822 and primarily a clarification of the former.  It also implements
RFC 2047 encoded word decoding.

RFC 5322 goes to considerable trouble to maintain backward compatibility with
RFC 822 in the parse phase, while cleaning up the structure on the generation
phase.  This parser supports correct RFC 5322 generation by tagging white space
as folding white space only when folding is allowed in the non-obsolete rule
sets.  Actually, the parser is even more generous when accepting input than RFC
5322 mandates, following the spirit of Postel's Law, which RFC 5322 encourages.
Where possible deviations from the standard are annotated on the 'defects'
attribute of tokens that deviate.

The general structure of the parser follows RFC 5322, and uses its terminology
where there is a direct correspondence.  Where the implementation requires a
somewhat different structure than that used by the formal grammar, new terms
that mimic the closest existing terms are used.  Thus, it really helps to have
a copy of RFC 5322 handy when studying this code.

Input to the parser is a string that has already been unfolded according to
RFC 5322 rules.  According to the RFC this unfolding is the very first step, and
this parser leaves the unfolding step to a higher level message parser, which
will have already detected the line breaks that need unfolding while
determining the beginning and end of each header.

The output of the parser is a TokenList object, which is a list subclass.  A
TokenList is a recursive data structure.  The terminal nodes of the structure
are Terminal objects, which are subclasses of str.  These do not correspond
directly to terminal objects in the formal grammar, but are instead more
practical higher level combinations of true terminals.

All TokenList and Terminal objects have a 'value' attribute, which produces the
semantically meaningful value of that part of the parse subtree.  The value of
all whitespace tokens (no matter how many sub-tokens they may contain) is a
single space, as per the RFC rules.  This includes 'CFWS', which is herein
included in the general class of whitespace tokens.  There is one exception to
the rule that whitespace tokens are collapsed into single spaces in values: in
the value of a 'bare-quoted-string' (a quoted-string with no leading or
trailing whitespace), any whitespace that appeared between the quotation marks
is preserved in the returned value.  Note that in all Terminal strings quoted
pairs are turned into their unquoted values.

All TokenList and Terminal objects also have a string value, which attempts to
be a "canonical" representation of the RFC-compliant form of the substring that
produced the parsed subtree, including minimal use of quoted pair quoting.
Whitespace runs are not collapsed.

Comment tokens also have a 'content' attribute providing the string found
between the parens (including any nested comments) with whitespace preserved.

All TokenList and Terminal objects have a 'defects' attribute which is a
possibly empty list all of the defects found while creating the token.  Defects
may appear on any token in the tree, and a composite list of all defects in the
subtree is available through the 'all_defects' attribute of any node.  (For
Terminal notes x.defects == x.all_defects.)

Each object in a parse tree is called a 'token', and each has a 'token_type'
attribute that gives the name from the RFC 5322 grammar that it represents.
Not all RFC 5322 nodes are produced, and there is one non-RFC 5322 node that
may be produced: 'ptext'.  A 'ptext' is a string of printable ascii characters.
It is returned in place of lists of (ctext/quoted-pair) and
(qtext/quoted-pair).

XXX: provide complete list of token types.
È    N)⁄	hexdigits)⁄
itemgetter)⁄_encoded_words)⁄errors)⁄utilsz 	⁄(z()<>@,:;.\"[]⁄.z."(z/?=z*'%⁄%⁄
⁄c                 ÛX   ï [        U 5      R                  SS5      R                  SS5      $ )z;Escape dquote and backslash for use within a quoted-string.⁄\˙\\⁄"z\")⁄str⁄replace©⁄values    ⁄1/usr/lib/python3.13/email/_header_value_parser.py⁄make_quoted_pairsr   c   s&   Ä ‰àuã:◊—òd†F”+◊3—3∞C∏”?–?Û    c                 Û$   ï [        U 5      nSU S3$ )Nr   )r   )r   ⁄escapeds     r   ⁄quote_stringr   h   s   Ä ‹†”&ÄGÿàwàiêqà>–r   zÒ
   =\?            # literal =?
   [^?]*          # charset
   \?             # literal ?
   [qQbB]         # literal 'q' or 'b', case insensitive
   \?             # literal ?
  .*?             # encoded word
  \?=             # literal ?=
c                   Û∞   ^ ï \ rS rSrSrSrSrU 4S jrS rU 4S jr	\
S 5       r\
S 5       rS	 r\
S
 5       r\
S 5       rS rSS jrSS jrSS jrSrU =r$ )⁄	TokenListÈ}   NTc                 Û4   >ï [         TU ]  " U0 UD6  / U l        g ©N)⁄super⁄__init__⁄defects)⁄self⁄args⁄kw⁄	__class__s      Är   r!   ⁄TokenList.__init__É   s   ¯Ä ‹â“ò$–%†"“%ÿàçr   c                 Û2   ï SR                  S U  5       5      $ )N⁄ c              3   Û8   #   ï U  H  n[        U5      v ï  M     g 7fr   ©r   ©⁄.0⁄xs     r   ⁄	<genexpr>⁄$TokenList.__str__.<locals>.<genexpr>à   Û   È Ä –,¢t†!îsò1óvêv¢t˘Û   Ç©⁄join©r#   s    r   ⁄__str__⁄TokenList.__str__á   s   Ä ÿèwâw—,°t”,”,–,r   c                 Ûh   >ï SR                  U R                  R                  [        TU ]  5       5      $ ©Nz{}({})©⁄formatr&   ⁄__name__r    ⁄__repr__©r#   r&   s    Är   r=   ⁄TokenList.__repr__ä   s+   ¯Ä ÿèâòtü~ô~◊6—6‹"ôW—-”/Û1 	1r   c                 Û2   ï SR                  S U  5       5      $ )Nr)   c              3   Û^   #   ï U  H#  oR                   (       d  M  UR                   v ï  M%     g 7fr   r   r,   s     r   r/   ⁄"TokenList.value.<locals>.<genexpr>ê   s   È Ä –8™†1∑µìwêqówñw™˘s   Ç-ö-r3   r5   s    r   r   ⁄TokenList.valueé   s   Ä ‡èwâw—8©”8”8–8r   c                 Û<   ï [        S U  5       U R                  5      $ )Nc              3   Û8   #   ï U  H  oR                   v ï  M     g 7fr   )⁄all_defectsr,   s     r   r/   ⁄(TokenList.all_defects.<locals>.<genexpr>î   s   È Ä –0™4†aóMñM™4˘r2   )⁄sumr"   r5   s    r   rF   ⁄TokenList.all_defectsí   s   Ä ‰—0©4”0∞$∑,±,”?–?r   c                 Û(   ï U S   R                  5       $ ©Nr   )⁄startswith_fwsr5   s    r   rL   ⁄TokenList.startswith_fwsñ   s   Ä ÿêAâw◊%—%”'–'r   c                 Û&   ï [        S U  5       5      $ )zATrue if all top level tokens of this part may be RFC2047 encoded.c              3   Û8   #   ï U  H  oR                   v ï  M     g 7fr   )⁄as_ew_allowed)r-   ⁄parts     r   r/   ⁄*TokenList.as_ew_allowed.<locals>.<genexpr>ú   s   È Ä –7≤$®$◊%÷%≤$˘r2   )⁄allr5   s    r   rP   ⁄TokenList.as_ew_allowedô   s   Ä Ù —7±$”7”7–7r   c                 ÛR   ï / nU  H  nUR                  UR                  5        M      U$ r   )⁄extend⁄comments)r#   rW   ⁄tokens      r   rW   ⁄TokenList.commentsû   s&   Ä ‡à€àEÿèOâOòEüNôN÷+Ò ‡àr   c                Û   ï [        XS9$ )N©⁄policy)⁄_refold_parse_tree©r#   r\   s     r   ⁄fold⁄TokenList.fold•   s   Ä ‹!†$—6–6r   c                 Û4   ï [        U R                  US95        g )N©⁄indent)⁄print⁄ppstr©r#   rc   s     r   ⁄pprint⁄TokenList.pprint®   s   Ä ‹àdèjâj†àj–'’(r   c                 Û>   ï SR                  U R                  US95      $ )Nr   rb   )r4   ⁄_pprf   s     r   re   ⁄TokenList.ppstr´   s   Ä ÿèyâyòüô®ò–0”1–1r   c              #   Ûñ  #   ï SR                  UU R                  R                  U R                  5      v ï  U  HH  n[	        US5      (       d  USR                  U5      -   v ï  M,  UR                  US-   5       S h  vïN   MJ     U R                  (       a  SR                  U R                  5      nOSnSR                  X5      v ï  g  NK7f)Nz{}{}/{}(rj   z*    !! invalid element in token list: {!r}z    z Defects: {}r)   z{}){})r;   r&   r<   ⁄
token_type⁄hasattrrj   r"   )r#   rc   rX   ⁄extras       r   rj   ⁄TokenList._ppÆ   s≥   È Ä ÿ◊—ÿÿèNâN◊#—#ÿèOâOÛÚ 	Û àE‹ò5†%◊(—(ÿ !5ﬂ5;±V∏E≥]ÒCÙ D !ü9ô9†V®F°]”3◊3“3Ò  è<è<ÿ"◊)—)®$Ø,©,”7âE‡àEÿènânòV”+”+Ò 4˘s   ÇA9C	¡;C¡<AC	)r"   ©r)   )r<   ⁄
__module__⁄__qualname__⁄__firstlineno__rm   ⁄syntactic_break⁄ew_combine_allowedr!   r6   r=   ⁄propertyr   rF   rL   rP   rW   r_   rg   re   rj   ⁄__static_attributes__⁄__classcell__©r&   s   @r   r   r   }   sí   ¯Ü ‡ÄJÿÄOÿ–ıÚ-ı1 Ò9Û 9 Ò@Û @Ú( Ò8Û 8 ÒÛ Ú7Ù)Ù2˜,Ú ,r   r   c                   Û4   ï \ rS rSr\S 5       r\S 5       rSrg)⁄WhiteSpaceTokenListÈ¿   c                 Û   ï g©N⁄ © r5   s    r   r   ⁄WhiteSpaceTokenList.value¬   Û   Ä ‡r   c                 Ûh   ï U  Vs/ s H   oR                   S:X  d  M  UR                  PM"     sn$ s  snf )N⁄comment)rm   ⁄content©r#   r.   s     r   rW   ⁄WhiteSpaceTokenList.comments∆   s)   Ä ·#'”C¢4òaØ<©<∏—+Bì	êó	î	°4—C–C˘“CÛ   Ö/ú/rÅ   N)r<   rr   rs   rt   rw   r   rW   rx   rÅ   r   r   r|   r|   ¿   s*   Ü ‡ÒÛ  ÒDÛ ÛDr   r|   c                   Û   ï \ rS rSrSrSrg)⁄UnstructuredTokenListÈÀ   ⁄unstructuredrÅ   N©r<   rr   rs   rt   rm   rx   rÅ   r   r   rã   rã   À   s   Ü ÿÉJr   rã   c                   Û   ï \ rS rSrSrSrg)⁄PhraseÈœ   ⁄phraserÅ   Nré   rÅ   r   r   rê   rê   œ   Û   Ü ÿÉJr   rê   c                   Û   ï \ rS rSrSrSrg)⁄WordÈ“   ⁄wordrÅ   Nré   rÅ   r   r   rï   rï   “   Û   Ü ÿÉJr   rï   c                   Û   ï \ rS rSrSrSrg)⁄CFWSListÈ÷   ⁄cfwsrÅ   Nré   rÅ   r   r   rö   rö   ÷   rò   r   rö   c                   Û   ï \ rS rSrSrSrg)⁄AtomÈ⁄   ⁄atomrÅ   Nré   rÅ   r   r   rû   rû   ⁄   rò   r   rû   c                   Û   ï \ rS rSrSrSrSrg)⁄TokenÈﬁ   rX   FrÅ   N)r<   rr   rs   rt   rm   ⁄encode_as_ewrx   rÅ   r   r   r¢   r¢   ﬁ   s   Ü ÿÄJÿÉLr   r¢   c                   Û$   ï \ rS rSrSrSrSrSrSrg)⁄EncodedWordÈ„   ˙encoded-wordNrÅ   )	r<   rr   rs   rt   rm   ⁄cte⁄charset⁄langrx   rÅ   r   r   r¶   r¶   „   s   Ü ÿÄJÿ
ÄCÿÄGÿÉDr   r¶   c                   ÛH   ï \ rS rSrSr\S 5       r\S 5       r\S 5       rSr	g)⁄QuotedStringÈÍ   ˙quoted-stringc                 ÛR   ï U  H!  nUR                   S:X  d  M  UR                  s  $    g ©N˙bare-quoted-string©rm   r   rá   s     r   rÜ   ⁄QuotedString.contentÓ   s"   Ä „àAÿè|â|–3’3ÿówëwíÚ r   c                 Û»   ï / nU  HJ  nUR                   S:X  a  UR                  [        U5      5        M/  UR                  UR                  5        ML     SR	                  U5      $ )Nr≤   r)   )rm   ⁄appendr   r   r4   )r#   ⁄resr.   s      r   ⁄quoted_value⁄QuotedString.quoted_valueÙ   sN   Ä ‡à€àAÿè|â|–3”3ÿó
ë
ú3òqõ6÷"‡ó
ë
ò1ü7ô7÷#Ò	 
 èwâwêsã|–r   c                 ÛR   ï U  H!  nUR                   S:X  d  M  UR                  s  $    g r±   r≥   ©r#   rX   s     r   ⁄stripped_value⁄QuotedString.stripped_value˛   s%   Ä „àEÿ◊—–#7’7ÿó{ë{“"Ú r   rÅ   N)
r<   rr   rs   rt   rm   rw   rÜ   r∏   rº   rx   rÅ   r   r   r≠   r≠   Í   sA   Ü ‡ ÄJ‡ÒÛ 
 ÒÛ  Ò#Û Û#r   r≠   c                   Û.   ï \ rS rSrSrS r\S 5       rSrg)⁄BareQuotedStringi  r≤   c                 ÛD   ï [        SR                  S U  5       5      5      $ )Nr)   c              3   Û8   #   ï U  H  n[        U5      v ï  M     g 7fr   r+   r,   s     r   r/   ⁄+BareQuotedString.__str__.<locals>.<genexpr>
  s   È Ä –#9≤D®q§C®ßF†F≤D˘r2   )r   r4   r5   s    r   r6   ⁄BareQuotedString.__str__	  s   Ä ‹òBüGôG—#9±D”#9”9”:–:r   c                 Û2   ï SR                  S U  5       5      $ )Nr)   c              3   Û8   #   ï U  H  n[        U5      v ï  M     g 7fr   r+   r,   s     r   r/   ⁄)BareQuotedString.value.<locals>.<genexpr>  r1   r2   r3   r5   s    r   r   ⁄BareQuotedString.value  Û   Ä ‡èwâw—,°t”,”,–,r   rÅ   N)	r<   rr   rs   rt   rm   r6   rw   r   rx   rÅ   r   r   rø   rø     s    Ü ‡%ÄJÚ; Ò-Û Û-r   rø   c                   ÛD   ï \ rS rSrSrS rS r\S 5       r\S 5       r	Sr
g)	⁄Commenti  rÖ   c                 Ûä   ï SR                  [        S/U  Vs/ s H  oR                  U5      PM     snS/// 5      5      $ s  snf )Nr)   r   ⁄))r4   rH   ⁄quoterá   s     r   r6   ⁄Comment.__str__  sI   Ä ÿèwâwîsÿ òEŸ48”9≤D®qüZôZ®û]±D—9ÿ òE  "Û	#Û $ 	$˘‚9s   óA c                 ÛÆ   ï UR                   S:X  a  [        U5      $ [        U5      R                  SS5      R                  SS5      R                  SS5      $ )NrÖ   r   r   r   z\(rÃ   z\))rm   r   r   )r#   r   s     r   rÕ   ⁄Comment.quote  sR   Ä ÿ◊—òy”(‹êuì:–‹ê5ãz◊!—!†$®”/◊7—7ÿ"%†uÛ.ﬂ.5©gÿ"%†uÛ/.	.r   c                 Û2   ï SR                  S U  5       5      $ )Nr)   c              3   Û8   #   ï U  H  n[        U5      v ï  M     g 7fr   r+   r,   s     r   r/   ⁄"Comment.content.<locals>.<genexpr>%  r1   r2   r3   r5   s    r   rÜ   ⁄Comment.content#  r»   r   c                 Û   ï U R                   /$ r   )rÜ   r5   s    r   rW   ⁄Comment.comments'  s   Ä ‡óëà~–r   rÅ   N)r<   rr   rs   rt   rm   r6   rÕ   rw   rÜ   rW   rx   rÅ   r   r   r    r      s9   Ü ‡ÄJÚ$Ú. Ò-Û - ÒÛ Ûr   r    c                   ÛH   ï \ rS rSrSr\S 5       r\S 5       r\S 5       rSr	g)⁄AddressListi+  zaddress-listc                 ÛT   ï U  Vs/ s H  oR                   S:X  d  M  UPM     sn$ s  snf )N⁄address©rm   rá   s     r   ⁄	addresses⁄AddressList.addresses/  Û#   Ä ·”;ö4êaß<°<∞—#:óô4—;–;˘“;Û   Ö%ú%c                 Û(   ï [        S U  5       / 5      $ )Nc              3   Û\   #   ï U  H"  oR                   S :X  d  M  UR                  v ï  M$     g7f©r⁄   N©rm   ⁄	mailboxesr,   s     r   r/   ⁄(AddressList.mailboxes.<locals>.<genexpr>5  s&   È Ä  >⁄!òß\°\∞9—%<Û  êAóKñK⁄!˘Û   Ç,ô,©rH   r5   s    r   r‰   ⁄AddressList.mailboxes3  Û!   Ä ‰Ò >Ÿ!Û>ÿ?AÛC 	Cr   c                 Û(   ï [        S U  5       / 5      $ )Nc              3   Û\   #   ï U  H"  oR                   S :X  d  M  UR                  v ï  M$     g7fr‚   ©rm   ⁄all_mailboxesr,   s     r   r/   ⁄,AddressList.all_mailboxes.<locals>.<genexpr>:  s&   È Ä  >⁄!òß\°\∞9—%<Û $êAóOñO⁄!˘rÊ   rÁ   r5   s    r   rÌ   ⁄AddressList.all_mailboxes8  rÈ   r   rÅ   N)
r<   rr   rs   rt   rm   rw   r‹   r‰   rÌ   rx   rÅ   r   r   rÿ   rÿ   +  sE   Ü ‡ÄJ‡Ò<Û < ÒCÛ C ÒCÛ ÛCr   rÿ   c                   ÛH   ï \ rS rSrSr\S 5       r\S 5       r\S 5       rSr	g)⁄Addressi>  r⁄   c                 ÛH   ï U S   R                   S:X  a  U S   R                  $ g )Nr   ⁄group©rm   ⁄display_namer5   s    r   rı   ⁄Address.display_nameB  s)   Ä ‡êâ7◊—†”(ÿòë7◊'—'–' )r   c                 Û|   ï U S   R                   S:X  a  U S   /$ U S   R                   S:X  a  / $ U S   R                  $ ©Nr   ⁄mailbox˙invalid-mailboxr„   r5   s    r   r‰   ⁄Address.mailboxesG  sH   Ä ‡êâ7◊—†”*ÿòëGê9–ÿê!âW◊—–#4”4ÿàIÿêAâw◊ — – r   c                 ÛÑ   ï U S   R                   S:X  a  U S   /$ U S   R                   S:X  a  U S   /$ U S   R                  $ r¯   rÏ   r5   s    r   rÌ   ⁄Address.all_mailboxesO  sO   Ä ‡êâ7◊—†”*ÿòëGê9–ÿê!âW◊—–#4”4ÿòëGê9–ÿêAâw◊$—$–$r   rÅ   N)
r<   rr   rs   rt   rm   rw   rı   r‰   rÌ   rx   rÅ   r   r   rÒ   rÒ   >  sA   Ü ‡ÄJ‡Ò(Û ( Ò!Û ! Ò%Û Û%r   rÒ   c                   Û8   ï \ rS rSrSr\S 5       r\S 5       rSrg)⁄MailboxListiW  ˙mailbox-listc                 ÛT   ï U  Vs/ s H  oR                   S:X  d  M  UPM     sn$ s  snf )Nr˘   r€   rá   s     r   r‰   ⁄MailboxList.mailboxes[  rﬁ   rﬂ   c                 ÛV   ï U  Vs/ s H  nUR                   S;   d  M  UPM     sn$ s  snf )N)r˘   r˙   r€   rá   s     r   rÌ   ⁄MailboxList.all_mailboxes_  s2   Ä ·Û ?ö4êaÿè|â|–=—=˜ ô4Ò ? 	?˘Ú ?s   Ö&ù&rÅ   N©	r<   rr   rs   rt   rm   rw   r‰   rÌ   rx   rÅ   r   r   rˇ   rˇ   W  s-   Ü ‡ÄJ‡Ò<Û < Ò?Û Û?r   rˇ   c                   Û8   ï \ rS rSrSr\S 5       r\S 5       rSrg)⁄	GroupListie  ˙
group-listc                 ÛX   ï U (       a  U S   R                   S:w  a  / $ U S   R                  $ ©Nr   r   r„   r5   s    r   r‰   ⁄GroupList.mailboxesi  s+   Ä ÊêtòAëw◊)—)®^”;ÿàIÿêAâw◊ — – r   c                 ÛX   ï U (       a  U S   R                   S:w  a  / $ U S   R                  $ r
  rÏ   r5   s    r   rÌ   ⁄GroupList.all_mailboxeso  s+   Ä ÊêtòAëw◊)—)®^”;ÿàIÿêAâw◊$—$–$r   rÅ   Nr  rÅ   r   r   r  r  e  s-   Ü ‡ÄJ‡Ò!Û !
 Ò%Û Û%r   r  c                   ÛH   ï \ rS rSrSr\S 5       r\S 5       r\S 5       rSr	g)⁄Groupiv  rÛ   c                 ÛJ   ï U S   R                   S:w  a  / $ U S   R                  $ ©NÈ   r  r„   r5   s    r   r‰   ⁄Group.mailboxesz  s)   Ä ‡êâ7◊—†”-ÿàIÿêAâw◊ — – r   c                 ÛJ   ï U S   R                   S:w  a  / $ U S   R                  $ r  rÏ   r5   s    r   rÌ   ⁄Group.all_mailboxesÄ  s)   Ä ‡êâ7◊—†”-ÿàIÿêAâw◊$—$–$r   c                 Û    ï U S   R                   $ rK   )rı   r5   s    r   rı   ⁄Group.display_nameÜ  s   Ä ‡êAâw◊#—#–#r   rÅ   N)
r<   rr   rs   rt   rm   rw   r‰   rÌ   rı   rx   rÅ   r   r   r  r  v  sA   Ü ‡ÄJ‡Ò!Û !
 Ò%Û %
 Ò$Û Û$r   r  c                   Ûh   ï \ rS rSrSr\S 5       r\S 5       r\S 5       r\S 5       r	\S 5       r
Srg	)
⁄NameAddriã  ˙	name-addrc                 Û@   ï [        U 5      S:X  a  g U S   R                  $ ©NÈ   r   )⁄lenrı   r5   s    r   rı   ⁄NameAddr.display_nameè  s    Ä ‰àtã9òã>ÿÿêAâw◊#—#–#r   c                 Û    ï U S   R                   $ ©NÈˇˇˇˇ©⁄
local_partr5   s    r   r$  ⁄NameAddr.local_partï  s   Ä ‡êBâx◊"—"–"r   c                 Û    ï U S   R                   $ r!  ©⁄domainr5   s    r   r(  ⁄NameAddr.domainô  s   Ä ‡êBâxèâ–r   c                 Û    ï U S   R                   $ r!  )⁄router5   s    r   r+  ⁄NameAddr.routeù  s   Ä ‡êBâxè~â~–r   c                 Û    ï U S   R                   $ r!  ©⁄	addr_specr5   s    r   r/  ⁄NameAddr.addr_spec°  s   Ä ‡êBâx◊!—!–!r   rÅ   N©r<   rr   rs   rt   rm   rw   rı   r$  r(  r+  r/  rx   rÅ   r   r   r  r  ã  si   Ü ‡ÄJ‡Ò$Û $
 Ò#Û # ÒÛ  ÒÛ  Ò"Û Û"r   r  c                   ÛX   ï \ rS rSrSr\S 5       r\S 5       r\S 5       r\S 5       r	Sr
g)	⁄	AngleAddri¶  z
angle-addrc                 ÛR   ï U  H!  nUR                   S:X  d  M  UR                  s  $    g ©N˙	addr-spec)rm   r$  rá   s     r   r$  ⁄AngleAddr.local_part™  s"   Ä „àAÿè|â|ò{’*ÿó|ë|“#Ú r   c                 ÛR   ï U  H!  nUR                   S:X  d  M  UR                  s  $    g r5  ©rm   r(  rá   s     r   r(  ⁄AngleAddr.domain∞  s!   Ä „àAÿè|â|ò{’*ÿóxëxíÚ r   c                 ÛR   ï U  H!  nUR                   S:X  d  M  UR                  s  $    g )N˙	obs-route)rm   ⁄domainsrá   s     r   r+  ⁄AngleAddr.route∂  s"   Ä „àAÿè|â|ò{’*ÿóyëy“ Ú r   c                 Ûº   ï U  HV  nUR                   S:X  d  M  UR                  (       a  UR                  s  $ [        UR                  5      UR                  -   s  $    g)Nr6  z<>)rm   r$  r/  r   rá   s     r   r/  ⁄AngleAddr.addr_specº  sF   Ä „àAÿè|â|ò{’*ÿó<ó<ÿü;ô;“&‰'®Ø©”5∏øπ—C“CÒ  r   rÅ   N)r<   rr   rs   rt   rm   rw   r$  r(  r+  r/  rx   rÅ   r   r   r3  r3  ¶  sU   Ü ‡ÄJ‡Ò$Û $
 Ò Û  
 Ò!Û !
 ÒÛ Ûr   r3  c                   Û(   ï \ rS rSrSr\S 5       rSrg)⁄ObsRoutei»  r<  c                 Ûh   ï U  Vs/ s H   oR                   S:X  d  M  UR                  PM"     sn$ s  snf )Nr(  r9  rá   s     r   r=  ⁄ObsRoute.domainsÃ  s)   Ä ·"&”C¢$òQØ,©,∏(—*Bìêóî°$—C–C˘“Crâ   rÅ   N)r<   rr   rs   rt   rm   rw   r=  rx   rÅ   r   r   rB  rB  »  s   Ü ‡ÄJ‡ÒDÛ ÛDr   rB  c                   Ûh   ï \ rS rSrSr\S 5       r\S 5       r\S 5       r\S 5       r	\S 5       r
Srg	)
⁄Mailboxi—  r˘   c                 ÛH   ï U S   R                   S:X  a  U S   R                  $ g ©Nr   r  rÙ   r5   s    r   rı   ⁄Mailbox.display_name’  s)   Ä ‡êâ7◊—†”,ÿòë7◊'—'–' -r   c                 Û    ï U S   R                   $ rK   r#  r5   s    r   r$  ⁄Mailbox.local_part⁄  Û   Ä ‡êAâw◊!—!–!r   c                 Û    ï U S   R                   $ rK   r'  r5   s    r   r(  ⁄Mailbox.domainﬁ  s   Ä ‡êAâwè~â~–r   c                 ÛH   ï U S   R                   S:X  a  U S   R                  $ g rH  )rm   r+  r5   s    r   r+  ⁄Mailbox.route‚  s'   Ä ‡êâ7◊—†”,ÿòë7ó=ë=–  -r   c                 Û    ï U S   R                   $ rK   r.  r5   s    r   r/  ⁄Mailbox.addr_specÁ  s   Ä ‡êAâw◊ — – r   rÅ   Nr1  rÅ   r   r   rF  rF  —  si   Ü ‡ÄJ‡Ò(Û ( Ò"Û " ÒÛ  Ò!Û ! Ò!Û Û!r   rF  c                   Û8   ï \ rS rSrSr\S 5       r\=r=r=r	r
Srg)⁄InvalidMailboxiÏ  r˙   c                 Û   ï g r   rÅ   r5   s    r   rı   ⁄InvalidMailbox.display_name  Û   Ä ‡r   rÅ   Nr1  rÅ   r   r   rT  rT  Ï  s/   Ü ‡"ÄJ‡ÒÛ  /;–:ÄJ–:ê–:ò%£)r   rT  c                   Û:   ^ ï \ rS rSrSrSr\U 4S j5       rSrU =r	$ )⁄Domaini˜  r(  Fc                 ÛR   >ï SR                  [        TU ]  R                  5       5      $ ©Nr)   ©r4   r    r   ⁄splitr>   s    Är   r(  ⁄Domain.domain¸  Û   ¯Ä ‡èwâwîuëwë}◊*—*”,”-–-r   rÅ   )
r<   rr   rs   rt   rm   rP   rw   r(  rx   ry   rz   s   @r   rY  rY  ˜  s   ¯Ü ‡ÄJÿÄM‡Ù.Û ˆ.r   rY  c                   Û   ï \ rS rSrSrSrg)⁄DotAtomi  ˙dot-atomrÅ   Nré   rÅ   r   r   ra  ra    s   Ü ÿÉJr   ra  c                   Û   ï \ rS rSrSrSrSrg)⁄DotAtomTexti  zdot-atom-textTrÅ   N©r<   rr   rs   rt   rm   rP   rx   rÅ   r   r   rd  rd    s   Ü ÿ ÄJÿÉMr   rd  c                   Û   ï \ rS rSrSrSrSrg)⁄NoFoldLiterali
  zno-fold-literalFrÅ   Nre  rÅ   r   r   rg  rg  
  s   Ü ÿ"ÄJÿÉMr   rg  c                   Û\   ï \ rS rSrSrSr\S 5       r\S 5       r\S 5       r	\S 5       r
Srg	)
⁄AddrSpeci  r6  Fc                 Û    ï U S   R                   $ rK   r#  r5   s    r   r$  ⁄AddrSpec.local_part  rL  r   c                 Û@   ï [        U 5      S:  a  g U S   R                  $ )NÈ   r"  )r  r(  r5   s    r   r(  ⁄AddrSpec.domain  s   Ä ‰àtã9êqã=ÿÿêBâxèâ–r   c                 Û‘   ï [        U 5      S:  a  U S   R                  $ U S   R                  R                  5       U S   R                  -   U S   R                  R                  5       -   $ )Nrm  r   r  r  )r  r   ⁄rstrip⁄lstripr5   s    r   r   ⁄AddrSpec.value  sU   Ä ‰àtã9êqã=ÿòë7ó=ë=– ÿêAâwè}â}◊#—#”%†d®1°gßm°m—3∞D∏±G∑M±M◊4H—4H”4J—J–Jr   c                 Û   ï [        U R                  5      n[        U5      [        U[        -
  5      :î  a  [	        U R                  5      nOU R                  nU R
                  b  US-   U R
                  -   $ U$ )N⁄@)⁄setr$  r  ⁄DOT_ATOM_ENDSr   r(  )r#   ⁄nameset⁄lps      r   r/  ⁄AddrSpec.addr_spec$  s_   Ä ‰êdóoëo”&à‹àwã<ú#òg§m—3”4”4‹òdüoôo”.âB‡óëàBÿè;â;—"ÿòë8òdükôk—)–)ÿà	r   rÅ   N)r<   rr   rs   rt   rm   rP   rw   r$  r(  r   r/  rx   rÅ   r   r   ri  ri    s\   Ü ‡ÄJÿÄM‡Ò"Û " ÒÛ 
 ÒKÛ K
 ÒÛ Ûr   ri  c                   Û   ï \ rS rSrSrSrSrg)⁄ObsLocalParti0  zobs-local-partFrÅ   Nre  rÅ   r   r   r{  r{  0  s   Ü ‡!ÄJÿÉMr   r{  c                   ÛJ   ^ ï \ rS rSrSrSr\S 5       r\U 4S j5       rSr	U =r
$ )⁄DisplayNamei6  zdisplay-nameFc                 Û  ï [        U 5      n[        U5      S:X  a  UR                  $ US   R                  S:X  a  UR	                  S5        OB[        US   [         5      (       a*  US   S   R                  S:X  a  [        US   SS  5      US'   US   R                  S:X  a  UR	                  5         UR                  $ [        US   [         5      (       a*  US   S   R                  S:X  a  [        US   S S 5      US'   UR                  $ )Nr   rú   r  r"  )r   r  r   rm   ⁄pop⁄
isinstance)r#   r∑   s     r   rı   ⁄DisplayName.display_name;  sÓ   Ä ‰òãoà‹àsã8êqã=ÿó9ë9–ÿàqâ6◊—†”&ÿèGâGêAçJ‰ò3òqô6§9◊-—-ÿòëFò1ëI◊(—(®F”2‹"†3†q°6®!®"†:”.êêAëÿàrâ7◊—†”'ÿèGâGåI
 èyây–Ù ò3òrô7§I◊.—.ÿòëGòBëK◊*—*®f”4‹#†C®°G®C®R†L”1êêBëÿèyây–r   c                 ÛÚ  >ï SnU R                   (       a  SnOU  H  nUR                  S:X  d  M  SnM     [        U 5      S:w  a´  U(       a§  S=p4U S   R                  S:X  d.  [        U S   [        5      (       a  U S   S   R                  S:X  a  SnU S   R                  S:X  d.  [        U S   [        5      (       a  U S   S   R                  S:X  a  SnU[        U R                  5      -   U-   $ [        TU ]   $ )	NFTrØ   r   r)   rú   rÄ   r"  )	r"   rm   r  rÄ  r   r   rı   r    r   )r#   rÕ   r.   ⁄pre⁄postr&   s        Är   r   ⁄DisplayName.valueN  sÊ   ¯Ä ‡àÿè<è<ÿâE„êÿó<ë<†?’2ÿ íEÒ Ù àtã9òã>ûeÿàOàCÿêQë◊"—"†f”,‹ò4†ô7§I◊.—.ÿêQëòë
◊%—%®”/ÿêÿêRë◊#—#†v”-‹ò4†ô8§Y◊/—/ÿêRëòë◊'—'®6”1ÿêÿî|†D◊$5—$5”6—6∞t—;–;‰ë7ë=– r   rÅ   )r<   rr   rs   rt   rm   rv   rw   rı   r   rx   ry   rz   s   @r   r}  r}  6  s4   ¯Ü ‡ÄJÿ–‡ÒÛ $ Ù!Û ˆ!r   r}  c                   Û<   ï \ rS rSrSrSr\S 5       r\S 5       rSr	g)⁄	LocalPartif  z
local-partFc                 Ûd   ï U S   R                   S:X  a  U S   R                  $ U S   R                  $ )Nr   rØ   )rm   r∏   r   r5   s    r   r   ⁄LocalPart.valuek  s2   Ä ‡êâ7◊—†”0ÿòë7◊'—'–'‡òë7ó=ë=– r   c                 Ûˆ  ï [         /n[         nSnU S   [         /-    H¿  nUR                  S:X  a  M  U(       a4  UR                  S:X  a$  US   R                  S:X  a  [        US S 5      US'   [        U[        5      nU(       aA  UR                  S:X  a1  US   R                  S:X  a  UR	                  [        USS  5      5        OUR	                  U5        US   nUnM¬     [        USS 5      nUR
                  $ )NFr   rú   ⁄dotr"  r  )⁄DOTrm   r   rÄ  r∂   r   )r#   r∑   ⁄last⁄
last_is_tl⁄tok⁄is_tls         r   r$  ⁄LocalPart.local_partr  s‰   Ä Ù àeà‹àÿà
ÿòë7úcòUî?àCÿè~â~†”'Ÿﬁòsü~ô~∞”6ÿòëH◊'—'®6”1‹#†D®®"†I”.êêBë‹òs§I”.àEﬁò$ü/ô/®U”2ÿòëF◊%—%®”/ÿó
ë
ú9†S®®†W”-’.‡ó
ë
ò3îÿêrë7àDÿäJÒ #Ù òòAòbò	”"àÿèyây–r   rÅ   N)
r<   rr   rs   rt   rm   rP   rw   r   r$  rx   rÅ   r   r   rá  rá  f  s2   Ü ‡ÄJÿÄM‡Ò!Û ! ÒÛ Ûr   rá  c                   ÛJ   ^ ï \ rS rSrSrSr\U 4S j5       r\S 5       rSr	U =r
$ )⁄DomainLiteraliä  zdomain-literalFc                 ÛR   >ï SR                  [        TU ]  R                  5       5      $ r[  r\  r>   s    Är   r(  ⁄DomainLiteral.domainè  r_  r   c                 ÛR   ï U  H!  nUR                   S:X  d  M  UR                  s  $    g )N⁄ptextr≥   rá   s     r   ⁄ip⁄DomainLiteral.ipì  s!   Ä „àAÿè|â|òw’&ÿówëwíÚ r   rÅ   )r<   rr   rs   rt   rm   rP   rw   r(  rò  rx   ry   rz   s   @r   rì  rì  ä  s3   ¯Ü ‡!ÄJÿÄM‡Ù.Û . ÒÛ ˆr   rì  c                   Û    ï \ rS rSrSrSrSrSrg)⁄MIMEVersioniö  zmime-versionNrÅ   )r<   rr   rs   rt   rm   ⁄major⁄minorrx   rÅ   r   r   rõ  rõ  ö  s   Ü ‡ÄJÿÄEÿÉEr   rõ  c                   ÛD   ï \ rS rSrSrSrSrSr\S 5       r	\S 5       r
Srg)	⁄	Parameteri°  ⁄	parameterF˙us-asciic                 ÛF   ï U R                   (       a  U S   R                  $ S$ r  )⁄	sectioned⁄numberr5   s    r   ⁄section_number⁄Parameter.section_number®  s   Ä  "&ßßàtêAâwè~â~–6∞Q–6r   c                 Û  ï U  Hy  nUR                   S:X  a  UR                  s  $ UR                   S:X  d  M3  U H@  nUR                   S:X  d  M  U H%  nUR                   S:X  d  M  UR                  s  s  s  $    MB     M{     g)Nr   rØ   r≤   r)   )rm   rº   rª   s     r   ⁄param_value⁄Parameter.param_valueÆ  sx   Ä Û àEÿ◊—†7”*ÿ◊+—+“+ÿ◊—†?’2€"êEÿ◊'—'–+?’?€%*òEÿ$◊/—/∞7’:ÿ',◊';—';÷ ;Û &+Û #Ò	  r   rÅ   N)r<   rr   rs   rt   rm   r£  ⁄extendedr™   rw   r•  r®  rx   rÅ   r   r   rü  rü  °  s<   Ü ‡ÄJÿÄIÿÄHÿÄG‡Ò7Û 7
 ÒÛ Ûr   rü  c                   Û   ï \ rS rSrSrSrg)⁄InvalidParameteriΩ  ˙invalid-parameterrÅ   Nré   rÅ   r   r   r¨  r¨  Ω  s   Ü ‡$ÉJr   r¨  c                   Û(   ï \ rS rSrSr\S 5       rSrg)⁄	Attributei¬  ⁄	attributec                 Ûr   ï U  H1  nUR                   R                  S5      (       d  M%  UR                  s  $    g )N⁄attrtext)rm   ⁄endswithr   rª   s     r   rº   ⁄Attribute.stripped_value∆  s-   Ä „àEÿ◊—◊(—(®◊4”4ÿó{ë{“"Ú r   rÅ   N©r<   rr   rs   rt   rm   rw   rº   rx   rÅ   r   r   rØ  rØ  ¬  s   Ü ‡ÄJ‡Ò#Û Û#r   rØ  c                   Û   ï \ rS rSrSrSrSrg)⁄SectioniÃ  ⁄sectionNrÅ   )r<   rr   rs   rt   rm   r§  rx   rÅ   r   r   r∑  r∑  Ã  s   Ü ‡ÄJÿÉFr   r∑  c                   Û(   ï \ rS rSrSr\S 5       rSrg)⁄Valuei“  r   c                 Û¶   ï U S   nUR                   S:X  a  U S   nUR                   R                  S5      (       a  UR                  $ U R                  $ )Nr   rú   r  )rØ   r∞  zextended-attribute)rm   r≥  rº   r   rª   s     r   rº   ⁄Value.stripped_value÷  sV   Ä ‡êQëàÿ◊—òv”%ÿòëGàEÿ◊—◊$—$ÿD˜FÒ F‡◊'—'–'ÿèzâz–r   rÅ   Nrµ  rÅ   r   r   r∫  r∫  “  s   Ü ‡ÄJ‡ÒÛ Ûr   r∫  c                   Û2   ï \ rS rSrSrSr\S 5       rS rSr	g)⁄MimeParametersi·  ˙mime-parametersFc              #   ÛÆ  #   ï 0 nU  H  nUR                   R                  S5      (       d  M%  US   R                   S:w  a  M:  US   R                  R                  5       nX1;  a  / X'   X   R	                  UR
                  U45        MÅ     UR                  5        GHﬂ  u  p4[        U[        S5      S9nUS   S   nUR                  nUR                  (       dU  [        U5      S:î  aF  US   S   S:X  a:  US   S   R                  R	                  [        R                  " S5      5        US S n/ nSnU GH+  u  pöXò:w  aq  U
R                  (       d1  U
R                  R	                  [        R                  " S5      5        MM  U
R                  R	                  [        R                  " S5      5        US-  nU
R                  nU
R                  (       a|   [         R"                  R%                  U5      n UR'                  US	5      n[,        R.                  " U5      (       a.  U
R                  R	                  [        R0                  " 5       5        UR	                  U5        GM.     SR5                  U5      nX;4v ï  GM‚     g ! [(        [*        4 a    UR'                  S
S	5      n Nüf = f! [*         a!    [         R"                  R3                  USS9n NÑf = f7f)Nr†  r   r∞  )⁄keyr  z.duplicate parameter name; duplicate(s) ignoredz+duplicate parameter name; duplicate ignoredz(inconsistent RFC2231 parameter numbering⁄surrogateescaper°  zlatin-1)⁄encodingr)   )rm   r≥  r   ⁄stripr∂   r•  ⁄items⁄sortedr   r™   r™  r  r"   r   ⁄InvalidHeaderDefectr®  ⁄urllib⁄parse⁄unquote_to_bytes⁄decode⁄LookupError⁄UnicodeEncodeErrorr   ⁄_has_surrogates⁄UndecodableBytesDefect⁄unquoter4   )r#   ⁄paramsrX   ⁄name⁄parts⁄first_paramr™   ⁄value_parts⁄ir•  ⁄paramr   s               r   r—  ⁄MimeParameters.paramsÊ  så  È Ä  à€àEÿ◊#—#◊,—,®[◊9—9ŸÿêQâx◊"—"†k”1Ÿÿòë8ó>ë>◊'—'”)àDÿ”!ÿ!êëÿâL◊—†◊!5—!5∞u– =÷>Ò  "ü<ô<ü>âKàD‹ò5§j∞£m—4àEÿ†ô(†1ô+àKÿ!◊)—)àG ◊'◊'¨C∞´J∏´Nÿòë8òAë;†!”#ÿò!ëHòQëK◊'—'◊.—.¨v◊/I“/IÿHÛ0JÙ K‡!†"†1òIêE àKÿàA‹).—%êÿ!”& !ü>ü>ÿüô◊,—,¨V◊-G“-GÿIÛ.KÙ L· ‡üô◊,—,¨V◊-G“-GÿFÛ.HÙ I‡êQëêÿ◊)—)êÿó>ó>R‹ &ß°◊ =— =∏e” DòPÿ$)ßL°L∞–:K”$LòEÙ !◊0“0∞◊7—7ÿ!üMôM◊0—0¥◊1N“1N”1P‘Qÿ◊"—"†5◊)ÒC */D óGëGòK”(àEÿê+’Úg *¯ÙR !,‘-?–@Û P
 %*ßL°L∞–=N”$OöEP˚Ù .Û PÙ !'ß°◊ 4— 4∞U¿Y– 4– Oö	P¸sI   ÇGK«J'«2I?»A;K…?"J$ !K #J$ $K '(KÀKÀKÀKc           	      Ûˆ   ï / nU R                    HI  u  p#U(       a,  UR                  SR                  U[        U5      5      5        M8  UR                  U5        MK     SR	                  U5      nU(       a  SU-   $ S$ )N˙{}={}z; rÄ   r)   )r—  r∂   r;   r   r4   )r#   r—  r“  r   s       r   r6   ⁄MimeParameters.__str__,  sc   Ä ÿàÿü;ú;âKàDﬁÿóëògünôn®T¥<¿”3F”G÷H‡óëòd÷#Ò	 '
 óëò6”"àﬁ%àsêVâ|–-®2–-r   rÅ   N)
r<   rr   rs   rt   rm   ru   rw   r—  r6   rx   rÅ   r   r   ræ  ræ  ·  s&   Ü ‡"ÄJÿÄO‡ÒCÛ CıJ.r   ræ  c                   Û(   ï \ rS rSrSr\S 5       rSrg)⁄ParameterizedHeaderValuei7  Fc                 Ûf   ï [        U 5       H!  nUR                  S:X  d  M  UR                  s  $    0 $ )Nrø  )⁄reversedrm   r—  rª   s     r   r—  ⁄ParameterizedHeaderValue.params=  s0   Ä ‰òdñ^àEÿ◊—–#4’4ÿó|ë|“#Ò $ à	r   rÅ   N)r<   rr   rs   rt   ru   rw   r—  rx   rÅ   r   r   r›  r›  7  s   Ü  ÄO‡ÒÛ Ûr   r›  c                   Û$   ï \ rS rSrSrSrSrSrSrg)⁄ContentTypeiE  zcontent-typeF⁄text⁄plainrÅ   N)	r<   rr   rs   rt   rm   rP   ⁄maintype⁄subtyperx   rÅ   r   r   r‚  r‚  E  s   Ü ÿÄJÿÄMÿÄHÿÉGr   r‚  c                   Û    ï \ rS rSrSrSrSrSrg)⁄ContentDispositioniL  zcontent-dispositionFNrÅ   )r<   rr   rs   rt   rm   rP   ⁄content_dispositionrx   rÅ   r   r   rË  rË  L  s   Ü ÿ&ÄJÿÄMÿ”r   rË  c                   Û    ï \ rS rSrSrSrSrSrg)⁄ContentTransferEncodingiR  zcontent-transfer-encodingF⁄7bitrÅ   N)r<   rr   rs   rt   rm   rP   r©   rx   rÅ   r   r   rÎ  rÎ  R  s   Ü ÿ,ÄJÿÄMÿ
ÉCr   rÎ  c                   Û   ï \ rS rSrSrSrSrg)⁄HeaderLabeliX  zheader-labelFrÅ   Nre  rÅ   r   r   rÓ  rÓ  X  s   Ü ÿÄJÿÉMr   rÓ  c                   Û"   ï \ rS rSrSrSrS rSrg)⁄MsgIDi]  zmsg-idFc                 Û2   ï [        U 5      UR                  -   $ r   )r   ⁄linesepr^   s     r   r_   ⁄
MsgID.folda  s   Ä ‰ê4ãyò6ü>ô>—)–)r   rÅ   N)r<   rr   rs   rt   rm   rP   r_   rx   rÅ   r   r   r  r  ]  s   Ü ÿÄJÿÄMı*r   r  c                   Û   ï \ rS rSrSrSrg)⁄	MessageIDif  z
message-idrÅ   Nré   rÅ   r   r   rı  rı  f  s   Ü ÿÉJr   rı  c                   Û   ï \ rS rSrSrSrg)⁄InvalidMessageIDij  zinvalid-message-idrÅ   Nré   rÅ   r   r   r˜  r˜  j  s   Ü ÿ%ÉJr   r˜  c                   Û   ï \ rS rSrSrSrg)⁄Headerin  ⁄headerrÅ   Nré   rÅ   r   r   r˘  r˘  n  rì   r   r˘  c                   ÛÇ   ^ ï \ rS rSrSrSrSrU 4S jrU 4S jrS r	\
S 5       rSU 4S jjrS r\
S	 5       rS
 rSrU =r$ )⁄Terminaliv  Tc                 Û@   >ï [         TU ]  X5      nX#l        / Ul        U$ r   )r    ⁄__new__rm   r"   )⁄clsr   rm   r#   r&   s       Är   r˛  ⁄Terminal.__new__|  s"   ¯Ä ‹âwâòs”*àÿ$åÿàåÿàr   c                 Ûh   >ï SR                  U R                  R                  [        TU ]  5       5      $ r9   r:   r>   s    Är   r=   ⁄Terminal.__repr__Ç  s&   ¯Ä ÿèâòtü~ô~◊6—6ºπ—8H”8J”K–Kr   c                 Ûb   ï [        U R                  R                  S-   U R                  -   5        g )N⁄/)rd   r&   r<   rm   r5   s    r   rg   ⁄Terminal.pprintÖ  s"   Ä ‹àdènân◊%—%®—+®dØo©o—=’>r   c                 Û,   ï [        U R                  5      $ r   )⁄listr"   r5   s    r   rF   ⁄Terminal.all_defectsà  s   Ä ‰êDóLëL”!–!r   c           	      ÛÊ   >ï SR                  UU R                  R                  U R                  [        TU ]  5       U R                  (       d  S5      /$ SR                  U R                  5      5      /$ )Nz{}{}/{}({}){}r)   z {})r;   r&   r<   rm   r    r=   r"   )r#   rc   r&   s     Är   rj   ⁄Terminal._ppå  sg   ¯Ä ÿ◊&—&ÿÿèNâN◊#—#ÿèOâO‹âG—”ÿólólàBÛ  	
 ).Ø©∞T∑\±\”(BÛ  	r   c                 Û   ï g r   rÅ   r5   s    r   ⁄pop_trailing_ws⁄Terminal.pop_trailing_wsï  rW  r   c                 Û   ï / $ r   rÅ   r5   s    r   rW   ⁄Terminal.commentsô  s   Ä ‡à	r   c                 Û0   ï [        U 5      U R                  4$ r   )r   rm   r5   s    r   ⁄__getnewargs__⁄Terminal.__getnewargs__ù  s   Ä ‹ê4ãyò$ü/ô/–*–*r   )r"   rm   rq   )r<   rr   rs   rt   rP   rv   ru   r˛  r=   rg   rw   rF   rj   r  rW   r  rx   ry   rz   s   @r   r¸  r¸  v  s_   ¯Ü ‡ÄMÿ–ÿÄOııLÚ? Ò"Û "˜Ú ÒÛ ˜+ +r   r¸  c                   Û*   ï \ rS rSr\S 5       rS rSrg)⁄WhiteSpaceTerminali°  c                 Û   ï gr   rÅ   r5   s    r   r   ⁄WhiteSpaceTerminal.value£  rÉ   r   c                 Û   ï g)NTrÅ   r5   s    r   rL   ⁄!WhiteSpaceTerminal.startswith_fwsß  s   Ä ÿr   rÅ   N©r<   rr   rs   rt   rw   r   rL   rx   rÅ   r   r   r  r  °  s   Ü ‡ÒÛ ır   r  c                   Û*   ï \ rS rSr\S 5       rS rSrg)⁄ValueTerminali´  c                 Û   ï U $ r   rÅ   r5   s    r   r   ⁄ValueTerminal.value≠  s   Ä ‡àr   c                 Û   ï g)NFrÅ   r5   s    r   rL   ⁄ValueTerminal.startswith_fws±  s   Ä ÿr   rÅ   Nr  rÅ   r   r   r  r  ´  s   Ü ‡ÒÛ ır   r  c                   Û*   ï \ rS rSr\S 5       rS rSrg)⁄EWWhiteSpaceTerminaliµ  c                 Û   ï gr[  rÅ   r5   s    r   r   ⁄EWWhiteSpaceTerminal.value∑  s   Ä ‡r   c                 Û   ï gr[  rÅ   r5   s    r   r6   ⁄EWWhiteSpaceTerminal.__str__ª  s   Ä ÿr   rÅ   N)r<   rr   rs   rt   rw   r   r6   rx   rÅ   r   r   r!  r!  µ  s   Ü ‡ÒÛ ır   r!  c                   Û   ï \ rS rSrSrSrg)⁄_InvalidEwErroriø  z1Invalid encoded word found while parsing headers.rÅ   N)r<   rr   rs   rt   ⁄__doc__rx   rÅ   r   r   r'  r'  ø  s   Ü ‹;r   r'  rã  ⁄,zlist-separatorFrt  zroute-component-markerz([{}]+)r)   z[^{}]+z[\x00-\x20\x7F]c                 Û  ï [        U 5      nU(       a/  U R                  R                  [        R                  " U5      5        [
        R                  " U 5      (       a0  U R                  R                  [        R                  " S5      5        gg)z@If input token contains ASCII non-printables, register a defect.z*Non-ASCII characters found in header tokenN)⁄_non_printable_finderr"   r∂   r   ⁄NonPrintableDefectr   rŒ  rœ  )⁄xtext⁄non_printabless     r   ⁄_validate_xtextr/  Ï  sf   Ä Ù +®5”1ÄNﬁÿèâ◊—úV◊6“6∞~”F‘G‹◊“òU◊#—#ÿèâ◊—úV◊:“:ÿ8Û:ı 	; $r   c                 ÛH  ï U (       d  g[        U S5      tp#/ nSnSn[        [        U5      5       HB  nX'   S:X  a  U(       a  SnSnOSnM  U(       a  SnO
X'   U;   a    OUR                  X'   5        MD     WS-   nSR	                  U5      SR	                  X'S /U-   5      U4$ )aW  Scan printables/quoted-pairs until endchars and return unquoted ptext.

This function turns a run of qcontent, ccontent-without-comments, or
dtext-with-quoted-printables into a single string by unquoting any
quoted printables.  It returns the string, the remaining value, and
a flag that is True iff there were any quoted printables decoded.

)r)   r)   Fr  Fr   Tr)   N)⁄_wsp_splitter⁄ranger  r∂   r4   )r   ⁄endchars⁄fragment⁄	remainder⁄vchars⁄escape⁄had_qp⁄poss           r   ⁄_get_ptext_to_endcharsr:  ˆ  s≤   Ä ˆ ÿ‹(®∞”2–ÄHÿÄFÿÄFÿÄF‹îSòì]÷#àÿâ=òD” ﬁÿêÿë‡êŸﬁÿâFÿâ]òh”&Ÿÿèâêhëm÷$Ò $ êAâgàÿè7â7ê6ã?òBüGôG†X®d†^–$4∞y—$@”A¿6–I–Ir   c                 Ûp   ï U R                  5       n[        U S[        U 5      [        U5      -
   S5      nX!4$ )z”FWS = 1*WSP

This isn't the RFC definition.  We're using fws to represent tokens where
folding can be done, but when we are parsing the *un*folding has already
been done so we don't need to watch out for CRLF.

N⁄fws)rq  r  r  )r   ⁄newvaluer<  s      r   ⁄get_fwsr>    s8   Ä  è|â|ã~ÄH‹
òU–#<§C®£J¨s∞8´}—$<–=∏u”
EÄCÿà=–r   c                 Û:  ï [        5       nU R                  S5      (       d%  [        R                  " SR	                  U 5      5      eU SS R                  SS5      tp4X0SS :X  a%  [        R                  " SR	                  U 5      5      eSR                  U5      n[        U5      S:î  aJ  US   [        ;   a=  US   [        ;   a0  UR                  S	5      S:  a  UR                  SS5      tpdUS-   U-   n[        UR                  5       5      S:î  a/  UR                  R                  [        R                  " S
5      5        Xl        SR                  U5      n  [        R                  " SU-   S-   5      u  pxpöXÇl        Xíl        UR                  R+                  U
5        U(       a{  US   [,        ;   a   [/        U5      u  p∑UR                  U5        M4  [1        US5      tpƒ[3        X¡5      n[5        U5        UR                  U5        SR                  U5      nU(       a  M{  U (       a<  U S   [,        ;  a/  UR                  R         |ç  }ç  ~ç  ç  Äç  Åç  Çç  Éç  Ñç  Öç  Üç  áç  àç  âç  äç  ãç  åç  çç  éç  èç  êç  ëç                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   [        R                  " S5      5        X 4$ ! [         ["        4 a%    [%        SR	                  UR                  5      5      ef = f)zDencoded-word = "=?" charset "?" encoding "?" encoded-text "?="

    ˙=?z"expected encoded word but found {}r  Nz?=r  r)   r   ⁄?zwhitespace inside encoded wordz!encoded word format invalid: '{}'z.missing trailing whitespace after encoded-word)r¶   ⁄
startswithr   ⁄HeaderParseErrorr;   r]  r4   r  r   ⁄countr"   r∂   r«  r©   ⁄_ewrÀ  ⁄
ValueError⁄KeyErrorr'  r™   r´   rV   ⁄WSPr>  r1  r  r/  )r   ⁄terminal_type⁄ewrè  r5  ⁄remstr⁄restr„  r™   r´   r"   rX   ⁄chars⁄vtexts                 r   ⁄get_encoded_wordrO  "  sM  Ä Ù 
ãÄBÿ◊—òD◊!—!‹◊%“%ÿ0◊7—7∏”>Û@ 	@‡òAòBêióoëo†d®A”.ÄOÄCÿ
êAêBài”‹◊%“%ÿ0◊7—7∏”>Û@ 	@‡èWâWêY”ÄF‹àFãêaãÿàqâ	îY”ÿàqâ	îY”ÿè	â	ê#ãò”‡!ü<ô<®®a”0–àÿêDâjò4—à‹
à3è9â9ã;”ò!”ÿ
è
â
◊—ú&◊4“4ÿ,Û.Ù 	/‡ÑFÿèGâGêI”ÄE@‹'*ßz¢z∞$∏±*∏t—2C”'D—$àêt ÑJÿÑGÿáJÅJ◊—êg‘ﬁ
ÿêâ7îcã>‹!†$õ-âKàEÿèIâIêe‘Ÿ‹)®$∞”2–à‹òe”3à‹ò‘ÿ
è	â	ê%‘ÿèwâwêy”!à˜ à$ˆ êêqë§”$ÿ
è
â
◊—ú&◊4“4ÿ<Û>Ù 	?‡à9–¯Ù) ú–!Û @‹ÿ/◊6—6∞r∑v±v”>Û@ 	@@˙s   ≈I% …%5Jc                 Ûl  ï [        5       nU (       Gaz  U S   [        ;   a   [        U 5      u  p UR                  U5        M5  SnU R	                  S5      (       a≤   [        U S5      u  p Sn[        U5      S:î  aD  US   R                  S:w  a1  UR                  R                  [        R                  " S5      5        SnU(       a4  [        U5      S	:î  a%  US
   R                  S:X  a  [        US   S5      US'   UR                  U5        Mˇ  [        U S	5      tpVU(       a,  [        R!                  U5      (       a  U R#                  S5      tpV[%        US5      n['        U5        UR                  U5        SR)                  U5      n U (       a  GMz  U$ ! [         a    Sn Nì[        R                   a     N®f = f)a  unstructured = (*([FWS] vchar) *WSP) / obs-unstruct
   obs-unstruct = *((*LF *CR *(obs-utext) *LF *CR)) / FWS)
   obs-utext = %d0 / obs-NO-WS-CTL / LF / CR

   obs-NO-WS-CTL is control characters except WSP/CR/LF.

So, basically, we have printable runs, plus control characters or nulls in
the obsolete syntax, separated by whitespace.  Since RFC 2047 uses the
obsolete syntax in its specification, but requires whitespace on either
side of the encoded words, I can see no reason to need to separate the
non-printable-non-whitespace from the printable runs if they occur, so we
parse this into xtext tokens separated by WSP tokens.

Because an 'unstructured' value must by definition constitute the entire
value, this 'get' routine does not return a remaining value, only the
parsed TokenList.

r   Tr@  ⁄utextr"  r<  z&missing whitespace before encoded wordFr  È˛ˇˇˇr®   r)   )rã   rH  r>  r∂   rB  rO  r  rm   r"   r   r«  r!  r'  rC  r1  ⁄rfc2047_matcher⁄search⁄	partitionr  r/  r4   )r   rç   rX   ⁄valid_ew⁄have_wsrè  r5  rN  s           r   ⁄get_unstructuredrX  S  sõ  Ä Ù. )”*ÄLﬂ
ÿêâ8îsã?‹"†5õ>âLàEÿ◊—†‘&Ÿÿàÿ◊—òD◊!—!‹/∞∞w”?ëê ê‹ê|”$†q”(ÿ#†B—'◊2—2∞e”;ÿ$◊,—,◊3—3¥F◊4N“4NÿDÛ5FÙ G‡"'òﬁús†<”0∞1”4ÿ#†B—'◊2—2∞n”D‹+?ÿ(®—,®eÛ,5ò†R—(‡◊#—#†E‘*Ÿ‹'®®q”1ààˆ ú◊.—.®s◊3—3ÿ#üoôo®d”3àOàC‹òc†7”+à‹ò‘ÿ◊—òE‘"ÿóëò	”"à˜Q â%R –¯ÙA #Û !ÿ í‹◊*—*Û Ò ˙s   ¡F ∆F3∆F3∆2F3c                 ÛT   ï [        U S5      u  pn[        US5      n[        U5        X4$ )aÊ  ctext = <printable ascii except \ ( )>

This is not the RFC ctext, since we are handling nested comments in comment
and unquoting quoted-pairs here.  We allow anything except the '()'
characters, but if we find any ASCII other than the RFC defined printable
ASCII, a NonPrintableDefect is added to the token's defects list.  Since
quoted pairs are converted to their unquoted values, what is returned is
a 'ptext' token.  In this case it is a WhiteSpaceTerminal, so it's value
is ' '.

z()ró  )r:  r  r/  ©r   ró  ⁄_s      r   ⁄get_qp_ctextr\  ñ  s0   Ä Ù -®U∞D”9ÅOÄEê!‹òu†g”.ÄE‹êE‘ÿà<–r   c                 ÛT   ï [        U S5      u  pn[        US5      n[        U5        X4$ )aW  qcontent = qtext / quoted-pair

We allow anything except the DQUOTE character, but if we find any ASCII
other than the RFC defined printable ASCII, a NonPrintableDefect is
added to the token's defects list.  Any quoted pairs are converted to their
unquoted values, so what is returned is a 'ptext' token.  In this case it
is a ValueTerminal.

r   ró  )r:  r  r/  rZ  s      r   ⁄get_qcontentr^  ß  s0   Ä Ù -®U∞C”8ÅOÄEê!‹ò%†”)ÄE‹êE‘ÿà<–r   c                 Û‡   ï [        U 5      nU(       d%  [        R                  " SR                  U 5      5      eUR	                  5       nU [        U5      S n [        US5      n[        U5        X 4$ )z¢atext = <matches _atext_matcher>

We allow any non-ATOM_ENDS in atext, but add an InvalidATextDefect to
the token's defects list if we find non-atext characters.
zexpected atext but found '{}'N⁄atext)⁄_non_atom_end_matcherr   rC  r;   rÛ   r  r  r/  )r   ⁄mr`  s      r   ⁄	get_atextrc  ∂  si   Ä Ù 	òe”$ÄAﬁ‹◊%“%ÿ+◊2—2∞5”9Û; 	;‡èGâGãIÄEÿî#êeì*ê+–ÄE‹ò%†”)ÄE‹êE‘ÿà<–r   c                 Ûö  ï U (       a	  U S   S:w  a%  [         R                  " SR                  U 5      5      e[        5       nU SS n U (       a'  U S   S:X  a  [	        U 5      u  p UR                  U5        U (       aÌ  U S   S:w  a‰  U S   [        ;   a  [        U 5      u  p O¶U SS S:X  aê  Sn [        U 5      u  p UR                  R                  [         R                  " S	5      5        S
nU(       aG  [        U5      S:î  a8  US   R                  S:X  a%  US   R                  S:X  a  [        US   S5      US'   O[	        U 5      u  p UR                  U5        U (       a  U S   S:w  a  M‰  U (       d2  UR                  R                  [         R                  " S5      5        X4$ XSS 4$ ! [         R                   a    [	        U 5      u  p  N·f = f)z›bare-quoted-string = DQUOTE *([FWS] qcontent) [FWS] DQUOTE

A quoted-string without the leading or trailing white space.  Its
value is the text between the quote marks, with whitespace
preserved and quoted pairs decoded.
r   r   zexpected '"' but found '{}'r  Nr  r@  Fz!encoded word inside quoted stringTr"  r<  rR  r®   z"end of header inside quoted string)r   rC  r;   rø   r^  r∂   rH  r>  rO  r"   r«  r  rm   r!  )r   ⁄bare_quoted_stringrX   rV  s       r   ⁄get_bare_quoted_stringrf  ∆  s√  Ä ˆ êEò!ëH†ìO‹◊%“%ÿ*◊1—1∞%”8Û: 	:‰)”+–ÿê!ê"àIÄEﬁêêqëòSì‹#†E”*âàÿ◊!—!†%‘(ﬁ
êEò!ëH†ìOÿêâ8îsã?‹"†5õ>âLàEê5ÿê2êAàYò$”ÿàH3‹/∞”6ëêÿ"◊*—*◊1—1¥&◊2L“2Lÿ7Û39Ù :‡êˆ
 úC– 2”3∞a”7ÿ&†r—*◊5—5∏”>ÿ*®2—.◊9—9∏^”K‹-Aÿ*®2—.∞Û.7–&†r—*¯Ù (®”.âLàEÿ◊!—!†%‘(ˆ+ êEò!ëH†ïOˆ, ÿ◊"—"◊)—)¨&◊*D“*Dÿ0Û+2Ù 	3‡!–(–(ÿ†Q†Ròy–(–(¯Ù! ◊*—*Û 3‹+®E”2ëêëu3˙s   ¬*>F& ∆&!G
«	G
c                 ÛÏ  ï U (       a.  U S   S:w  a%  [         R                  " SR                  U 5      5      e[        5       nU SS n U (       ak  U S   S:w  ab  U S   [        ;   a  [        U 5      u  p O$U S   S:X  a  [        U 5      u  p O[        U 5      u  p UR                  U5        U (       a  U S   S:w  a  Mb  U (       d2  UR                  R                  [         R                  " S5      5        X4$ XSS 4$ )z†comment = "(" *([FWS] ccontent) [FWS] ")"
   ccontent = ctext / quoted-pair / comment

We handle nested comments here, and quoted-pair in our qp-ctext routine.
r   r   zexpected '(' but found '{}'r  NrÃ   zend of header inside comment)r   rC  r;   r    rH  r>  ⁄get_commentr\  r∂   r"   r«  )r   rÖ   rX   s      r   rh  rh  Ò  sÁ   Ä ˆ êêqëòSì‹◊%“%ÿ)◊0—0∞”7Û9 	9‰ãiÄGÿê!ê"àIÄEﬁ
êEò!ëH†ìOÿêâ8îsã?‹"†5õ>âLàEê5ÿê1âXòã_‹&†u”-âLàEê5‰'®”.âLàEÿèâêu‘ˆ êEò!ëH†ïOˆ ÿèâ◊—úv◊9“9ÿ*Û ,Ù 	-‡à~–ÿò!ò"êI––r   c                 Û‚   ï [        5       nU (       a\  U S   [        ;   aO  U S   [        ;   a  [        U 5      u  p O[	        U 5      u  p UR                  U5        U (       a  U S   [        ;   a  MO  X4$ )z,CFWS = (1*([FWS] comment) [FWS]) / FWS

    r   )rö   ⁄CFWS_LEADERrH  r>  rh  r∂   )r   rú   rX   s      r   ⁄get_cfwsrk  
  sc   Ä Ù ã:ÄDﬁ
êEò!ëH§”+ÿêâ8îsã?‹"†5õ>âLàEê5‰&†u”-âLàEÿèâêE‘ˆ êEò!ëH§’+ à;–r   c                 Û   ï [        5       nU (       a+  U S   [        ;   a  [        U 5      u  p UR                  U5        [	        U 5      u  p UR                  U5        U (       a+  U S   [        ;   a  [        U 5      u  p UR                  U5        X4$ )z…quoted-string = [CFWS] <bare-quoted-string> [CFWS]

'bare-quoted-string' is an intermediate class defined by this
parser and not by the RFC grammar.  It is the quoted string
without any attached CFWS.
r   )r≠   rj  rk  r∂   rf  )r   ⁄quoted_stringrX   s      r   ⁄get_quoted_stringrn    s|   Ä Ù !ìNÄMﬁêêqëú[”(‹†ìâàÿ◊—òU‘#‹)®%”0ÅLÄEÿ◊—ò‘ﬁêêqëú[”(‹†ìâàÿ◊—òU‘#ÿ––r   c                 Û*  ï [        5       nU (       a+  U S   [        ;   a  [        U 5      u  p UR                  U5        U (       a2  U S   [        ;   a%  [
        R                  " SR                  U 5      5      eU R                  S5      (       a   [        U 5      u  p O[        U 5      u  p UR                  U5        U (       a+  U S   [        ;   a  [        U 5      u  p UR                  U5        X4$ ! [
        R                   a    [        U 5      u  p  Nif = f)zHatom = [CFWS] 1*atext [CFWS]

An atom could be an rfc2047 encoded word.
r   zexpected atom but found '{}'r@  )rû   rj  rk  r∂   ⁄	ATOM_ENDSr   rC  r;   rB  rO  rc  )r   r†   rX   s      r   ⁄get_atomrq  )  sÒ   Ä Ù
 ã6ÄDﬁêêqëú[”(‹†ìâàÿèâêE‘ﬁêêqëúY”&‹◊%“%ÿ*◊1—1∞%”8Û: 	:‡◊—ò◊—	,‹+®E”2âLàEê5Ù !†”'âàÿáKÅKê‘ﬁêêqëú[”(‹†ìâàÿèâêE‘ÿà;–¯Ù ◊&—&Û 	,Ù %†U”+âLàEë5	,˙s   ¬C. √.!DƒDc                 Û⁄  ï [        5       nU (       a  U S   [        ;   a%  [        R                  " SR	                  U 5      5      eU (       ak  U S   [        ;  a^  [        U 5      u  p UR                  U5        U (       a#  U S   S:X  a  UR                  [        5        U SS n U (       a  U S   [        ;  a  M^  US   [        L a(  [        R                  " SR	                  SU -   5      5      eX4$ )z'dot-text = 1*atext *("." 1*atext)

    r   z8expected atom at a start of dot-atom-text but found '{}'r	   r  Nr"  z4expected atom at end of dot-atom-text but found '{}')rd  rp  r   rC  r;   rc  r∂   rå  )r   ⁄dot_atom_textrX   s      r   ⁄get_dot_atom_textrt  D  s÷   Ä Ù  ìMÄMﬁêEò!ëH§	”)‹◊%“% '+ﬂ+1©6∞%´=Û: 	:Ê
êEò!ëH§I”-‹ †”'âàÿ◊—òU‘#ﬁêUò1ëX†ì_ÿ◊ — §‘%ÿò!ò"êIàEˆ êEò!ëH§I’- êR—úC“‹◊%“% 'ﬂ#ôV†C®°I”.Û0 	0‡––r   c                 Û™  ï [        5       nU S   [        ;   a  [        U 5      u  p UR                  U5        U R	                  S5      (       a   [        U 5      u  p O[        U 5      u  p UR                  U5        U (       a+  U S   [        ;   a  [        U 5      u  p UR                  U5        X4$ ! [        R                   a    [        U 5      u  p  Nif = f)zydot-atom = [CFWS] dot-atom-text [CFWS]

Any place we can have a dot atom, we could instead have an rfc2047 encoded
word.
r   r@  )	ra  rj  rk  r∂   rB  rO  r   rC  rt  )r   ⁄dot_atomrX   s      r   ⁄get_dot_atomrw  W  s¿   Ä Ù ãyÄHÿàQÅxî;”‹†ìâàÿèâò‘ÿ◊—ò◊—	4‹+®E”2âLàEê5Ù )®”/âàÿáOÅOêE‘ﬁêêqëú[”(‹†ìâàÿèâò‘ÿà?–¯Ù ◊&—&Û 	4Ù -®U”3âLàEë5	4˙s   ¡B. ¬.!C√Cc                 Û:  ï U S   [         ;   a  [        U 5      u  pOSnU (       d  [        R                  " S5      eU S   S:X  a  [	        U 5      u  p O?U S   [
        ;   a%  [        R                  " SR                  U 5      5      e[        U 5      u  p Ub  U/USS& X 4$ )a`  word = atom / quoted-string

Either atom or quoted-string may start with CFWS.  We have to peel off this
CFWS first to determine which type of word to parse.  Afterward we splice
the leading CFWS, if any, into the parsed sub-token.

If neither an atom or a quoted-string is found before the next special, a
HeaderParseError is raised.

The token returned is either an Atom or a QuotedString, as appropriate.
This means the 'word' level of the formal grammar is not represented in the
parse tree; this is because having that extra layer when manipulating the
parse tree is more confusing than it is helpful.

r   Nz5Expected 'atom' or 'quoted-string' but found nothing.r   z1Expected 'atom' or 'quoted-string' but found '{}')rj  rk  r   rC  rn  ⁄SPECIALSr;   rq  )r   ⁄leaderrX   s      r   ⁄get_wordr{  p  s≠   Ä   àQÅxî;”‹ †õâàê‡àﬁ‹◊%“%ÿCÛE 	E‡àQÅxêÉ}‹(®”/âààuÿ	àqâîX”	‹◊%“% '7ﬂ7=±v∏e≥}ÛF 	FÙ  †ìâàÿ—ÿêHààbàqà	ÿà<–r   c                 ÛÏ  ï [        5       n [        U 5      u  p UR                  U5        U (       aï  U S   [        ;  aà  U S   S:X  aJ  UR                  [        5        UR
                  R                  [        R                  " S5      5        U SS n O [        U 5      u  p UR                  U5        U (       a  U S   [        ;  a  Mà  X4$ ! [        R                   a2    UR
                  R                  [        R                  " S5      5         N‰f = f! [        R                   aM    U S   [        ;   a>  [        U 5      u  p UR
                  R                  [        R                  " S5      5         N“e f = f)a÷  phrase = 1*word / obs-phrase
    obs-phrase = word *(word / "." / CFWS)

This means a phrase can be a sequence of words, periods, and CFWS in any
order as long as it starts with at least one word.  If anything other than
words is detected, an ObsoleteHeaderDefect is added to the token's defect
list.  We also accept a phrase that starts with CFWS followed by a dot;
this is registered as an InvalidHeaderDefect, since it is not supported by
even the obsolete grammar.

zphrase does not start with wordr   r	   zperiod in 'phrase'r  Nzcomment found without atom)rê   r{  r∂   r   rC  r"   r«  ⁄PHRASE_ENDSrå  ⁄ObsoleteHeaderDefectrj  rk  )r   rí   rX   s      r   ⁄
get_phraser  í  s@  Ä Ù ãXÄF0‹†ìâàÿèâêe‘ˆ êEò!ëH§K”/ÿêâ8êSã=ÿèMâMú#‘ÿèNâN◊!—!§&◊"=“"=ÿ$Û#&Ù '‡ò!ò"êIâE‹'®õëê èMâMò%‘ ˆ! êEò!ëH§K’/" à=–¯Ù) ◊"—"Û 0ÿèâ◊—úf◊8“8ÿ-Û/ˆ 	00˚Ù ◊*—*Û ÿòë8ú{”*‹#+®E£?ëLêEÿóNëN◊)—)¨&◊*E“*Eÿ4Û+6ˆ 7 ˙s%   åC	 ¬D √	ADƒDƒAE3≈1E3c                 Û‚  ï [    