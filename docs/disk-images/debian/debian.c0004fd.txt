2\u2553\u256b'
    '\u256a\u2518\u250c\u2588\u2584\u258c\u2590\u2580'
    '\u03b1\xdf\u0393\u03c0\u03a3\u03c3\xb5\u03c4'
    '\u03a6\u0398\u03a9\u03b4\u221e\u03c6\u03b5\u2229'
    '\u2261\xb1\u2265\u2264\u2320\u2321\xf7\u2248'
    '\xb0\u2219\xb7\u221a\u207f\xb2\u25a0\xa0'
)

_importing_zlib = False

# Return the zlib.decompress function object, or NULL if zlib couldn't
# be imported. The function is cached when found, so subsequent calls
# don't import zlib again.
def _get_decompress_func():
    global _importing_zlib
    if _importing_zlib:
        # Someone has a zlib.py[co] in their Zip file
        # let's avoid a stack overflow.
        _bootstrap._verbose_message('zipimport: zlib UNAVAILABLE')
        raise ZipImportError("can't decompress data; zlib not available")

    _importing_zlib = True
    try:
        from zlib import decompress
    except Exception:
        _bootstrap._verbose_message('zipimport: zlib UNAVAILABLE')
        raise ZipImportError("can't decompress data; zlib not available")
    finally:
        _importing_zlib = False

    _bootstrap._verbose_message('zipimport: zlib available')
    return decompress

# Given a path to a Zip file and a toc_entry, return the (uncompressed) data.
def _get_data(archive, toc_entry):
    datapath, compress, data_size, file_size, file_offset, time, date, crc = toc_entry
    if data_size < 0:
        raise ZipImportError('negative data size')

    with _io.open_code(archive) as fp:
        # Check to make sure the local file header is correct
        try:
            fp.seek(file_offset)
        except OSError:
            raise ZipImportError(f"can't read Zip file: {archive!r}", path=archive)
        buffer = fp.read(30)
        if len(buffer) != 30:
            raise EOFError('EOF read where not expected')

        if buffer[:4] != b'PK\x03\x04':
            # Bad: Local File Header
            raise ZipImportError(f'bad local file header: {archive!r}', path=archive)

        name_size = _unpack_uint16(buffer[26:28])
        extra_size = _unpack_uint16(buffer[28:30])
        header_size = 30 + name_size + extra_size
        file_offset += header_size  # Start of file data
        try:
            fp.seek(file_offset)
        except OSError:
            raise ZipImportError(f"can't read Zip file: {archive!r}", path=archive)
        raw_data = fp.read(data_size)
        if len(raw_data) != data_size:
            raise OSError("zipimport: can't read data")

    if compress == 0:
        # data is not compressed
        return raw_data

    # Decompress with zlib
    try:
        decompress = _get_decompress_func()
    except Exception:
        raise ZipImportError("can't decompress data; zlib not available")
    return decompress(raw_data, -15)


# Lenient date/time comparison function. The precision of the mtime
# in the archive is lower than the mtime stored in a .pyc: we
# must allow a difference of at most one second.
def _eq_mtime(t1, t2):
    # dostime only stores even seconds, so be lenient
    return abs(t1 - t2) <= 1


# Given the contents of a .py[co] file, unmarshal the data
# and return the code object. Raises ImportError it the magic word doesn't
# match, or if the recorded .py[co] metadata does not match the source.
def _unmarshal_code(self, pathname, fullpath, fullname, data):
    exc_details = {
        'name': fullname,
        'path': fullpath,
    }

    flags = _bootstrap_external._classify_pyc(data, fullname, exc_details)

    hash_based = flags & 0b1 != 0
    if hash_based:
        check_source = flags & 0b10 != 0
        if (_imp.check_hash_based_pycs != 'never' and
                (check_source or _imp.check_hash_based_pycs == 'always')):
            source_bytes = _get_pyc_source(self, fullpath)
            if source_bytes is not None:
                source_hash = _imp.source_hash(
                    _bootstrap_external._RAW_MAGIC_NUMBER,
                    source_bytes,
                )

                _bootstrap_external._validate_hash_pyc(
                    data, source_hash, fullname, exc_details)
    else:
        source_mtime, source_size = \
            _get_mtime_and_size_of_source(self, fullpath)

        if source_mtime:
            # We don't use _bootstrap_external._validate_timestamp_pyc
            # to allow for a more lenient timestamp check.
            if (not _eq_mtime(_unpack_uint32(data[8:12]), source_mtime) or
                    _unpack_uint32(data[12:16]) != source_size):
                _bootstrap._verbose_message(
                    f'bytecode is stale for {fullname!r}')
                return None

    code = marshal.loads(data[16:])
    if not isinstance(code, _code_type):
        raise TypeError(f'compiled module {pathname!r} is not a code object')
    return code

_code_type = type(_unmarshal_code.__code__)


# Replace any occurrences of '\r\n?' in the input string with '\n'.
# This converts DOS and Mac line endings to Unix line endings.
def _normalize_line_endings(source):
    source = source.replace(b'\r\n', b'\n')
    source = source.replace(b'\r', b'\n')
    return source

# Given a string buffer containing Python source code, compile it
# and return a code object.
def _compile_source(pathname, source):
    source = _normalize_line_endings(source)
    return compile(source, pathname, 'exec', dont_inherit=True)

# Convert the date/time values found in the Zip archive to a value
# that's compatible with the time stamp stored in .pyc files.
def _parse_dostime(d, t):
    return time.mktime((
        (d >> 9) + 1980,    # bits 9..15: year
        (d >> 5) & 0xF,     # bits 5..8: month
        d & 0x1F,           # bits 0..4: day
        t >> 11,            # bits 11..15: hours
        (t >> 5) & 0x3F,    # bits 8..10: minutes
        (t & 0x1F) * 2,     # bits 0..7: seconds / 2
        -1, -1, -1))

# Given a path to a .pyc file in the archive, return the
# modification time of the matching .py file and its size,
# or (0, 0) if no source is available.
def _get_mtime_and_size_of_source(self, path):
    try:
        # strip 'c' or 'o' from *.py[co]
        assert path[-1:] in ('c', 'o')
        path = path[:-1]
        toc_entry = self._get_files()[path]
        # fetch the time stamp of the .py file for comparison
        # with an embedded pyc time stamp
        time = toc_entry[5]
        date = toc_entry[6]
        uncompressed_size = toc_entry[3]
        return _parse_dostime(date, time), uncompressed_size
    except (KeyError, IndexError, TypeError):
        return 0, 0


# Given a path to a .pyc file in the archive, return the
# contents of the matching .py file, or None if no source
# is available.
def _get_pyc_source(self, path):
    # strip 'c' or 'o' from *.py[co]
    assert path[-1:] in ('c', 'o')
    path = path[:-1]

    try:
        toc_entry = self._get_files()[path]
    except KeyError:
        return None
    else:
        return _get_data(self.archive, toc_entry)


# Get the code object associated with the module specified by
# 'fullname'.
def _get_module_code(self, fullname):
    path = _get_module_path(self, fullname)
    import_error = None
    for suffix, isbytecode, ispackage in _zip_searchorder:
        fullpath = path + suffix
        _bootstrap._verbose_message('trying {}{}{}', self.archive, path_sep, fullpath, verbosity=2)
        try:
            toc_entry = self._get_files()[fullpath]
        except KeyError:
            pass
        else:
            modpath = toc_entry[0]
            data = _get_data(self.archive, toc_entry)
            code = None
            if isbytecode:
                try:
                    code = _unmarshal_code(self, modpath, fullpath, fullname, data)
                except ImportError as exc:
                    import_error = exc
            else:
                code = _compile_source(modpath, data)
            if code is None:
                # bad magic number or non-matching mtime
                # in byte code, try next
                continue
            modpath = toc_entry[0]
            return code, ispackage, modpath
    else:
        if import_error:
            msg = f"module load failed: {import_error}"
            raise ZipImportError(msg, name=fullname) from import_error
        else:
            raise ZipImportError(f"can't find module {fullname!r}", name=fullname)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      8   .   ˙   ..  9   __init__.py :   __pycache__ ?   
_common.py  @   
_tzpath.py  A  ò_zoneinfo.py                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    __all__ = [
    "ZoneInfo",
    "reset_tzpath",
    "available_timezones",
    "TZPATH",
    "ZoneInfoNotFoundError",
    "InvalidTZPathWarning",
]

from . import _tzpath
from ._common import ZoneInfoNotFoundError

try:
    from _zoneinfo import ZoneInfo
except ImportError:  # pragma: nocover
    from ._zoneinfo import ZoneInfo

reset_tzpath = _tzpath.reset_tzpath
available_timezones = _tzpath.available_timezones
InvalidTZPathWarning = _tzpath.InvalidTZPathWarning


def __getattr__(name):
    if name == "TZPATH":
        return _tzpath.TZPATH
    else:
        raise AttributeError(f"module {__name__!r} has no attribute {name!r}")


def __dir__():
    return sorted(list(globals()) + ["TZPATH"])
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 :   .   8   ..  ;    __init__.cpython-313.pyc<    _common.cpython-313.pyc =    _tzpath.cpython-313.pyc >  à_zoneinfo.cpython-313.pyc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Û
    F\hø  „                   Û™   ï / S Qr SSKJr  SSKJr   SSKJr  \R                  r\R                  r	\R                  r
S rS rg! \ a	    SSKJr   N9f = f)	)⁄ZoneInfo⁄reset_tzpath⁄available_timezones⁄TZPATH⁄ZoneInfoNotFoundError⁄InvalidTZPathWarningÈ   )⁄_tzpath)r   È    )r   c                 Û\   ï U S:X  a  [         R                  $ [        S[        < SU < 35      e)Nr   zmodule z has no attribute )r	   r   ⁄AttributeError⁄__name__)⁄names    ⁄(/usr/lib/python3.13/zoneinfo/__init__.py⁄__getattr__r      s-   Ä ÿàx”‹è~â~–‰òw§x°l–2D¿T¡H–M”N–NÛ    c                  ÛB   ï [        [        [        5       5      S/-   5      $ )Nr   )⁄sorted⁄list⁄globals© r   r   ⁄__dir__r      s   Ä ‹î$îwìyì/†X†J—.”/–/r   N)⁄__all__⁄ r	   ⁄_commonr   ⁄	_zoneinfor   ⁄ImportErrorr   r   r   r   r   r   r   r   ⁄<module>r      s`   ÚÄı › *$›" ◊#—#Äÿ◊1—1– ÿ◊3—3– ÚOÛ0¯ Û $ﬂ#$˙s   íA ¡A¡A                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Û
    F\hÆ  „                   ÛB   ï S SK r S rS r " S S5      r " S S\5      rg)È    Nc                 Û  ï SSK Jn  U R                  S5      nSR                  S/US S -   5      nUS   n UR	                  U5      R                  U5      R                  S5      $ ! [        [        [        4 a    [        SU  35      ef = f)	Nr   )⁄	resources⁄/⁄.ztzdata.zoneinfoÈˇˇˇˇ⁄rbzNo time zone found with key )⁄	importlibr   ⁄split⁄join⁄files⁄joinpath⁄open⁄ImportError⁄FileNotFoundError⁄UnicodeEncodeError⁄ZoneInfoNotFoundError)⁄keyr   ⁄
components⁄package_name⁄resource_names        ⁄'/usr/lib/python3.13/zoneinfo/_common.py⁄load_tzdatar      sí   Ä ›#‡óëò3ìÄJÿó8ë8–.–/∞*∏S∏b∞/—A”BÄLÿòrëNÄMJÿèâò|”,◊5—5∞m”D◊I—I»$”O–O¯‹‘*‘,>–?Û JÙ $–&B¿3¿%–$H”I–IJ˙s   ∂.A% ¡%$B	c                 Ûx  ^ ^^^ï [         R                  T 5      nUR                  S:X  a  SnSnOÅSnSnUR                  S-  UR                  S-  -   UR
                  -   UR                  S-  -   UR                  -   UR                  -   nT R                  US5        [         R                  T 5      nUR                  nUR                  nUR
                  nU(       aX  [        R                  " SU U 3T R                  Xb-  5      5      n[        R                  " SU S	3T R                  U5      5      n	OS
nS
n	U(       a  [        U 4S j[        U5       5       6 u  p´nOS
n
S
nS
n0 mT R                  U5      mUU4S jm[        U4S jU 5       5      nUR                  S:º  aí  UR                  UR                  -   UR                  S-  -   nT R                  US5        T R                  S5      nUS:X  d   U5       eSnT R                  S5      =nS:w  a  X˛-  nT R                  S5      =nS:w  a  M  UnOS nXòX´UU4$ )NÈ   È   ⁄lÈ   ⁄qÈ   È   ⁄>⁄B© c              3   Ûp   >#   ï U  H+  n[         R                  " S TR                  S5      5      v ï  M-     g7f)z>lbbr    N)⁄struct⁄unpack⁄read)⁄.0⁄i⁄fobjs     Är   ⁄	<genexpr>⁄load_data.<locals>.<genexpr>H   s'   ¯È Ä –J∫>∞aåfèmämòF†DßI°I®a£L◊1–1∫>˘s   É36c                 Ûh   >ï U T;  a'  TR                  SU 5      nTX R                  5       TU '   TU    $ )NÛ    )⁄find⁄decode)⁄idx⁄span_end⁄
abbr_chars⁄	abbr_valss     ÄÄr   ⁄get_abbr⁄load_data.<locals>.get_abbrV   s>   ¯Ä  êi”ÿ!óë†w∞”4àHÿ'®–5◊<—<”>àIêcâN‡òâ~–Û    c              3   Û4   >#   ï U  H  nT" U5      v ï  M     g 7f)Nr#   )r(   r1   r5   s     Är   r+   r,   g   s   ¯È Ä –2™'†3ëò#óê™'˘s   ÉÈ   È   Û   
r7   )⁄_TZifHeader⁄	from_file⁄version⁄timecnt⁄typecnt⁄charcnt⁄leapcnt⁄isstdcnt⁄isutcnt⁄seekr%   r&   r'   ⁄zip⁄range⁄tuple)r*   ⁄header⁄	time_size⁄	time_type⁄
skip_bytesr@   r?   rA   ⁄trans_list_utc⁄	trans_idx⁄utcoff⁄isdst⁄abbrind⁄abbr⁄c⁄tz_bytes⁄tz_strr3   r4   r5   s   `                @@@r   ⁄	load_datarV      s7  ˚Ä ‹◊"—"†4”(ÄF‡á~Å~ò”ÿà	ÿâ	 à	ÿà	
 èNâNòQ—ÿènânòq— Ò!‡ènânÒ ènânòq— Ò! èoâoÒ	
 ènânÒ 	 	è	â	ê*òa‘ Ù ◊&—&†t”,à‡ènânÄGÿènânÄGÿènânÄGˆ ‹üöÿêàyòò–$†dßi°i∞—0C”&DÛ
àÙ óMíM†A†g†Y®a†.∞$∑)±)∏G”2D”Eâ	‡àÿà	ˆ ‹!$‹Jº5¿º>”J"
—àëw àÿàÿà ÄIÿóëò7”#ÄJˆÙ" ‘2©'”2”2ÄD
 á~Å~ò”‡ó^ë^†fßo°o—5∏øπ»—8K—Kà
ÿè	â	ê*òa‘ ‡èIâIêaãLàÿêEãz–ò1”àz‡àÿóIëIòaìL– àq†U”*ÿâMàH óIëIòaìL– àq†U’* â‡à‡†f∞T∏6–A–Ar7   c                   Û2   ï \ rS rSr/ SQrS r\S 5       rSrg)r<   È   )r>   rD   rC   rB   r?   r@   rA   c                 ÛX   ï [        U R                  USS9 H  u  p#[        XU5        M     g )NT)⁄strict)rF   ⁄	__slots__⁄setattr)⁄self⁄args⁄attr⁄vals       r   ⁄__init__⁄_TZifHeader.__init__ä   s&   Ä ‹òTü^ô^®T∏$‘?âIàD‹êD†÷$Ú @r7   c                 Û  ï UR                  S5      S:w  a  [        S5      eUR                  S5      nUS:X  a  SnO[        U5      nUR                  S5        U4nU[        R                  " SUR                  S5      5      -   nU " U6 $ )	Nr   s   TZifz"Invalid TZif file: magic not foundr   r.   È   z>6lÈ   )r'   ⁄
ValueError⁄intr%   r&   )⁄cls⁄stream⁄_versionr>   r^   s        r   r=   ⁄_TZifHeader.from_fileé   s~   Ä  è;â;êqã>òW”$‹–A”B–B‡ó;ë;òqì>àÿêw”ÿâG‰ò(ìmàGÿèâêBå‡àzà îfómím†E®6Ø;©;∞r´?”;—;à·êDàz–r7   r#   N)	⁄__name__⁄
__module__⁄__qualname__⁄__firstlineno__r[   ra   ⁄classmethodr=   ⁄__static_attributes__r#   r7   r   r<   r<      s"   Ü ÚÄIÚ% ÒÛ Ûr7   r<   c                   Û   ï \ rS rSrSrSrg)r   È£   z2Exception raised when a ZoneInfo key is not found.r#   N)rl   rm   rn   ro   ⁄__doc__rq   r#   r7   r   r   r   £   s   Ü ‹<r7   r   )r%   r   rV   r<   ⁄KeyErrorr   r#   r7   r   ⁄<module>rv      s-   € ÚJÚ.aB˜H!Ò !ÙH=òHı =r7                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Û
    F\h  „                   Û‰   ï S SK r S SKrSS jrSS jrS rS rS r\ R                  R                  \ R                  R                  SS5      5      SS r
\
4S	 jrC
S
 r " S S\5      rSq\" SS9  g)È    Nc                 Û∞  ï U nUbÇ  [        U[        [        45      (       a  [        SS[	        U5       SU< 3-   5      e[        [        [        R                  R                  U5      5      (       d  [        [        U5      5      eUnOD[        R                  R                  SS 5      nUc  [        R                  " S5      n[!        XA5      n[#        U5      qg )Nz!tzpaths must be a list or tuple, znot z: ⁄PYTHONTZPATH⁄TZPATH)⁄
isinstance⁄str⁄bytes⁄	TypeError⁄type⁄all⁄map⁄os⁄path⁄isabs⁄
ValueError⁄_get_invalid_paths_message⁄environ⁄get⁄	sysconfig⁄get_config_var⁄_parse_python_tzpath⁄tupler   )⁄to⁄
stacklevel⁄tzpaths⁄base_tzpath⁄env_vars        ⁄'/usr/lib/python3.13/zoneinfo/_tzpath.py⁄_reset_tzpathr      s∏   Ä  ÄGÿ—‹êg§§Uò|◊,—,‹ÿ3ÿúògõò†r®'©–5Ò6Û Ù
 î3îrówëwó}ë}†g”.◊/—/‹‘7∏”@”A–Aÿâ‰ó*ë*ó.ë.†∞”6àÿâ?‹◊.“.®x”8àG‹*®7”?à‰ê;”ÅFÛ    c                 Û   ï [        U 5        g)zReset global TZPATH.N)r   )r   s    r   ⁄reset_tzpathr!      s   Ä Ù
 ê"’r   c                 Û,  ï U (       d  gU R                  [        R                  5      n[        [	        [        R
                  R                  U5      5      n[        U5      [        U5      :w  a'  SS Kn[        U5      nUR                  SU-   [        US9  U$ )N© r   z>Invalid paths specified in PYTHONTZPATH environment variable. ©r   )⁄splitr   ⁄pathsepr   ⁄filterr   r   ⁄len⁄warningsr   ⁄warn⁄InvalidTZPathWarning)r   r   ⁄
raw_tzpath⁄
new_tzpathr)   ⁄msgs         r   r   r   $   s|   Ä ﬁÿ‡óëúrüzôz”*ÄJ‹îvúbügôgümôm®Z”8”9ÄJÙ à:Éú#òjõ/”)€‰(®”4à‡èâÿLÿÒ‰ ÿ!	 	Ò 	
 –r   c                 ÛH   ï S U  5       nSnX"R                  U5      -   nSU-   $ )Nc              3   Ûr   #   ï U  H-  n[         R                  R                  U5      (       a  M)  Uv ï  M/     g 7f©N)r   r   r   )⁄.0r   s     r   ⁄	<genexpr>⁄-_get_invalid_paths_message.<locals>.<genexpr><   s!   È Ä –I¢gòd¥R∑W±W∑]±]¿4◊5HóTëT¢g˘s   Ç(7Æ	7z
    z@Paths should be absolute but found the following relative paths:)⁄join)r   ⁄invalid_paths⁄prefix⁄indented_strs       r   r   r   ;   s5   Ä ŸI°g”IÄM‡ÄFÿüKôK®”6—6ÄL 	Kÿ
Ò	r   c                 Û¬   ï [        U 5        [         HJ  n[        R                  R	                  X5      n[        R                  R                  U5      (       d  MH  Us  $    g)z,Retrieve the path to a TZif file from a key.N)⁄_validate_tzfile_pathr   r   r   r5   ⁄isfile)⁄key⁄search_path⁄filepaths      r   ⁄find_tzfiler?   G   sC   Ä ‰ò#‘ﬂà‹ó7ë7ó<ë<†”1à‹è7â7è>â>ò(◊#”#ÿäOÒ 
 r   ⁄_Èˇˇˇˇc                 Û≤  ï [         R                  R                  U 5      (       a  [        SU  35      e[         R                  R	                  U 5      n[        U5      [        U 5      :w  a  [        SU  35      e[         R                  R	                  [         R                  R                  X5      5      nUR                  U5      (       d  [        SU  35      eg )Nz.ZoneInfo keys may not be absolute paths, got: z6ZoneInfo keys must be normalized relative paths, got: z;ZoneInfo keys must refer to subdirectories of TZPATH, got: )r   r   r   r   ⁄normpathr(   r5   ⁄
startswith)r   ⁄_base⁄new_path⁄resolveds       r   r:   r:   U   sπ   Ä ‹	áwÅwá}Å}êT◊—‹ÿ<∏T∏F–CÛ
 	
Ù èwâw◊—†”%ÄH‹
à8É}úòDõ	”!‹ÿD¿T¿F–KÛ
 	
Ù èwâw◊—§ß°ß°®U” =”>ÄHÿ◊—òu◊%—%‹ÿI»$»–PÛ
 	
 &r   c                  Û‚  ï SSK Jn   [        5       n U R                  S5      R	                  S5      R                  S5       nU H-  nUR                  5       nU(       d  M  UR                  U5        M/     SSS5        S n[         GH$  n[        R                  R                  U5      (       d  M*  [        R                  " U5       H‡  u  pgnXe:X  a.  SU;   a  UR                  S5        S	U;   a  UR                  S	5        U H°  n	[        R                  R!                  Xi5      n
[        R                  R#                  X•S
9n[        R$                  S:w  a   UR'                  [        R$                  S5      nU(       a  X±;   a  MÅ  U" U
5      (       d  Mê  UR                  U5        M£     M‚     GM'     SU;   a  UR                  S5        U$ ! , (       d  f       GNZ= f! [        [        4 a     GNpf = f)a  Returns a set containing all available time zones.

.. caution::

    This may attempt to open a large number of files, since the best way to
    determine if a given file on the time zone search path is to open it
    and check for the "magic string" at the beginning.
r   )⁄	resources⁄tzdata⁄zones⁄rNc                 Ûö   ï  [        U S5       nUR                  S5      S:H  sS S S 5        $ ! , (       d  f       g = f! [         a     gf = f)N⁄rbÈ   s   TZifF)⁄open⁄read⁄	Exception)⁄fpath⁄fs     r   ⁄	valid_key⁄&available_timezones.<locals>.valid_keyá   s@   Ä 	‹êeòT‘"†aÿóvëvòaìy†G—+˜ #◊"◊"˚‰Û 	Ÿ	˙s#   Ç= é,¢	= ¨
:∂= ∫= Ω
A
¡	A
⁄right⁄posix)⁄start⁄/⁄
posixrules)⁄	importlibrI   ⁄set⁄files⁄joinpathrP   ⁄strip⁄add⁄ImportError⁄FileNotFoundErrorr   r   r   ⁄exists⁄walk⁄remover5   ⁄relpath⁄sep⁄replace)rI   ⁄valid_zonesrT   ⁄zonerU   ⁄tz_root⁄root⁄dirnamesr^   ⁄filerS   r<   s               r   ⁄available_timezonesrp   o   sà  Ä ı $‰ì%ÄKÿè_â_òX”&◊/—/∞”8◊=—=∏c‘B¿a€êÿózëzì|êﬂê4ÿóOëO†D÷)Ò ˜ CÚ˜ ê6à‹èwâwè~â~òg◊&—&Ÿ‰%'ßW¢W®W÷%5—!àDòEÿã òh”&ÿóOëO†G‘,ÿòh”&ÿóOëO†G‘,„ê‹üôüô†T”0ê‰ógëgóoëo†eêo–;ê‹ó6ë6òSì=ÿü+ô+§bßf°f®c”2êCÊòc”0Ÿ·òU◊#”#ÿóOëO†C÷(Û Ù &6Ò	 4 ê{”" 	◊—ò<‘(‡–˜] C÷B˚Ù
 ‘*–+Û ⁄˙s5   í/G ¡G¡ G¡5G «
G«G «G «G.«-G.c                   Û   ï \ rS rSrSrSrg)r+   È∞   z?Warning raised if an invalid path is specified in PYTHONTZPATH.r#   N)⁄__name__⁄
__module__⁄__qualname__⁄__firstlineno__⁄__doc__⁄__static_attributes__r#   r   r   r+   r+   ∞   s   Ü ‹Ir   r+   r#   È   r$   )NrO   r1   )r   r   r   r!   r   r   r?   r   rC   r5   ⁄
_TEST_PATHr:   rp   ⁄RuntimeWarningr+   r   r#   r   r   ⁄<module>r|      sÇ   € 	€ Ù Ù.ÚÚ.	Ú èWâW◊—òbügôgülôl®3∞”4”5∞c∞r–:Ä
 '1Ù 
. Ú>ÙBJò>Ù J 
ÄŸ ò” r                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Û
    F\hb`  „                   Û`  ï S SK r S SKrS SKrS SKrS SKrS SKrS SKJrJrJr  SSK	J
r
Jr  \" SSS5      r\" SSS5      R                  5       r\R                  " SS9S 5       r " S	 S
\5      r " S S5      r\" SSS5      r " S S5      rS r " S S5      r " S S5      rS rS rS rS rg)È    N)⁄datetime⁄	timedelta⁄tzinfoÈ   )⁄_common⁄_tzpathi≤  i   )⁄maxsizec                 Û   ï [        U S9$ )N©⁄seconds)r   r   s    ⁄)/usr/lib/python3.13/zoneinfo/_zoneinfo.py⁄_load_timedeltar      s   Ä ‰òW—%–%Û    c                   ÛT  ^ ï \ rS rSrSr\R                  " 5       r\R                  " 5       r
SrS rS r\S 5       r\U 4S j5       r\SU 4S	 jj5       r\SS
.S j5       r\S 5       rS rS rS rS rS rS rS rS rS rS r\S 5       rS rS r \!S 5       r"\!S 5       r#Sr$U =r%$ )⁄ZoneInfoÈ   È   ⁄zoneinfoc                 Ûl   ï [         R                  " 5       U l        [        R                  " 5       U l        g ©N)⁄collections⁄OrderedDict⁄_strong_cache⁄weakref⁄WeakValueDictionary⁄_weak_cache)⁄clss    r   ⁄__init_subclass__⁄ZoneInfo.__init_subclass__$   s#   Ä ‹'◊3“3”5à‘‹!◊5“5”7àçr   c                 Ûn  ï U R                   R                  US 5      nUc1  U R                   R                  XR                  U5      5      nSUl        U R
                  R                  X5      U R
                  U'   [        U R
                  5      U R                  :î  a  U R
                  R                  SS9  U$ )NTF)⁄last)
r   ⁄get⁄
setdefault⁄_new_instance⁄_from_cacher   ⁄pop⁄len⁄_strong_cache_size⁄popitem)r   ⁄key⁄instances      r   ⁄__new__⁄ZoneInfo.__new__(   sù   Ä ÿó?ë?◊&—&†s®D”1àÿ—ÿóë◊1—1∞#◊7H—7H»”7M”NàHÿ#'àH‘  "%◊!2—!2◊!6—!6∞s”!Eà◊—ò#—‰às◊ — ”!†C◊$:—$:”:ÿ◊—◊%—%®5–%—1‡àr   c                 Û6   ï U R                  U5      nSUl        U$ )NF)r$   r%   )r   r*   ⁄objs      r   ⁄no_cache⁄ZoneInfo.no_cache6   s   Ä ‡◊—†”$àÿàå‡à
r   c                 Û.  >ï [         TU ]  U 5      nXl        UR                  U5      Ul        UR                  b  [        UR                  S5      nO[        R                  " U5      nU nUR                  U5        S S S 5        U$ ! , (       d  f       U$ = f)N⁄rb)	⁄superr,   ⁄_key⁄_find_tzfile⁄
_file_path⁄openr   ⁄load_tzdata⁄
_load_file)r   r*   r/   ⁄file_obj⁄f⁄	__class__s        Är   r$   ⁄ZoneInfo._new_instance=   s~   ¯Ä ‰âgâoòc”"àÿåÿ◊)—)®#”.àå‡è>â>—%‹òCüNôN®D”1âH‰◊*“*®3”/àH·òÿèNâNò1‘˜  à
˜ åX à
˙s   ¡)B¬
BNc                Û§   >ï [         TU ]  U 5      nX#l        S Ul        UR	                  U5        [        U5      Ul        UR                  Ul        U$ r   )	r4   r,   r5   r7   r:   ⁄repr⁄
_file_repr⁄_file_reduce⁄
__reduce__)r   ⁄fobjr*   r/   r=   s       Är   ⁄	from_file⁄ZoneInfo.from_fileM   sH   ¯Ä ‰âgâoòc”"àÿåÿàåÿèâêt‘‹òdõàå ◊)—)àå‡à
r   )⁄	only_keysc                Ûˆ   ï UbB  U H;  nU R                   R                  US 5        U R                  R                  US 5        M=     g U R                   R                  5         U R                  R                  5         g r   )r   r&   r   ⁄clear)r   rG   r*   s      r   ⁄clear_cache⁄ZoneInfo.clear_cacheZ   s`   Ä ‡— € êÿóë◊#—#†C®‘.ÿ◊!—!◊%—%†c®4÷0Ú !
 èOâO◊!—!‘#ÿ◊—◊#—#’%r   c                 Û   ï U R                   $ r   )r5   ©⁄selfs    r   r*   ⁄ZoneInfo.keye   s   Ä ‡èyây–r   c                 Û8   ï U R                  U5      R                  $ r   )⁄_find_trans⁄utcoff©rN   ⁄dts     r   ⁄	utcoffset⁄ZoneInfo.utcoffseti   Û   Ä ÿ◊—†”#◊*—*–*r   c                 Û8   ï U R                  U5      R                  $ r   )rQ   ⁄dstoffrS   s     r   ⁄dst⁄ZoneInfo.dstl   rW   r   c                 Û8   ï U R                  U5      R                  $ r   )rQ   ⁄tznamerS   s     r   r]   ⁄ZoneInfo.tznameo   rW   r   c                 Û  ï [        U[        5      (       d  [        S5      eUR                  U La  [	        S5      eU R                  U5      n[        U R                  5      nUS:º  a"  X R                  S   :  a  U R                  nSnGOIUS:X  d  X R                  S   :î  aG  [        U R                  [        5      (       d(  U R                  R                  X!R                  5      u  pEOÍUS:X  a  U R                  nSnO’[        R                  " U R                  U5      nUS:î  a'  X R                  S   :º  a  U R                  US-
  U u  ptOIX R                  S   :î  a  U R                  S   nU R                  nOU R                  nU R                  S   nUR                   UR                   -
  nUR#                  5       X R                  US-
     -
  :Ñ  nXR                   -  nU(       a  UR%                  SS9$ U$ )z6Convert from datetime in UTC to datetime in local timez&fromutc() requires a datetime argumentzdt.tzinfo is not selfr   r   ÈˇˇˇˇÈ   )⁄fold)⁄
isinstancer   ⁄	TypeErrorr   ⁄
ValueError⁄_get_local_timestampr'   ⁄
_trans_utc⁄_tti_before⁄	_tz_after⁄_ttinfo⁄get_trans_info_fromutc⁄year⁄bisect⁄bisect_right⁄_ttinfosrR   ⁄total_seconds⁄replace)	rN   rT   ⁄	timestamp⁄	num_trans⁄ttirb   ⁄idx⁄tti_prev⁄shifts	            r   ⁄fromutc⁄ZoneInfo.fromutcr   s≤  Ä Ù ò"úh◊'—'‹–D”E–Eÿè9â9òD“ ‹–4”5–5‡◊-—-®b”1à	‹òüô”(à	‡òã>òiØ/©/∏!—*<”<ÿ◊"—"àCÿäD‡òãNòiØ/©/∏"—*=”=‹òTü^ô^¨W◊5—5ÿüô◊=—=ÿü7ô7ÛâIàCê ò!ã^ÿó.ë.àCÿâD‰◊%“%†dßo°o∞y”AàC‡ò1ã}†Øo©o∏a—.@”!@ÿ $ß°®c∞A©g∏– <ëêò#ÿü_ô_®R—0”0ÿü=ô=®—,êÿónënë‡◊+—+êÿómëm†A—&ê óOëO†cßj°j—0àEÿ◊&—&”(®9∑±¿s»Q¡w—7O—+O—OàDÿ
èjâj—àﬁÿó:ë:†1ê:–%–%‡àIr   c                 Û"  ï Uc#  U R                   (       a  U R                  $ [        $ U R                  U5      nU R                  UR
                     n[        U5      nU(       a  X#S   :  a  U R                  $ U(       a  X#S   :î  a[  [        U R                  [        5      (       a0  U R                  R                  X!R                  UR
                  5      $ U R                  $ [        R                  " X25      S-
  nUS:º  d   eU R                  U   $ )Nr   r`   r   )⁄_fixed_offsetri   ⁄
_NO_TTINFOrf   ⁄_trans_localrb   r'   rh   rc   ⁄_TZStr⁄get_trans_inforl   rm   rn   ro   )rN   rT   ⁄ts⁄ltrs   ru   s         r   rQ   ⁄ZoneInfo._find_transû   s⁄   Ä ÿâ:ÿ◊!◊!ÿó~ë~–%‰!–!‡◊&—&†r”*à‡◊—òrüwôw—'à‰òìGà	Êò†ôeõÿ◊#—#–#ﬁòb†b°6õk‹ò$ü.ô.¨&◊1—1ÿó~ë~◊4—4∞Røπ¿"«'¡'”J–J‡ó~ë~–%Ù ◊%“%†b”-∞—1àCÿò!ì8àOê8ÿó=ë=†—%–%r   c                 Ûê   ï UR                  5       [        -
  S-  UR                  S-  -   UR                  S-  -   UR                  -   $ )NÈÄQ È  È<   )⁄	toordinal⁄EPOCHORDINAL⁄hour⁄minute⁄secondrS   s     r   rf   ⁄ZoneInfo._get_local_timestampπ   sH   Ä ‡è\â\ã^úl—*®e—3ÿègâgòânÒ‡èiâiò"ânÒ èiâiÒ	
r   c                 ÛL   ï U R                   b  U R                    $ [        U 5      $ r   )r5   r@   rM   s    r   ⁄__str__⁄ZoneInfo.__str__¡   s"   Ä ÿè9â9— ÿóiëiê[–!‰òì:–r   c                 Û∂   ï U R                   b'  U R                  R                   SU R                   < S3$ U R                  R                   SU R                   S3$ )Nz(key=⁄)z.from_file()r5   r=   ⁄__name__rA   rM   s    r   ⁄__repr__⁄ZoneInfo.__repr__«   sQ   Ä ÿè9â9— ÿónën◊-—-–.®e∞D∑I±I±=¿–B–B‡ónën◊-—-–.®k∏$ø/π/–9J»!–L–Lr   c                 Û^   ï U R                   R                  U R                  U R                  44$ r   )r=   ⁄	_unpickler5   r%   rM   s    r   rC   ⁄ZoneInfo.__reduce__Õ   s&   Ä ÿóë◊(—(®4Ø9©9∞d◊6F—6F–*G–H–Hr   c                 Û,   ï SS K nUR                  S5      e)Nr   z9Cannot pickle a ZoneInfo file created from a file stream.)⁄pickle⁄PicklingError)rN   rô   s     r   rB   ⁄ZoneInfo._file_reduce–   s   Ä €‡◊"—"ÿGÛ
 	
r   c                ÛB   ï U(       a  U " U5      $ U R                  U5      $ r   )r0   )r   r*   ⁄
from_caches      r   rñ   ⁄ZoneInfo._unpickle◊   s   Ä ÊŸêsì8àO‡ó<ë<†”$–$r   c                 Û.   ï [         R                  " U5      $ r   )r   ⁄find_tzfile)rN   r*   s     r   r6   ⁄ZoneInfo._find_tzfileﬁ   s   Ä ‹◊"“"†3”'–'r   c                 Û   ï [         R                  " U5      u  p#pEpgU R                  X$U5      nU R                  X#U5      n	[	        XHU5       V
VVs/ s H%  u  p´n[        [        U
5      [        U5      U5      PM'     nnn
nX0l        Xêl        U Vs/ s H  oÌU   PM	     snU l	        [        [        U5      5       H  nX_   (       a  M  Xﬂ   U l          O/   U R                  (       a  U R                  S   U l        OS U l        Ub%  US:w  a  [        UR                  5       5      U l        OSU R                  (       d  U(       d  [!        S5      eU R                  (       a  U R                  S   U l        O
US   U l        [        U5      S:î  d  [#        U R                  [
        5      (       d  SU l        g U(       d  SU l        g US   U R                  :H  U l        g s  snnn
f s  snf )Nr   r   zNo time zone information found.r`   r   FT)r   ⁄	load_data⁄_utcoff_to_dstoff⁄_ts_to_local⁄ziprj   r   rg   r}   ro   ⁄ranger'   rh   ⁄_parse_tz_str⁄decoderi   re   rc   r{   )rN   rD   ⁄	trans_idx⁄	trans_utcrR   ⁄isdst⁄abbr⁄tz_strrY   ⁄trans_localrU   ⁄	dstoffsetr]   ⁄_ttinfo_listru   ⁄is                   r   r:   ⁄ZoneInfo._load_file·   s™  Ä ‰<C◊<M“<MÿÛ=
—9à	òf®T
 ◊'—'®	∏5”Aà ◊'—'®	∏f”EàÙ 14∞F¿D‘0Iı	
Ú 1J—,ê	†fÙ ‹†	”*¨O∏I”,F»ˆÒ 1J	 	Ú 
 $åÿ'‘Ÿ6?”@≤i®s†c‘*±i—@àåÙ îsò5ìz÷"àAÿó8ë8ÿ#/°?ê‘ ŸÒ #
 è}è}ÿ#'ß=°=∞—#3ê’ ‡#'ê‘  —†&®C£-‹*®6Ø=©=´?”;àDçN‡ó=ó=Æ‹ –!B”C–C‡è}è}ÿ!%ß°®r—!2êï‡!-®b—!1êîÙ* à|”òq” ¨
∞4∑>±>ƒ7◊(K—(Kÿ!&àD’ﬁÿ!%àD’‡!-®a°∞D∑N±N—!BàD’˘Ùu
˘Ú As   ¡,G¬G c                 Û∆  ï [        U5      nS/U-  n[        U5      nSn[        S[        U 5      5       H}  nXV:X  a    U$ X   nX(   n	U	(       d  M  XH   S:w  a  M&  Sn
X   nXS-
     nX,   (       d  X±U   -
  n
U
(       d!  XÉS-
  :  a  XS-      nX,   (       a  Md  X±U   -
  n
U
(       d  Mt  US-  nX§U'   M     [        U5       H  nXH   (       a  M  X(   (       d  M  SXH'   M     U$ )Nr   r   rÖ   )r'   ⁄sumrß   )r™   ⁄
utcoffsets⁄isdsts⁄typecnt⁄dstoffs⁄dst_cnt⁄	dst_foundr≤   ru   rZ   rY   rR   ⁄comp_idxs                r   r§   ⁄ZoneInfo._utcoff_to_dstoff*  s  Ä Ù êfì+àÿê#òë-à‹êfì+àÿà	‰êqú#òiõ.÷)àAÿ”#ÿX àU ë,àC‡ë+àCˆ Ÿ â|òq” Ÿ‡àFÿë_àF‡ †Q°—'àH‡◊#ÿ®X—"6—6êÊòc®q°[”1ÿ$®°U—+ê
 ◊#Ÿ‡®X—"6—6êÁàvÿòQëê	ÿ%òìÒK *ÙT òWñ~êÿó|ë|®Ø©ÿ#'êGìLÒ & àr   c                 ÛÇ  ï U(       d  / / /$ [        U5      [        U5      /n[        U5      S:î  a  US   nX S      nXT:î  a  XEpEOUS   =pEUS   S==   U-  ss'   US   S==   U-  ss'   [        S[        U 5      5       H;  nX US-
        nX U      nXT:î  a  XEpEUS   U==   U-  ss'   US   U==   U-  ss'   M=     U$ )zGenerate number of seconds since 1970 *in the local time*.

This is necessary to easily find the transition times in local timer   r   )⁄listr'   rß   )r™   ⁄trans_list_utcr∂   ⁄trans_list_wall⁄offset_0⁄offset_1r≤   s          r   r•   ⁄ZoneInfo._ts_to_locali  s¯   Ä ˆ
 ÿòê8àOÙ  †”/¥∞n”1E–Fà‰àzã?òQ”ÿ!†!ë}àHÿ!®A°,—/àHÿ”"ÿ%-ò(¯‡",®Q°-–/àH‡ò—ò1”†—)”ÿò—ò1”†—)”‰êqú#òiõ.÷)àAÿ!®A∞©E—"2—3àHÿ!®A°,—/àH‡”"ÿ%-ò(‡òA—òq”!†X—-”!ÿòA—òq”!†X—-’!Ò * –r   )r{   r}   rg   rh   ro   ri   r   )&rí   ⁄
__module__⁄__qualname__⁄__firstlineno__r(   r   r   r   r   r   r   r   r,   ⁄classmethodr0   r$   rE   rJ   ⁄propertyr*   rU   rZ   r]   rx   rQ   rf   ré   rì   rC   rB   rñ   r6   r:   ⁄staticmethodr§   r•   ⁄__static_attributes__⁄__classcell__)r=   s   @r   r   r      s  ¯Ü ÿ–ÿ◊+“+”-ÄMÿ◊-“-”/ÄKÿÄJÚ8Ú ÒÛ  ÙÛ  ˆ
Û 
 ÿ&*Ù &Û & ÒÛ Ú+Ú+Ú+Ú*ÚX&Ú6
ÚÚMÚIÚ
 Ò%Û %Ú(ÚGCR Ò<Û <| ÒÛ ˆr   r   c                   Û.   ï \ rS rSr/ SQrS rS rS rSrg)rj   iå  ©rR   rY   r]   c                 Û(   ï Xl         X l        X0l        g r   rŒ   )rN   rR   rY   r]   s       r   ⁄__init__⁄_ttinfo.__init__è  s   Ä ÿåÿåÿçr   c                 Û¥   ï U R                   UR                   :H  =(       a9    U R                  UR                  :H  =(       a    U R                  UR                  :H  $ r   rŒ   )rN   ⁄others     r   ⁄__eq__⁄_ttinfo.__eq__î  sA   Ä ‡èKâKò5ü<ô<—'˜ ,ÿóëòuü|ô|—+˜,‡óëòuü|ô|—+	
r   c                 ÛÜ   ï U R                   R                   SU R                   SU R                   SU R                   S3-   $ )N⁄(z, rë   )r=   rí   rR   rY   r]   rM   s    r   rì   ⁄_ttinfo.__repr__õ  s@   Ä ‡è~â~◊&—&–'ÿê$ó+ë+êòb†ß°†®R∞∑±®}∏A–>Ò?	
r   )rY   r]   rR   N)	rí   r≈   r∆   r«   ⁄	__slots__r–   r‘   rì   rÀ   © r   r   rj   rj   å  s   Ü ⁄.ÄIÚÚ

ı
r   rj   c                   Û6   ï \ rS rSrSr S	S jrS rS rS rSr	g)
r~   i•  )⁄stdrZ   ⁄start⁄endr   rk   ⁄dst_diffNc                 Û@  ï XB-
  U l         [        U5      n[        U[        S5      US9U l        XPl        X`l        [        U5      n[        U R                   5      n[        XGUS9U l        Uc   S5       eUc   S5       eU R                  U l        U R                  U l
        g )Nr   rŒ   zNo transition start specifiedzNo transition end specified)rﬂ   r   rj   r‹   r›   rﬁ   rZ   ⁄_get_trans_infor   ⁄_get_trans_info_fromutcrk   )rN   ⁄std_abbr⁄
std_offset⁄dst_abbr⁄
dst_offsetr›   rﬁ   ⁄deltas           r   r–   ⁄_TZStr.__init__∞  s¢   Ä  #—/àå‹$†Z”0à
‹ÿ§o∞a”&8¿Ò
àå å
ÿå‰$†Z”0à
‹†ß°”.à‹†*¿8—Làå — –A–"A”A– ÿâ–=– =”=à‡"◊2—2à‘ÿ&*◊&B—&Bà’#r   c                 Ût   ï U R                   R                  U5      nU R                  R                  U5      nX#4$ r   )r›   ⁄year_to_epochrﬁ   )rN   rl   r›   rﬁ   s       r   ⁄transitions⁄_TZStr.transitions»  s2   Ä ÿó
ë
◊(—(®”.àÿèhâh◊$—$†T”*àÿàz–r   c                 Û*  ï U R                  U5      u  pEX0R                  S:¨  :X  a  XPR                  -  nOX@R                  -  nXE:  a  XAs=:*  =(       a    U:  Os  nOXQs=:*  =(       a    U:  Os  (       + nU(       a  U R                  $ U R                  $ )z6Get the information about the current transition - ttir   )rÎ   rﬂ   rZ   r‹   )rN   rÄ   rl   rb   r›   rﬁ   r¨   s          r   r·   ⁄_TZStr._get_trans_infoÕ  sz   Ä ‡◊%—%†d”+â
à óMëM†Q—&”'ÿó=ë=— âC‡ó]ë]—"àE‡ã;ÿ◊%”%†#‘%âE‡◊*”*†U‘*‘+àEÊ àtèxâx–.†dßh°h–.r   c                 Ûˆ  ï U R                  U5      u  p4X0R                  R                  R                  5       -  nX@R                  R                  R                  5       -  nX4:  a  X1s=:*  =(       a    U:  Os  nOXAs=:*  =(       a    U:  Os  (       + nU R
                  S:î  a  UnX@R
                  -   nOUnX0R
                  -
  nXas=:*  =(       a    U:  Os  nU(       a  U R                  U4$ U R                  U4$ )Nr   )rÎ   r‹   rR   rp   rZ   rﬂ   )	rN   rÄ   rl   r›   rﬁ   r¨   ⁄ambig_start⁄	ambig_endrb   s	            r   r‚   ⁄_TZStr._get_trans_info_fromutcÂ  sÕ   Ä ÿ◊%—%†d”+â
àÿóëóë◊.—.”0—0àÿèxâxèâ◊,—,”.—.à‡ã;ÿ◊%”%†#‘%âE‡◊*”*†U‘*‘+àE
 è=â=ò1”ÿàKÿümôm—+âI‡àKÿß°—-àI‡◊,”,†9‘,àÊ!êóë∞–6–6†tßx°x∞–6–6r   )rZ   rﬂ   rﬁ   r   rk   r›   r‹   )NN)
rí   r≈   r∆   r«   rŸ   r–   rÎ   r·   r‚   rÀ   r⁄   r   r   r~   r~   •  s%   Ü ÄI KOÙCÚ0Ú
/ı07r   r~   c                 ÛH   ï U S-
  nUS-  US-  -   US-  -
  US-  -   [         -
  $ )z8Get the number of days between 1970-01-01 and YEAR-01-01r   Èm  È   Èd   iê  )rà   )rl   ⁄ys     r   ⁄_post_epoch_days_before_yearr¯   ˛  s5   Ä ‡àqâÄAÿàsâ7êQò!ëV—òa†3ôh—&®®c©—1¥L—@–@r   c                   Û,   ï \ rS rSr/ SQrSS jrS rSrg)⁄
_DayOffseti  )⁄d⁄julianrâ   rä   rã   c                 Ûà   ï SU-   nXas=::  a  S::  d  O  [        SU SU 35      eXl        X l        X0l        X@l        XPl        g )Nr   rÙ   zd must be in [z, 365], not: )re   r˚   r¸   râ   rä   rã   )rN   r˚   r¸   râ   rä   rã   ⁄min_days          r   r–   ⁄_DayOffset.__init__  sG   Ä ÿêfë*àÿ’"òs’"‹ò~®g®Y∞m¿A¿3–G”H–H‡åÿåÿå	ÿåÿçr   c                 Û  ï [        U5      nU R                  nU R                  (       a&  US:º  a   [        R                  " U5      (       a  US-  nX#-   S-  nX@R
                  S-  U R                  S-  -   U R                  -   -  nU$ )NÈ;   r   rÑ   rÖ   rÜ   )r¯   r˚   r¸   ⁄calendar⁄isleaprâ   rä   rã   )rN   rl   ⁄days_before_yearr˚   ⁄epochs        r   rÍ   ⁄_DayOffset.year_to_epoch  st   Ä ‹7∏”=–‡èFâFàÿè;è;ò1†õ7§xß¢∞t◊'<—'<ÿêâFàA‡!—%®—.àÿóëòT—!†DßK°K∞"—$4—4∞t∑{±{—B—Bà‡àr   )r˚   râ   r¸   rä   rã   N©ra   r   r   )rí   r≈   r∆   r«   rŸ   r–   rÍ   rÀ   r⁄   r   r   r˙   r˙     s   Ü ⁄;ÄIÙ	ı
r   r˙   c                   Û@   ï \ rS rSr/ SQrSrS	S jr\S 5       rS r	Sr
g)
⁄_CalendarOffseti  )⁄m⁄wr˚   râ   rä   rã   )r`   r   È   r  ÈZ   Èx   Èó   Èµ   È‘   ÈÛ   i  i0  iN  c                 ÛË   ï SUs=::  a  S::  d  O  [        S5      eSUs=::  a  S::  d  O  [        S5      eSUs=::  a  S::  d  O  [        S5      eXl        X l        X0l        X@l        XPl        X`l        g )	Nr   È   zm must be in [1, 12]È   zw must be in [1, 5]r   È   zd must be in [0, 6])re   r
  r  r˚   râ   rä   rã   )rN   r
  r  r˚   râ   rä   rã   s          r   r–   ⁄_CalendarOffset.__init__2  se   Ä ÿêAç|òç|‹–3”4–4‡êAç{òç{‹–2”3–3‡êAç{òç{‹–2”3–3‡åÿåÿåÿå	ÿåÿçr   c                 ÛÑ   ï [        U5      U R                  U   -   US:Ñ  =(       a    [        R                  " U5      -   U-   $ )Nra   )r¯   ⁄_DAYS_BEFORE_MONTHr  r  )r   rl   ⁄month⁄days       r   ⁄_ymd2ord⁄_CalendarOffset._ymd2ordC  sH   Ä Ù )®”.ÿ◊$—$†U—+Ò,‡êqây◊2úXü_ö_®T”2Ò4 Ò	
r   c                 ÛT  ï [         R                  " XR                  5      u  p#U R                  US-   -
  S-  S-   nX@R                  S-
  S-  -  nXC:î  a  US-  nU R                  XR                  U5      nUS-  nX`R                  S-  U R                  S-  -   U R                  -   -  nU$ )z7Calculates the datetime of the occurrence from the yearr   È   rÑ   rÖ   rÜ   )	r  ⁄
monthranger
  r˚   r  r  râ   rä   rã   )rN   rl   ⁄	first_day⁄days_in_month⁄	month_day⁄ordinalr  s          r   rÍ   ⁄_CalendarOffset.year_to_epochM  s´   Ä Ù $,◊#6“#6∞tøVπV”#D— à	 óVëVòy®1ô}—-∞—2∞Q—6à	 	ófëfòqëj†A—%—%à	
 ”$ÿòâNàI‡ó-ë-†ßf°f®i”8àÿò%ëàÿóëòT—!†DßK°K∞"—$4—4∞t∑{±{—B—Bàÿàr   )r˚   râ   r
  rä   rã   r  Nr  )rí   r≈   r∆   r«   rŸ   r  r–   r»   r  rÍ   rÀ   r⁄   r   r   r	  r	    s-   Ü ⁄;ÄI–Ù " Ò
Û 
ır   r	  c                 ÛŒ  ï U R                  SS5      tp[        R                  " S[        R                  [        R                  -  5      nUR                  U5      nUc  [        U  S35      eUR                  S5      nUR                  S5      nS nUR                  S5      nU(       a  UR                  S5      nUR                  S5      =n(       a   [        U5      nOS
nUbm  UR                  S5      =n(       a   [        U5      nOUS-   nU(       d  [        SU  35      eUS
   R                  SS5      n
 S U
 5       u  pº[        XXXgXº5      $ U(       a  [        SU  35      e[        [        U5      [        S
5      U5      $ ! [         a  n	[        S	U  35      U	eS n	A	ff = f! [         a  n	[        SU  35      U	eS n	A	ff = f! [         a  n	[        SU  35      U	eS n	A	ff = f)N⁄,r   a.  
        (?P<std>[^<0-9:.+-]+|<[a-zA-Z0-9+-]+>)
        (?:
            (?P<stdoff>[+-]?\d{1,3}(?::\d{2}(?::\d{2})?)?)
            (?:
                (?P<dst>[^0-9:.+-]+|<[a-zA-Z0-9+-]+>)
                (?P<dstoff>[+-]?\d{1,3}(?::\d{2}(?::\d{2})?)?)?
            )? # dst
        )? # stdoff
        z is not a valid TZ stringr‹   rZ   z<>⁄stdoffzInvalid STD offset in r   rY   zInvalid DST offset in rÖ   zMissing transition rules: c              3   Û8   #   ï U  H  n[        U5      v ï  M     g 7fr   )⁄_parse_dst_start_end)⁄.0⁄xs     r   ⁄	<genexpr>⁄ _parse_tz_str.<locals>.<genexpr>Ø  s   È Ä –J∫>∞a‘.®q◊1–1∫>˘s   ÇzInvalid TZ string: z%Transition rule present without DST: )⁄split⁄re⁄compile⁄ASCII⁄VERBOSE⁄	fullmatchre   ⁄group⁄strip⁄_parse_tz_deltar~   rj   r   )rÆ   ⁄
offset_str⁄start_end_str⁄	parser_rer
  r„   rÂ   rÊ   r‰   ⁄e⁄start_end_strsr›   rﬁ   s                r   r®   r®   o  s  Ä  "(ß°®c∞1”!5–ÄJ‰ó
í
		Ù 	èâîóë—ÛÄI 	◊—òJ”'ÄA‡Åy‹òFò8–#<–=”>–>‡èwâwêuã~ÄHÿèwâwêuã~ÄHÿÄJ‡è~â~òd”#ÄHÊÿó>ë>†$”'à‡óWëWòX”&–&Äz’&	G‹(®”4âJ à
‡—ÿüô†”*–*à:’*K‹,®Z”8ë
 $†d—*àJÊ‹–9∏&∏–B”C–C‡&†q—)◊/—/∞∞Q”7à	DŸJπ>”JâJàEÙ êh®H¿%”M–Mﬁ	‹–@¿¿–I”J–JÙ ‹òJ”'¨∏”);∏XÛ
 	
¯Ù9 Û 	G‹–5∞f∞X–>”?¿Q–F˚	G˚Ù Û K‹ –#9∏&∏–!B”C»–J˚K˚Ù Û 	D‹–2∞6∞(–;”<¿!–C˚	D˙sH   √F √<F% ƒ8G ∆
F"∆F∆F"∆%
G∆/F>∆>G«
G$«G«G$c                 Û∞  ï U R                  SS5      tpUS S nUS:X  ai  Sn[        R                  " SU[        R                  5      nUc  [	        SU  35      e[        [        [        UR                  5       5      5      n[        U6 nO&US:X  a  SnUSS  nOSn[        U5      n[        XÑ5      nU(       a!  [        US	   5      u  Ul        Ul        Ul        U$ )
N⁄/r   ⁄MFzM(\d{1,2})\.(\d).(\d)zInvalid dst start/end date: ⁄JTr   )r/  r0  r4  r2  re   ⁄tuple⁄map⁄int⁄groupsr	  r˙   ⁄_parse_transition_timerâ   rä   rã   )	⁄dststr⁄date⁄time⁄type⁄n_is_julianr
  ⁄date_offset⁄offset⁄doys	            r   r*  r*  Ω  sŒ   Ä ÿó,ë,òs†A”&ÄKÄDÿêêà8ÄDÿàsÉ{ÿà‹èLäL–1∞4ºøπ”Bàÿâ9‹–;∏F∏8–D”E–E‹úC§†QßX°X£Z”0”1à‹ †+–.â‡ê3ã;ÿàKÿòòê8âD‡àK‰ê$ãià‹òC”-àÊ‹4J»4–PQ…7”4S—1àåêVî]†F§M‡ÄMr   c                 Û  ï [         R                  " SU [         R                  5      nUc  [        SU  35      eS UR	                  SSS5       5       u  p#nUS:î  a  [        SU  35      eUR	                  S	5      S
:X  a  U* U* U* pCnX#U4$ )N˙=(?P<sign>[+-])?(?P<h>\d{1,3})(:(?P<m>\d{2})(:(?P<s>\d{2}))?)?zInvalid time: c              3   ÛJ   #   ï U  H  n[        U=(       d    S 5      v ï  M     g7f©r   N©rC  ©r+  ⁄vs     r   r-  ⁄)_parse_transition_time.<locals>.<genexpr>‡  Û   È Ä –?“$>òqåsê1ó6òè{à{“$>˘Û   Ç!#⁄hr
  ⁄sÈß   zHour must be in [0, 167]: ⁄sign⁄-)r0  r4  r2  re   r5  )⁄time_str⁄matchrX  r
  rY  s        r   rE  rE  ◊  sú   Ä ‹èLäLÿHÿ‹
èâÛÄE
 Å}‹ò>®(®–4”5–5·?†EßK°K∞∞S∏#‘$>”?ÅGÄAà!‡à3Éw‹ÿ(®®
–3Û
 	
 á{Å{ê6”òc”!ÿê"êqêbò1ò"àaà‡êà7ÄNr   c                 Û  ï [         R                  " SU [         R                  5      nUc   U 5       eS UR                  SSS5       5       u  p#nUS-  US-  -   U-   nUS:î  a  [	        S	U  35      eUR                  S
5      S:w  a  U* nU$ )NrO  c              3   ÛJ   #   ï U  H  n[        U=(       d    S 5      v ï  M     g7frQ  rR  rS  s     r   r-  ⁄"_parse_tz_delta.<locals>.<genexpr>˜  rV  rW  rX  r
  rY  rÖ   rÜ   È   z!Offset hours must be in [0, 24]: r[  r\  )r0  r4  r2  r5  re   )⁄tz_deltar^  rX  r
  rY  ⁄totals         r   r7  r7  Ì  sü   Ä ‹èLäLÿHÿ‹
èâÛÄE —–&òh”&–·?†EßK°K∞∞S∏#‘$>”?ÅGÄAà!‡êâHêqò2ëv—†—!ÄE‡à2Év‹ÿ/∞®z–:Û
 	

 á{Å{ê6”òc”!ÿêà‡ÄLr   )rm   r  r   ⁄	functoolsr0  r   r   r   r   ⁄ r   r   ⁄EPOCHrá   rà   ⁄	lru_cacher   r   rj   r|   r~   r¯   r˙   r	  r®   r*  rE  r7  r⁄   r   r   ⁄<module>ri     sÕ   € € € € € 	€ ﬂ 0— 0Á ·êêqò!”ÄŸòòa†”#◊-—-”/Ä ◊“òS—!Ò&Û "&ÙkàvÙ k˜\
Ò 
Ò, êTò4†”&Ä
˜V7Ò V7ÚrA˜Ò ˜6MÒ MÚ`K
Ú\Ú4Û,r                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               import struct


def load_tzdata(key):
    from importlib import resources

    components = key.split("/")
    package_name = ".".join(["tzdata.zoneinfo"] + components[:-1])
    resource_name = components[-1]

    try:
        return resources.files(package_name).joinpath(resource_name).open("rb")
    except (ImportError, FileNotFoundError, UnicodeEncodeError):
        # There are three types of exception that can be raised that all amount
        # to "we cannot find this key":
        #
        # ImportError: If package_name doesn't exist (e.g. if tzdata is not
        #   installed, or if there's an error in the folder name like
        #   Amrica/New_York)
        # FileNotFoundError: If resource_name doesn't exist in the package
        #   (e.g. Europe/Krasnoy)
        # UnicodeEncodeError: If package_name or resource_name are not UTF-8,
        #   such as keys containing a surrogate character.
        raise ZoneInfoNotFoundError(f"No time zone found with key {key}")


def load_data(fobj):
    header = _TZifHeader.from_file(fobj)

    if header.version == 1:
        time_size = 4
        time_type = "l"
    else:
        # Version 2+ has 64-bit integer transition times
        time_size = 8
        time_type = "q"

        # Version 2+ also starts with a Version 1 header and data, which
        # we need to skip now
        skip_bytes = (
            header.timecnt * 5  # Transition times and types
            + header.typecnt * 6  # Local time type records
            + header.charcnt  # Time zone designations
            + header.leapcnt * 8  # Leap second records
            + header.isstdcnt  # Standard/wall indicators
            + header.isutcnt  # UT/local indicators
        )

        fobj.seek(skip_bytes, 1)

        # Now we need to read the second header, which is not the same
        # as the first
        header = _TZifHeader.from_file(fobj)

    typecnt = header.typecnt
    timecnt = header.timecnt
    charcnt = header.charcnt

    # The data portion starts with timecnt transitions and indices
    if timecnt:
        trans_list_utc = struct.unpack(
            f">{timecnt}{time_type}", fobj.read(timecnt * time_size)
        )
        trans_idx = struct.unpack(f">{timecnt}B", fobj.read(timecnt))
    else:
        trans_list_utc = ()
        trans_idx = ()

    # Read the ttinfo struct, (utoff, isdst, abbrind)
    if typecnt:
        utcoff, isdst, abbrind = zip(
            *(struct.unpack(">lbb", fobj.read(6)) for i in range(typecnt))
        )
    else:
        utcoff = ()
        isdst = ()
        abbrind = ()

    # Now read the abbreviations. They are null-terminated strings, indexed
    # not by position in the array but by position in the unsplit
    # abbreviation string. I suppose this makes more sense in C, which uses
    # null to terminate the strings, but it's inconvenient here...
    abbr_vals = {}
    abbr_chars = fobj.read(charcnt)

    def get_abbr(idx):
        # Gets a string starting at idx and running until the next \x00
        #
        # We cannot pre-populate abbr_vals by splitting on \x00 because there
        # are some zones that use subsets of longer abbreviations, like so:
        #
        #  LMT\x00AHST\x00HDT\x00
        #
        # Where the idx to abbr mapping should be:
        #
        # {0: "LMT", 4: "AHST", 5: "HST", 9: "HDT"}
        if idx not in abbr_vals:
            span_end = abbr_chars.find(b"\x00", idx)
            abbr_vals[idx] = abbr_chars[idx:span_end].decode()

        return abbr_vals[idx]

    abbr = tuple(get_abbr(idx) for idx in abbrind)

    # The remainder of the file consists of leap seconds (currently unused) and
    # the standard/wall and ut/local indicators, which are metadata we don't need.
    # In version 2 files, we need to skip the unnecessary data to get at the TZ string:
    if header.version >= 2:
        # Each leap second record has size (time_size + 4)
        skip_bytes = header.isutcnt + header.isstdcnt + header.leapcnt * 12
        fobj.seek(skip_bytes, 1)

        c = fobj.read(1)  # Should be \n
        assert c == b"\n", c

        tz_bytes = b""
        while (c := fobj.read(1)) != b"\n":
            tz_bytes += c

        tz_str = tz_bytes
    else:
        tz_str = None

    return trans_idx, trans_list_utc, utcoff, isdst, abbr, tz_str


class _TZifHeader:
    __slots__ = [
        "version",
        "isutcnt",
        "isstdcnt",
        "leapcnt",
        "timecnt",
        "typecnt",
        "charcnt",
    ]

    def __init__(self, *args):
        for attr, val in zip(self.__slots__, args, strict=True):
            setattr(self, attr, val)

    @classmethod
    def from_file(cls, stream):
        # The header starts with a 4-byte "magic" value
        if stream.read(4) != b"TZif":
            raise ValueError("Invalid TZif file: magic not found")

        _version = stream.read(1)
        if _version == b"\x00":
            version = 1
        else:
            version = int(_version)
        stream.read(15)

        args = (version,)

        # Slots are defined in the order that the bytes are arranged
        args = args + struct.unpack(">6l", stream.read(24))

        return cls(*args)


class ZoneInfoNotFoundError(KeyError):
    """Exception raised when a ZoneInfo key is not found."""
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  import os
import sysconfig


def _reset_tzpath(to=None, stacklevel=4):
    global TZPATH

    tzpaths = to
    if tzpaths is not None:
        if isinstance(tzpaths, (str, bytes)):
            raise TypeError(
                f"tzpaths must be a list or tuple, "
                + f"not {type(tzpaths)}: {tzpaths!r}"
            )

        if not all(map(os.path.isabs, tzpaths)):
            raise ValueError(_get_invalid_paths_message(tzpaths))
        base_tzpath = tzpaths
    else:
        env_var = os.environ.get("PYTHONTZPATH", None)
        if env_var is None:
            env_var = sysconfig.get_config_var("TZPATH")
        base_tzpath = _parse_python_tzpath(env_var, stacklevel)

    TZPATH = tuple(base_tzpath)


def reset_tzpath(to=None):
    """Reset global TZPATH."""
    # We need `_reset_tzpath` helper function because it produces a warning,
    # it is used as both a module-level call and a public API.
    # This is how we equalize the stacklevel for both calls.
    _reset_tzpath(to)


def _parse_python_tzpath(env_var, stacklevel):
    if not env_var:
        return ()

    raw_tzpath = env_var.split(os.pathsep)
    new_tzpath = tuple(filter(os.path.isabs, raw_tzpath))

    # If anything has been filtered out, we will warn about it
    if len(new_tzpath) != len(raw_tzpath):
        import warnings

        msg = _get_invalid_paths_message(raw_tzpath)

        warnings.warn(
            "Invalid paths specified in PYTHONTZPATH environment variable. "
            + msg,
            InvalidTZPathWarning,
            stacklevel=stacklevel,
        )

    return new_tzpath


def _get_invalid_paths_message(tzpaths):
    invalid_paths = (path for path in tzpaths if not os.path.isabs(path))

    prefix = "\n    "
    indented_str = prefix + prefix.join(invalid_paths)

    return (
        "Paths should be absolute but found the following relative paths:"
        + indented_str
    )


def find_tzfile(key):
    """Retrieve the path to a TZif file from a key."""
    _validate_tzfile_path(key)
    for search_path in TZPATH:
        filepath = os.path.join(search_path, key)
        if os.path.isfile(filepath):
            return filepath

    return None


_TEST_PATH = os.path.normpath(os.path.join("_", "_"))[:-1]


def _validate_tzfile_path(path, _base=_TEST_PATH):
    if os.path.isabs(path):
        raise ValueError(
            f"ZoneInfo keys may not be absolute paths, got: {path}"
        )

    # We only care about the kinds of path normalizations that would change the
    # length of the key - e.g. a/../b -> a/b, or a/b/ -> a/b. On Windows,
    # normpath will also change from a/b to a\b, but that would still preserve
    # the length.
    new_path = os.path.normpath(path)
    if len(new_path) != len(path):
        raise ValueError(
            f"ZoneInfo keys must be normalized relative paths, got: {path}"
        )

    resolved = os.path.normpath(os.path.join(_base, new_path))
    if not resolved.startswith(_base):
        raise ValueError(
            f"ZoneInfo keys must refer to subdirectories of TZPATH, got: {path}"
        )


del _TEST_PATH


def available_timezones():
    """Returns a set containing all available time zones.

    .. caution::

        This may attempt to open a large number of files, since the best way to
        determine if a given file on the time zone search path is to open it
        and check for the "magic string" at the beginning.
    """
    from importlib import resources

    valid_zones = set()

    # Start with loading from the tzdata package if it exists: this has a
    # pre-assembled list of zones that only requires opening one file.
    try:
        with resources.files("tzdata").joinpath("zones").open("r") as f:
            for zone in f:
                zone = zone.strip()
                if zone:
                    valid_zones.add(zone)
    except (ImportError, FileNotFoundError):
        pass

    def valid_key(fpath):
        try:
            with open(fpath, "rb") as f:
                return f.read(4) == b"TZif"
        except Exception:  # pragma: nocover
            return False

    for tz_root in TZPATH:
        if not os.path.exists(tz_root):
            continue

        for root, dirnames, files in os.walk(tz_root):
            if root == tz_root:
                # right/ and posix/ are special directories and shouldn't be
                # included in the output of available zones
                if "right" in dirnames:
                    dirnames.remove("right")
                if "posix" in dirnames:
                    dirnames.remove("posix")

            for file in files:
                fpath = os.path.join(root, file)

                key = os.path.relpath(fpath, start=tz_root)
                if os.sep != "/":  # pragma: nocover
                    key = key.replace(os.sep, "/")

                if not key or key in valid_zones:
                    continue

                if valid_key(fpath):
                    valid_zones.add(key)

    if "posixrules" in valid_zones:
        # posixrules is a special symlink-only time zone where it exists, it
        # should not be included in the output
        valid_zones.remove("posixrules")

    return valid_zones


class InvalidTZPathWarning(RuntimeWarning):
    """Warning raised if an invalid path is specified in PYTHONTZPATH."""


TZPATH = ()
_reset_tzpath(stacklevel=5)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    import bisect
import calendar
import collections
import functools
import re
import weakref
from datetime import datetime, timedelta, tzinfo

from . import _common, _tzpath

EPOCH = datetime(1970, 1, 1)
EPOCHORDINAL = datetime(1970, 1, 1).toordinal()

# It is relatively expensive to construct new timedelta objects, and in most
# cases we're looking at the same deltas, like integer numbers of hours, etc.
# To improve speed and memory use, we'll keep a dictionary with references
# to the ones we've already used so far.
#
# Loading every time zone in the 2020a version of the time zone database
# requires 447 timedeltas, which requires approximately the amount of space
# that ZoneInfo("America/New_York") with 236 transitions takes up, so we will
# set the cache size to 512 so that in the common case we always get cache
# hits, but specifically crafted ZoneInfo objects don't leak arbitrary amounts
# of memory.
@functools.lru_cache(maxsize=512)
def _load_timedelta(seconds):
    return timedelta(seconds=seconds)


class ZoneInfo(tzinfo):
    _strong_cache_size = 8
    _strong_cache = collections.OrderedDict()
    _weak_cache = weakref.WeakValueDictionary()
    __module__ = "zoneinfo"

    def __init_subclass__(cls):
        cls._strong_cache = collections.OrderedDict()
        cls._weak_cache = weakref.WeakValueDictionary()

    def __new__(cls, key):
        instance = cls._weak_cache.get(key, None)
        if instance is None:
            instance = cls._weak_cache.setdefault(key, cls._new_instance(key))
            instance._from_cache = True

        # Update the "strong" cache
        cls._strong_cache[key] = cls._strong_cache.pop(key, instance)

        if len(cls._strong_cache) > cls._strong_cache_size:
            cls._strong_cache.popitem(last=False)

        return instance

    @classmethod
    def no_cache(cls, key):
        obj = cls._new_instance(key)
        obj._from_cache = False

        return obj

    @classmethod
    def _new_instance(cls, key):
        obj = super().__new__(cls)
        obj._key = key
        obj._file_path = obj._find_tzfile(key)

        if obj._file_path is not None:
            file_obj = open(obj._file_path, "rb")
        else:
            file_obj = _common.load_tzdata(key)

        with file_obj as f:
            obj._load_file(f)

        return obj

    @classmethod
    def from_file(cls, fobj, /, key=None):
        obj = super().__new__(cls)
        obj._key = key
        obj._file_path = None
        obj._load_file(fobj)
        obj._file_repr = repr(fobj)

        # Disable pickling for objects created from files
        obj.__reduce__ = obj._file_reduce

        return obj

    @classmethod
    def clear_cache(cls, *, only_keys=None):
        if only_keys is not None:
            for key in only_keys:
                cls._weak_cache.pop(key, None)
                cls._strong_cache.pop(key, None)

        else:
            cls._weak_cache.clear()
            cls._strong_cache.clear()

    @property
    def key(self):
        return self._key

    def utcoffset(self, dt):
        return self._find_trans(dt).utcoff

    def dst(self, dt):
        return self._find_trans(dt).dstoff

    def tzname(self, dt):
        return self._find_trans(dt).tzname

    def fromutc(self, dt):
        """Convert from datetime in UTC to datetime in local time"""

        if not isinstance(dt, datetime):
            raise TypeError("fromutc() requires a datetime argument")
        if dt.tzinfo is not self:
            raise ValueError("dt.tzinfo is not self")

        timestamp = self._get_local_timestamp(dt)
        num_trans = len(self._trans_utc)

        if num_trans >= 1 and timestamp < self._trans_utc[0]:
            tti = self._tti_before
            fold = 0
        elif (
            num_trans == 0 or timestamp > self._trans_utc[-1]
        ) and not isinstance(self._tz_after, _ttinfo):
            tti, fold = self._tz_after.get_trans_info_fromutc(
                timestamp, dt.year
            )
        elif num_trans == 0:
            tti = self._tz_after
            fold = 0
        else:
            idx = bisect.bisect_right(self._trans_utc, timestamp)

            if num_trans > 1 and timestamp >= self._trans_utc[1]:
                tti_prev, tti = self._ttinfos[idx - 2 : idx]
            elif timestamp > self._trans_utc[-1]:
                tti_prev = self._ttinfos[-1]
                tti = self._tz_after
            else:
                tti_prev = self._tti_before
                tti = self._ttinfos[0]

            # Detect fold
            shift = tti_prev.utcoff - tti.utcoff
            fold = shift.total_seconds() > timestamp - self._trans_utc[idx - 1]
        dt += tti.utcoff
        if fold:
            return dt.replace(fold=1)
        else:
            return dt

    def _find_trans(self, dt):
        if dt is None:
            if self._fixed_offset:
                return self._tz_after
            else:
                return _NO_TTINFO

        ts = self._get_local_timestamp(dt)

        lt = self._trans_local[dt.fold]

        num_trans = len(lt)

        if num_trans and ts < lt[0]:
            return self._tti_before
        elif not num_trans or ts > lt[-1]:
            if isinstance(self._tz_after, _TZStr):
                return self._tz_after.get_trans_info(ts, dt.year, dt.fold)
            else:
                return self._tz_after
        else:
            # idx is the transition that occurs after this timestamp, so we
            # subtract off 1 to get the current ttinfo
            idx = bisect.bisect_right(lt, ts) - 1
            assert idx >= 0
            return self._ttinfos[idx]

    def _get_local_timestamp(self, dt):
        return (
            (dt.toordinal() - EPOCHORDINAL) * 86400
            + dt.hour * 3600
            + dt.minute * 60
            + dt.second
        )

    def __str__(self):
        if self._key is not None:
            return f"{self._key}"
        else:
            return repr(self)

    def __repr__(self):
        if self._key is not None:
            return f"{self.__class__.__name__}(key={self._key!r})"
        else:
            return f"{self.__class__.__name__}.from_file({self._file_repr})"

    def __reduce__(self):
        return (self.__class__._unpickle, (self._key, self._from_cache))

    def _file_reduce(self):
        import pickle

        raise pickle.PicklingError(
            "Cannot pickle a ZoneInfo file created from a file stream."
        )

    @classmethod
    def _unpickle(cls, key, from_cache, /):
        if from_cache:
            return cls(key)
        else:
            return cls.no_cache(key)

    def _find_tzfile(self, key):
        return _tzpath.find_tzfile(key)

    def _load_file(self, fobj):
        # Retrieve all the data as it exists in the zoneinfo file
        trans_idx, trans_utc, utcoff, isdst, abbr, tz_str = _common.load_data(
            fobj
        )

        # Infer the DST offsets (needed for .dst()) from the data
        dstoff = self._utcoff_to_dstoff(trans_idx, utcoff, isdst)

        # Convert all the transition times (UTC) into "seconds since 1970-01-01 local time"
        trans_local = self._ts_to_local(trans_idx, trans_utc, utcoff)

        # Construct `_ttinfo` objects for each transition in the file
        _ttinfo_list = [
            _ttinfo(
                _load_timedelta(utcoffset), _load_timedelta(dstoffset), tzname
            )
            for utcoffset, dstoffset, tzname in zip(utcoff, dstoff, abbr)
        ]

        self._trans_utc = trans_utc
        self._trans_local = trans_local
        self._ttinfos = [_ttinfo_list[idx] for idx in trans_idx]

        # Find the first non-DST transition
        for i in range(len(isdst)):
            if not isdst[i]:
                self._tti_before = _ttinfo_list[i]
                break
        else:
            if self._ttinfos:
                self._tti_before = self._ttinfos[0]
            else:
                self._tti_before = None

        # Set the "fallback" time zone
        if tz_str is not None and tz_str != b"":
            self._tz_after = _parse_tz_str(tz_str.decode())
        else:
            if not self._ttinfos and not _ttinfo_list:
                raise ValueError("No time zone information found.")

            if self._ttinfos:
                self._tz_after = self._ttinfos[-1]
            else:
                self._tz_after = _ttinfo_list[-1]

        # Determine if this is a "fixed offset" zone, meaning that the output
        # of the utcoffset, dst and tzname functions does not depend on the
        # specific datetime passed.
        #
        # We make three simplifying assumptions here:
        #
        # 1. If _tz_after is not a _ttinfo, it has transitions that might
        #    actually occur (it is possible to construct TZ strings that
        #    specify STD and DST but no transitions ever occur, such as
        #    AAA0BBB,0/0,J365/25).
        # 2. If _ttinfo_list contains more than one _ttinfo object, the objects
        #    represent different offsets.
        # 3. _ttinfo_list contains no unused _ttinfos (in which case an
        #    otherwise fixed-offset zone with extra _ttinfos defined may
        #    appear to *not* be a fixed offset zone).
        #
        # Violations to these assumptions would be fairly exotic, and exotic
        # zones should almost certainly not be used with datetime.time (the
        # only thing that would be affected by this).
        if len(_ttinfo_list) > 1 or not isinstance(self._tz_after, _ttinfo):
            self._fixed_offset = False
        elif not _ttinfo_list:
            self._fixed_offset = True
        else:
            self._fixed_offset = _ttinfo_list[0] == self._tz_after

    @staticmethod
    def _utcoff_to_dstoff(trans_idx, utcoffsets, isdsts):
        # Now we must transform our ttis and abbrs into `_ttinfo` objects,
        # but there is an issue: .dst() must return a timedelta with the
        # difference between utcoffset() and the "standard" offset, but
        # the "base offset" and "DST offset" are not encoded in the file;
        # we can infer what they are from the isdst flag, but it is not
        # sufficient to just look at the last standard offset, because
        # occasionally countries will shift both DST offset and base offset.

        typecnt = len(isdsts)
        dstoffs = [0] * typecnt  # Provisionally assign all to 0.
        dst_cnt = sum(isdsts)
        dst_found = 0

        for i in range(1, len(trans_idx)):
            if dst_cnt == dst_found:
                break

            idx = trans_idx[i]

            dst = isdsts[idx]

            # We're only going to look at daylight saving time
            if not dst:
                continue

            # Skip any offsets that have already been assigned
            if dstoffs[idx] != 0:
                continue

            dstoff = 0
            utcoff = utcoffsets[idx]

            comp_idx = trans_idx[i - 1]

            if not isdsts[comp_idx]:
                dstoff = utcoff - utcoffsets[comp_idx]

            if not dstoff and idx < (typecnt - 1):
                comp_idx = trans_idx[i + 1]

                # If the following transition is also DST and we couldn't
                # find the DST offset by this point, we're going to have to
                # skip it and hope this transition gets assigned later
                if isdsts[comp_idx]:
                    continue

                dstoff = utcoff - utcoffsets[comp_idx]

            if dstoff:
                dst_found += 1
                dstoffs[idx] = dstoff
        else:
            # If we didn't find a valid value for a given index, we'll end up
            # with dstoff = 0 for something where `isdst=1`. This is obviously
            # wrong - one hour will be a much better guess than 0
            for idx in range(typecnt):
                if not dstoffs[idx] and isdsts[idx]:
                    dstoffs[idx] = 3600

        return dstoffs

    @staticmethod
    def _ts_to_local(trans_idx, trans_list_utc, utcoffsets):
        """Generate number of seconds since 1970 *in the local time*.

        This is necessary to easily find the transition times in local time"""
        if not trans_list_utc:
            return [[], []]

        # Start with the timestamps and modify in-place
        trans_list_wall = [list(trans_list_utc), list(trans_list_utc)]

        if len(utcoffsets) > 1:
            offset_0 = utcoffsets[0]
            offset_1 = utcoffsets[trans_idx[0]]
            if offset_1 > offset_0:
                offset_1, offset_0 = offset_0, offset_1
        else:
            offset_0 = offset_1 = utcoffsets[0]

        trans_list_wall[0][0] += offset_0
        trans_list_wall[1][0] += offset_1

        for i in range(1, len(trans_idx)):
            offset_0 = utcoffsets[trans_idx[i - 1]]
            offset_1 = utcoffsets[trans_idx[i]]

            if offset_1 > offset_0:
                offset_1, offset_0 = offset_0, offset_1

            trans_list_wall[0][i] += offset_0
            trans_list_wall[1][i] += offset_1

        return trans_list_wall


class _ttinfo:
    __slots__ = ["utcoff", "dstoff", "tzname"]

    def __init__(self, utcoff, dstoff, tzname):
        self.utcoff = utcoff
        self.dstoff = dstoff
        self.tzname = tzname

    def __eq__(self, other):
        return (
            self.utcoff == other.utcoff
            and self.dstoff == other.dstoff
            and self.tzname == other.tzname
        )

    def __repr__(self):  # pragma: nocover
        return (
            f"{self.__class__.__name__}"
            + f"({self.utcoff}, {self.dstoff}, {self.tzname})"
        )


_NO_TTINFO = _ttinfo(None, None, None)


class _TZStr:
    __slots__ = (
        "std",
        "dst",
        "start",
        "end",
        "get_trans_info",
        "get_trans_info_fromutc",
        "dst_diff",
    )

    def __init__(
        self, std_abbr, std_offset, dst_abbr, dst_offset, start=None, end=None
    ):
        self.dst_diff = dst_offset - std_offset
        std_offset = _load_timedelta(std_offset)
        self.std = _ttinfo(
            utcoff=std_offset, dstoff=_load_timedelta(0), tzname=std_abbr
        )

        self.start = start
        self.end = end

        dst_offset = _load_timedelta(dst_offset)
        delta = _load_timedelta(self.dst_diff)
        self.dst = _ttinfo(utcoff=dst_offset, dstoff=delta, tzname=dst_abbr)

        # These are assertions because the constructor should only be called
        # by functions that would fail before passing start or end
        assert start is not None, "No transition start specified"
        assert end is not None, "No transition end specified"

        self.get_trans_info = self._get_trans_info
        self.get_trans_info_fromutc = self._get_trans_info_fromutc

    def transitions(self, year):
        start = self.start.year_to_epoch(year)
        end = self.end.year_to_epoch(year)
        return start, end

    def _get_trans_info(self, ts, year, fold):
        """Get the information about the current transition - tti"""
        start, end = self.transitions(year)

        # With fold = 0, the period (denominated in local time) with the
        # smaller offset starts at the end of the gap and ends at the end of
        # the fold; with fold = 1, it runs from the start of the gap to the
        # beginning of the fold.
        #
        # So in order to determine the DST boundaries we need to know both
        # the fold and whether DST is positive or negative (rare), and it
        # turns out that this boils down to fold XOR is_positive.
        if fold == (self.dst_diff >= 0):
            end -= self.dst_diff
        else:
            start += self.dst_diff

        if start < end:
            isdst = start <= ts < end
        else:
            isdst = not (end <= ts < start)

        return self.dst if isdst else self.std

    def _get_trans_info_fromutc(self, ts, year):
        start, end = self.transitions(year)
        start -= self.std.utcoff.total_seconds()
        end -= self.dst.utcoff.total_seconds()

        if start < end:
            isdst = start <= ts < end
        else:
            isdst = not (end <= ts < start)

        # For positive DST, the ambiguous period is one dst_diff after the end
        # of DST; for negative DST, the ambiguous period is one dst_diff before
        # the start of DST.
        if self.dst_diff > 0:
            ambig_start = end
            ambig_end = end + self.dst_diff
        else:
            ambig_start = start
            ambig_end = start - self.dst_diff

        fold = ambig_start <= ts < ambig_end

        return (self.dst if isdst else self.std, fold)


def _post_epoch_days_before_year(year):
    """Get the number of days between 1970-01-01 and YEAR-01-01"""
    y = year - 1
    return y * 365 + y // 4 - y // 100 + y // 400 - EPOCHORDINAL


class _DayOffset:
    __slots__ = ["d", "julian", "hour", "minute", "second"]

    def __init__(self, d, julian, hour=2, minute=0, second=0):
        min_day = 0 + julian  # convert bool to int
        if not min_day <= d <= 365:
            raise ValueError(f"d must be in [{min_day}, 365], not: {d}")

        self.d = d
        self.julian = julian
        self.hour = hour
        self.minute = minute
        self.second = second

    def year_to_epoch(self, year):
        days_before_year = _post_epoch_days_before_year(year)

        d = self.d
        if self.julian and d >= 59 and calendar.isleap(year):
            d += 1

        epoch = (days_before_year + d) * 86400
        epoch += self.hour * 3600 + self.minute * 60 + self.second

        return epoch


class _CalendarOffset:
    __slots__ = ["m", "w", "d", "hour", "minute", "second"]

    _DAYS_BEFORE_MONTH = (
        -1,
        0,
        31,
        59,
        90,
        120,
        151,
        181,
        212,
        243,
        273,
        304,
        334,
    )

    def __init__(self, m, w, d, hour=2, minute=0, second=0):
        if not 1 <= m <= 12:
            raise ValueError("m must be in [1, 12]")

        if not 1 <= w <= 5:
            raise ValueError("w must be in [1, 5]")

        if not 0 <= d <= 6:
            raise ValueError("d must be in [0, 6]")

        self.m = m
        self.w = w
        self.d = d
        self.hour = hour
        self.minute = minute
        self.second = second

    @classmethod
    def _ymd2ord(cls, year, month, day):
        return (
            _post_epoch_days_before_year(year)
            + cls._DAYS_BEFORE_MONTH[month]
            + (month > 2 and calendar.isleap(year))
            + day
        )

    # TODO: These are not actually epoch dates as they are expressed in local time
    def year_to_epoch(self, year):
        """Calculates the datetime of the occurrence from the year"""
        # We know year and month, we need to convert w, d into day of month
        #
        # Week 1 is the first week in which day `d` (where 0 = Sunday) appears.
        # Week 5 represents the last occurrence of day `d`, so we need to know
        # the range of the month.
        first_day, days_in_month = calendar.monthrange(year, self.m)

        # This equation seems magical, so I'll break it down:
        # 1. calendar says 0 = Monday, POSIX says 0 = Sunday
        #    so we need first_day + 1 to get 1 = Monday -> 7 = Sunday,
        #    which is still equivalent because this math is mod 7
        # 2. Get first day - desired day mod 7: -1 % 7 = 6, so we don't need
        #    to do anything to adjust negative numbers.
        # 3. Add 1 because month days are a 1-based index.
        month_day = (self.d - (first_day + 1)) % 7 + 1

        # Now use a 0-based index version of `w` to calculate the w-th
        # occurrence of `d`
        month_day += (self.w - 1) * 7

        # month_day will only be > days_in_month if w was 5, and `w` means
        # "last occurrence of `d`", so now we just check if we over-shot the
        # end of the month and if so knock off 1 week.
        if month_day > days_in_month:
            month_day -= 7

        ordinal = self._ymd2ord(year, self.m, month_day)
        epoch = ordinal * 86400
        epoch += self.hour * 3600 + self.minute * 60 + self.second
        return epoch


def _parse_tz_str(tz_str):
    # The tz string has the format:
    #
    # std[offset[dst[offset],start[/time],end[/time]]]
    #
    # std and dst must be 3 or more characters long and must not contain
    # a leading colon, embedded digits, commas, nor a plus or minus signs;
    # The spaces between "std" and "offset" are only for display and are
    # not actually present in the string.
    #
    # The format of the offset is ``[+|-]hh[:mm[:ss]]``

    offset_str, *start_end_str = tz_str.split(",", 1)

    parser_re = re.compile(
        r"""
        (?P<std>[^<0-9:.+-]+|<[a-zA-Z0-9+-]+>)
        (?:
            (?P<stdoff>[+-]?\d{1,3}(?::\d{2}(?::\d{2})?)?)
            (?:
                (?P<dst>[^0-9:.+-]+|<[a-zA-Z0-9+-]+>)
                (?P<dstoff>[+-]?\d{1,3}(?::\d{2}(?::\d{2})?)?)?
            )? # dst
        )? # stdoff
        """,
        re.ASCII|re.VERBOSE
    )

    m = parser_re.fullmatch(offset_str)

    if m is None:
        raise ValueError(f"{tz_str} is not a valid TZ string")

    std_abbr = m.group("std")
    dst_abbr = m.group("dst")
    dst_offset = None

    std_abbr = std_abbr.strip("<>")

    if dst_abbr:
        dst_abbr = dst_abbr.strip("<>")

    if std_offset := m.group("stdoff"):
        try:
            std_offset = _parse_tz_delta(std_offset)
        except ValueError as e:
            raise ValueError(f"Invalid STD offset in {tz_str}") from e
    else:
        std_offset = 0

    if dst_abbr is not None:
        if dst_offset := m.group("dstoff"):
            try:
                dst_offset = _parse_tz_delta(dst_offset)
            except ValueError as e:
                raise ValueError(f"Invalid DST offset in {tz_str}") from e
        else:
            dst_offset = std_offset + 3600

        if not start_end_str:
            raise ValueError(f"Missing transition rules: {tz_str}")

        start_end_strs = start_end_str[0].split(",", 1)
        try:
            start, end = (_parse_dst_start_end(x) for x in start_end_strs)
        except ValueError as e:
            raise ValueError(f"Invalid TZ string: {tz_str}") from e

        return _TZStr(std_abbr, std_offset, dst_abbr, dst_offset, start, end)
    elif start_end_str:
        raise ValueError(f"Transition rule present without DST: {tz_str}")
    else:
        # This is a static ttinfo, don't return _TZStr
        return _ttinfo(
            _load_timedelta(std_offset), _load_timedelta(0), std_abbr
        )


def _parse_dst_start_end(dststr):
    date, *time = dststr.split("/", 1)
    type = date[:1]
    if type == "M":
        n_is_julian = False
        m = re.fullmatch(r"M(\d{1,2})\.(\d).(\d)", date, re.ASCII)
        if m is None:
            raise ValueError(f"Invalid dst start/end date: {dststr}")
        date_offset = tuple(map(int, m.groups()))
        offset = _CalendarOffset(*date_offset)
    else:
        if type == "J":
            n_is_julian = True
            date = date[1:]
        else:
            n_is_julian = False

        doy = int(date)
        offset = _DayOffset(doy, n_is_julian)

    if time:
        offset.hour, offset.minute, offset.second = _parse_transition_time(time[0])

    return offset


def _parse_transition_time(time_str):
    match = re.fullmatch(
        r"(?P<sign>[+-])?(?P<h>\d{1,3})(:(?P<m>\d{2})(:(?P<s>\d{2}))?)?",
        time_str,
        re.ASCII
    )
    if match is None:
        raise ValueError(f"Invalid time: {time_str}")

    h, m, s = (int(v or 0) for v in match.group("h", "m", "s"))

    if h > 167:
        raise ValueError(
            f"Hour must be in [0, 167]: {time_str}"
        )

    if match.group("sign") == "-":
        h, m, s = -h, -m, -s

    return h, m, s


def _parse_tz_delta(tz_delta):
    match = re.fullmatch(
        r"(?P<sign>[+-])?(?P<h>\d{1,3})(:(?P<m>\d{2})(:(?P<s>\d{2}))?)?",
        tz_delta,
        re.ASCII
    )
    # Anything passed to this function should already have hit an equivalent
    # regular expression to find the section to parse.
    assert match is not None, tz_delta

    h, m, s = (int(v or 0) for v in match.group("h", "m", "s"))

    total = h * 3600 + m * 60 + s

    if h > 24:
        raise ValueError(
            f"Offset hours must be in [0, 24]: {tz_delta}"
        )

    # Yes, +5 maps to an offset of -5h
    if match.group("sign") != "-":
        total = -total

    return total
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              B   .   î  Ù..                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          C   .   î   ..  D   cert.pemE   certs   F   miscJ   openssl.cnf K  ®private                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         F   .   C   ..  G   CA.pl   H   tsget   I  »tsget.pl                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        