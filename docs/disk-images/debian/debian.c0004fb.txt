      if limit < 0:
            # Shortcut common case - newline found in buffer.
            i = self._readbuffer.find(b'\n', self._offset) + 1
            if i > 0:
                line = self._readbuffer[self._offset: i]
                self._offset = i
                return line

        return io.BufferedIOBase.readline(self, limit)

    def peek(self, n=1):
        """Returns buffered bytes without advancing the position."""
        if n > len(self._readbuffer) - self._offset:
            chunk = self.read(n)
            if len(chunk) > self._offset:
                self._readbuffer = chunk + self._readbuffer[self._offset:]
                self._offset = 0
            else:
                self._offset -= len(chunk)

        # Return up to 512 bytes to reduce allocation overhead for tight loops.
        return self._readbuffer[self._offset: self._offset + 512]

    def readable(self):
        if self.closed:
            raise ValueError("I/O operation on closed file.")
        return True

    def read(self, n=-1):
        """Read and return up to n bytes.
        If the argument is omitted, None, or negative, data is read and returned until EOF is reached.
        """
        if self.closed:
            raise ValueError("read from closed file.")
        if n is None or n < 0:
            buf = self._readbuffer[self._offset:]
            self._readbuffer = b''
            self._offset = 0
            while not self._eof:
                buf += self._read1(self.MAX_N)
            return buf

        end = n + self._offset
        if end < len(self._readbuffer):
            buf = self._readbuffer[self._offset:end]
            self._offset = end
            return buf

        n = end - len(self._readbuffer)
        buf = self._readbuffer[self._offset:]
        self._readbuffer = b''
        self._offset = 0
        while n > 0 and not self._eof:
            data = self._read1(n)
            if n < len(data):
                self._readbuffer = data
                self._offset = n
                buf += data[:n]
                break
            buf += data
            n -= len(data)
        return buf

    def _update_crc(self, newdata):
        # Update the CRC using the given data.
        if self._expected_crc is None:
            # No need to compute the CRC if we don't have a reference value
            return
        self._running_crc = crc32(newdata, self._running_crc)
        # Check the CRC if we're at the end of the file
        if self._eof and self._running_crc != self._expected_crc:
            raise BadZipFile("Bad CRC-32 for file %r" % self.name)

    def read1(self, n):
        """Read up to n bytes with at most one read() system call."""

        if n is None or n < 0:
            buf = self._readbuffer[self._offset:]
            self._readbuffer = b''
            self._offset = 0
            while not self._eof:
                data = self._read1(self.MAX_N)
                if data:
                    buf += data
                    break
            return buf

        end = n + self._offset
        if end < len(self._readbuffer):
            buf = self._readbuffer[self._offset:end]
            self._offset = end
            return buf

        n = end - len(self._readbuffer)
        buf = self._readbuffer[self._offset:]
        self._readbuffer = b''
        self._offset = 0
        if n > 0:
            while not self._eof:
                data = self._read1(n)
                if n < len(data):
                    self._readbuffer = data
                    self._offset = n
                    buf += data[:n]
                    break
                if data:
                    buf += data
                    break
        return buf

    def _read1(self, n):
        # Read up to n compressed bytes with at most one read() system call,
        # decrypt and decompress them.
        if self._eof or n <= 0:
            return b''

        # Read from file.
        if self._compress_type == ZIP_DEFLATED:
            ## Handle unconsumed data.
            data = self._decompressor.unconsumed_tail
            if n > len(data):
                data += self._read2(n - len(data))
        else:
            data = self._read2(n)

        if self._compress_type == ZIP_STORED:
            self._eof = self._compress_left <= 0
        elif self._compress_type == ZIP_DEFLATED:
            n = max(n, self.MIN_READ_SIZE)
            data = self._decompressor.decompress(data, n)
            self._eof = (self._decompressor.eof or
                         self._compress_left <= 0 and
                         not self._decompressor.unconsumed_tail)
            if self._eof:
                data += self._decompressor.flush()
        else:
            data = self._decompressor.decompress(data)
            self._eof = self._decompressor.eof or self._compress_left <= 0

        data = data[:self._left]
        self._left -= len(data)
        if self._left <= 0:
            self._eof = True
        self._update_crc(data)
        return data

    def _read2(self, n):
        if self._compress_left <= 0:
            return b''

        n = max(n, self.MIN_READ_SIZE)
        n = min(n, self._compress_left)

        data = self._fileobj.read(n)
        self._compress_left -= len(data)
        if not data:
            raise EOFError

        if self._decrypter is not None:
            data = self._decrypter(data)
        return data

    def close(self):
        try:
            if self._close_fileobj:
                self._fileobj.close()
        finally:
            super().close()

    def seekable(self):
        if self.closed:
            raise ValueError("I/O operation on closed file.")
        return self._seekable

    def seek(self, offset, whence=os.SEEK_SET):
        if self.closed:
            raise ValueError("seek on closed file.")
        if not self._seekable:
            raise io.UnsupportedOperation("underlying stream is not seekable")
        curr_pos = self.tell()
        if whence == os.SEEK_SET:
            new_pos = offset
        elif whence == os.SEEK_CUR:
            new_pos = curr_pos + offset
        elif whence == os.SEEK_END:
            new_pos = self._orig_file_size + offset
        else:
            raise ValueError("whence must be os.SEEK_SET (0), "
                             "os.SEEK_CUR (1), or os.SEEK_END (2)")

        if new_pos > self._orig_file_size:
            new_pos = self._orig_file_size

        if new_pos < 0:
            new_pos = 0

        read_offset = new_pos - curr_pos
        buff_offset = read_offset + self._offset

        if buff_offset >= 0 and buff_offset < len(self._readbuffer):
            # Just move the _offset index if the new position is in the _readbuffer
            self._offset = buff_offset
            read_offset = 0
        # Fast seek uncompressed unencrypted file
        elif self._compress_type == ZIP_STORED and self._decrypter is None and read_offset != 0:
            # disable CRC checking after first seeking - it would be invalid
            self._expected_crc = None
            # seek actual file taking already buffered data into account
            read_offset -= len(self._readbuffer) - self._offset
            self._fileobj.seek(read_offset, os.SEEK_CUR)
            self._left -= read_offset
            self._compress_left -= read_offset
            self._eof = self._left <= 0
            read_offset = 0
            # flush read buffer
            self._readbuffer = b''
            self._offset = 0
        elif read_offset < 0:
            # Position is before the current position. Reset the ZipExtFile
            self._fileobj.seek(self._orig_compress_start)
            self._running_crc = self._orig_start_crc
            self._expected_crc = self._orig_crc
            self._compress_left = self._orig_compress_size
            self._left = self._orig_file_size
            self._readbuffer = b''
            self._offset = 0
            self._decompressor = _get_decompressor(self._compress_type)
            self._eof = False
            read_offset = new_pos
            if self._decrypter is not None:
                self._init_decrypter()

        while read_offset > 0:
            read_len = min(self.MAX_SEEK_READ, read_offset)
            self.read(read_len)
            read_offset -= read_len

        return self.tell()

    def tell(self):
        if self.closed:
            raise ValueError("tell on closed file.")
        if not self._seekable:
            raise io.UnsupportedOperation("underlying stream is not seekable")
        filepos = self._orig_file_size - self._left - len(self._readbuffer) + self._offset
        return filepos


class _ZipWriteFile(io.BufferedIOBase):
    def __init__(self, zf, zinfo, zip64):
        self._zinfo = zinfo
        self._zip64 = zip64
        self._zipfile = zf
        self._compressor = _get_compressor(zinfo.compress_type,
                                           zinfo.compress_level)
        self._file_size = 0
        self._compress_size = 0
        self._crc = 0

    @property
    def _fileobj(self):
        return self._zipfile.fp

    @property
    def name(self):
        return self._zinfo.filename

    @property
    def mode(self):
        return 'wb'

    def writable(self):
        return True

    def write(self, data):
        if self.closed:
            raise ValueError('I/O operation on closed file.')

        # Accept any data that supports the buffer protocol
        if isinstance(data, (bytes, bytearray)):
            nbytes = len(data)
        else:
            data = memoryview(data)
            nbytes = data.nbytes
        self._file_size += nbytes

        self._crc = crc32(data, self._crc)
        if self._compressor:
            data = self._compressor.compress(data)
            self._compress_size += len(data)
        self._fileobj.write(data)
        return nbytes

    def close(self):
        if self.closed:
            return
        try:
            super().close()
            # Flush any data from the compressor, and update header info
            if self._compressor:
                buf = self._compressor.flush()
                self._compress_size += len(buf)
                self._fileobj.write(buf)
                self._zinfo.compress_size = self._compress_size
            else:
                self._zinfo.compress_size = self._file_size
            self._zinfo.CRC = self._crc
            self._zinfo.file_size = self._file_size

            if not self._zip64:
                if self._file_size > ZIP64_LIMIT:
                    raise RuntimeError("File size too large, try using force_zip64")
                if self._compress_size > ZIP64_LIMIT:
                    raise RuntimeError("Compressed size too large, try using force_zip64")

            # Write updated header info
            if self._zinfo.flag_bits & _MASK_USE_DATA_DESCRIPTOR:
                # Write CRC and file sizes after the file data
                fmt = '<LLQQ' if self._zip64 else '<LLLL'
                self._fileobj.write(struct.pack(fmt, _DD_SIGNATURE, self._zinfo.CRC,
                    self._zinfo.compress_size, self._zinfo.file_size))
                self._zipfile.start_dir = self._fileobj.tell()
            else:
                # Seek backwards and write file header (which will now include
                # correct CRC and file sizes)

                # Preserve current position in file
                self._zipfile.start_dir = self._fileobj.tell()
                self._fileobj.seek(self._zinfo.header_offset)
                self._fileobj.write(self._zinfo.FileHeader(self._zip64))
                self._fileobj.seek(self._zipfile.start_dir)

            # Successfully written: Add file to our caches
            self._zipfile.filelist.append(self._zinfo)
            self._zipfile.NameToInfo[self._zinfo.filename] = self._zinfo
        finally:
            self._zipfile._writing = False



class ZipFile:
    """ Class with methods to open, read, write, close, list zip files.

    z = ZipFile(file, mode="r", compression=ZIP_STORED, allowZip64=True,
                compresslevel=None)

    file: Either the path to the file, or a file-like object.
          If it is a path, the file will be opened and closed by ZipFile.
    mode: The mode can be either read 'r', write 'w', exclusive create 'x',
          or append 'a'.
    compression: ZIP_STORED (no compression), ZIP_DEFLATED (requires zlib),
                 ZIP_BZIP2 (requires bz2) or ZIP_LZMA (requires lzma).
    allowZip64: if True ZipFile will create files with ZIP64 extensions when
                needed, otherwise it will raise an exception when this would
                be necessary.
    compresslevel: None (default for the given compression type) or an integer
                   specifying the level to pass to the compressor.
                   When using ZIP_STORED or ZIP_LZMA this keyword has no effect.
                   When using ZIP_DEFLATED integers 0 through 9 are accepted.
                   When using ZIP_BZIP2 integers 1 through 9 are accepted.

    """

    fp = None                   # Set here since __del__ checks it
    _windows_illegal_name_trans_table = None

    def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=True,
                 compresslevel=None, *, strict_timestamps=True, metadata_encoding=None):
        """Open the ZIP file with mode read 'r', write 'w', exclusive create 'x',
        or append 'a'."""
        if mode not in ('r', 'w', 'x', 'a'):
            raise ValueError("ZipFile requires mode 'r', 'w', 'x', or 'a'")

        _check_compression(compression)

        self._allowZip64 = allowZip64
        self._didModify = False
        self.debug = 0  # Level of printing: 0 through 3
        self.NameToInfo = {}    # Find file info given name
        self.filelist = []      # List of ZipInfo instances for archive
        self.compression = compression  # Method of compression
        self.compresslevel = compresslevel
        self.mode = mode
        self.pwd = None
        self._comment = b''
        self._strict_timestamps = strict_timestamps
        self.metadata_encoding = metadata_encoding

        # Check that we don't try to write with nonconforming codecs
        if self.metadata_encoding and mode != 'r':
            raise ValueError(
                "metadata_encoding is only supported for reading files")

        # Check if we were passed a file-like object
        if isinstance(file, os.PathLike):
            file = os.fspath(file)
        if isinstance(file, str):
            # No, it's a filename
            self._filePassed = 0
            self.filename = file
            modeDict = {'r' : 'rb', 'w': 'w+b', 'x': 'x+b', 'a' : 'r+b',
                        'r+b': 'w+b', 'w+b': 'wb', 'x+b': 'xb'}
            filemode = modeDict[mode]
            while True:
                try:
                    self.fp = io.open(file, filemode)
                except OSError:
                    if filemode in modeDict:
                        filemode = modeDict[filemode]
                        continue
                    raise
                break
        else:
            self._filePassed = 1
            self.fp = file
            self.filename = getattr(file, 'name', None)
        self._fileRefCnt = 1
        self._lock = threading.RLock()
        self._seekable = True
        self._writing = False

        try:
            if mode == 'r':
                self._RealGetContents()
            elif mode in ('w', 'x'):
                # set the modified flag so central directory gets written
                # even if no files are added to the archive
                self._didModify = True
                try:
                    self.start_dir = self.fp.tell()
                except (AttributeError, OSError):
                    self.fp = _Tellable(self.fp)
                    self.start_dir = 0
                    self._seekable = False
                else:
                    # Some file-like objects can provide tell() but not seek()
                    try:
                        self.fp.seek(self.start_dir)
                    except (AttributeError, OSError):
                        self._seekable = False
            elif mode == 'a':
                try:
                    # See if file is a zip file
                    self.eŸ  fŸ  gŸ  hŸ  iŸ  jŸ  kŸ  lŸ  mŸ  nŸ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          _RealGetContents()
                    # seek to start of directory and overwrite
                    self.fp.seek(self.start_dir)
                except BadZipFile:
                    # file is not a zip file, just append
                    self.fp.seek(0, 2)

                    # set the modified flag so central directory gets written
                    # even if no files are added to the archive
                    self._didModify = True
                    self.start_dir = self.fp.tell()
            else:
                raise ValueError("Mode must be 'r', 'w', 'x', or 'a'")
        except:
            fp = self.fp
            self.fp = None
            self._fpclose(fp)
            raise

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        self.close()

    def __repr__(self):
        result = ['<%s.%s' % (self.__class__.__module__,
                              self.__class__.__qualname__)]
        if self.fp is not None:
            if self._filePassed:
                result.append(' file=%r' % self.fp)
            elif self.filename is not None:
                result.append(' filename=%r' % self.filename)
            result.append(' mode=%r' % self.mode)
        else:
            result.append(' [closed]')
        result.append('>')
        return ''.join(result)

    def _RealGetContents(self):
        """Read in the table of contents for the ZIP file."""
        fp = self.fp
        try:
            endrec = _EndRecData(fp)
        except OSError:
            raise BadZipFile("File is not a zip file")
        if not endrec:
            raise BadZipFile("File is not a zip file")
        if self.debug > 1:
            print(endrec)
        size_cd = endrec[_ECD_SIZE]             # bytes in central directory
        offset_cd = endrec[_ECD_OFFSET]         # offset of central directory
        self._comment = endrec[_ECD_COMMENT]    # archive comment

        # "concat" is zero, unless zip was concatenated to another file
        concat = endrec[_ECD_LOCATION] - size_cd - offset_cd
        if endrec[_ECD_SIGNATURE] == stringEndArchive64:
            # If Zip64 extension structures are present, account for them
            concat -= (sizeEndCentDir64 + sizeEndCentDir64Locator)

        if self.debug > 2:
            inferred = concat + offset_cd
            print("given, inferred, offset", offset_cd, inferred, concat)
        # self.start_dir:  Position of start of central directory
        self.start_dir = offset_cd + concat
        if self.start_dir < 0:
            raise BadZipFile("Bad offset for central directory")
        fp.seek(self.start_dir, 0)
        data = fp.read(size_cd)
        fp = io.BytesIO(data)
        total = 0
        while total < size_cd:
            centdir = fp.read(sizeCentralDir)
            if len(centdir) != sizeCentralDir:
                raise BadZipFile("Truncated central directory")
            centdir = struct.unpack(structCentralDir, centdir)
            if centdir[_CD_SIGNATURE] != stringCentralDir:
                raise BadZipFile("Bad magic number for central directory")
            if self.debug > 2:
                print(centdir)
            filename = fp.read(centdir[_CD_FILENAME_LENGTH])
            orig_filename_crc = crc32(filename)
            flags = centdir[_CD_FLAG_BITS]
            if flags & _MASK_UTF_FILENAME:
                # UTF-8 file names extension
                filename = filename.decode('utf-8')
            else:
                # Historical ZIP filename encoding
                filename = filename.decode(self.metadata_encoding or 'cp437')
            # Create ZipInfo instance to store file information
            x = ZipInfo(filename)
            x.extra = fp.read(centdir[_CD_EXTRA_FIELD_LENGTH])
            x.comment = fp.read(centdir[_CD_COMMENT_LENGTH])
            x.header_offset = centdir[_CD_LOCAL_HEADER_OFFSET]
            (x.create_version, x.create_system, x.extract_version, x.reserved,
             x.flag_bits, x.compress_type, t, d,
             x.CRC, x.compress_size, x.file_size) = centdir[1:12]
            if x.extract_version > MAX_EXTRACT_VERSION:
                raise NotImplementedError("zip file version %.1f" %
                                          (x.extract_version / 10))
            x.volume, x.internal_attr, x.external_attr = centdir[15:18]
            # Convert date/time code to (year, month, day, hour, min, sec)
            x._raw_time = t
            x.date_time = ( (d>>9)+1980, (d>>5)&0xF, d&0x1F,
                            t>>11, (t>>5)&0x3F, (t&0x1F) * 2 )
            x._decodeExtra(orig_filename_crc)
            x.header_offset = x.header_offset + concat
            self.filelist.append(x)
            self.NameToInfo[x.filename] = x

            # update total bytes read from central directory
            total = (total + sizeCentralDir + centdir[_CD_FILENAME_LENGTH]
                     + centdir[_CD_EXTRA_FIELD_LENGTH]
                     + centdir[_CD_COMMENT_LENGTH])

            if self.debug > 2:
                print("total", total)

        end_offset = self.start_dir
        for zinfo in reversed(sorted(self.filelist,
                                     key=lambda zinfo: zinfo.header_offset)):
            zinfo._end_offset = end_offset
            end_offset = zinfo.header_offset

    def namelist(self):
        """Return a list of file names in the archive."""
        return [data.filename for data in self.filelist]

    def infolist(self):
        """Return a list of class ZipInfo instances for files in the
        archive."""
        return self.filelist

    def printdir(self, file=None):
        """Print a table of contents for the zip file."""
        print("%-46s %19s %12s" % ("File Name", "Modified    ", "Size"),
              file=file)
        for zinfo in self.filelist:
            date = "%d-%02d-%02d %02d:%02d:%02d" % zinfo.date_time[:6]
            print("%-46s %s %12d" % (zinfo.filename, date, zinfo.file_size),
                  file=file)

    def testzip(self):
        """Read all the files and check the CRC.

        Return None if all files could be read successfully, or the name
        of the offending file otherwise."""
        chunk_size = 2 ** 20
        for zinfo in self.filelist:
            try:
                # Read by chunks, to avoid an OverflowError or a
                # MemoryError with very large embedded files.
                with self.open(zinfo.filename, "r") as f:
                    while f.read(chunk_size):     # Check CRC-32
                        pass
            except BadZipFile:
                return zinfo.filename

    def getinfo(self, name):
        """Return the instance of ZipInfo given 'name'."""
        info = self.NameToInfo.get(name)
        if info is None:
            raise KeyError(
                'There is no item named %r in the archive' % name)

        return info

    def setpassword(self, pwd):
        """Set default password for encrypted files."""
        if pwd and not isinstance(pwd, bytes):
            raise TypeError("pwd: expected bytes, got %s" % type(pwd).__name__)
        if pwd:
            self.pwd = pwd
        else:
            self.pwd = None

    @property
    def comment(self):
        """The comment text associated with the ZIP file."""
        return self._comment

    @comment.setter
    def comment(self, comment):
        if not isinstance(comment, bytes):
            raise TypeError("comment: expected bytes, got %s" % type(comment).__name__)
        # check for valid comment length
        if len(comment) > ZIP_MAX_COMMENT:
            import warnings
            warnings.warn('Archive comment is too long; truncating to %d bytes'
                          % ZIP_MAX_COMMENT, stacklevel=2)
            comment = comment[:ZIP_MAX_COMMENT]
        self._comment = comment
        self._didModify = True

    def read(self, name, pwd=None):
        """Return file bytes for name. 'pwd' is the password to decrypt
        encrypted files."""
        with self.open(name, "r", pwd) as fp:
            return fp.read()

    def open(self, name, mode="r", pwd=None, *, force_zip64=False):
        """Return file-like object for 'name'.

        name is a string for the file name within the ZIP file, or a ZipInfo
        object.

        mode should be 'r' to read a file already in the ZIP file, or 'w' to
        write to a file newly added to the archive.

        pwd is the password to decrypt files (only used for reading).

        When writing, if the file size is not known in advance but may exceed
        2 GiB, pass force_zip64 to use the ZIP64 format, which can handle large
        files.  If the size is known in advance, it is best to pass a ZipInfo
        instance for name, with zinfo.file_size set.
        """
        if mode not in {"r", "w"}:
            raise ValueError('open() requires mode "r" or "w"')
        if pwd and (mode == "w"):
            raise ValueError("pwd is only supported for reading files")
        if not self.fp:
            raise ValueError(
                "Attempt to use ZIP archive that was already closed")

        # Make sure we have an info object
        if isinstance(name, ZipInfo):
            # 'name' is already an info object
            zinfo = name
        elif mode == 'w':
            zinfo = ZipInfo(name)
            zinfo.compress_type = self.compression
            zinfo.compress_level = self.compresslevel
        else:
            # Get info object for name
            zinfo = self.getinfo(name)

        if mode == 'w':
            return self._open_to_write(zinfo, force_zip64=force_zip64)

        if self._writing:
            raise ValueError("Can't read from the ZIP file while there "
                    "is an open writing handle on it. "
                    "Close the writing handle before trying to read.")

        # Open for reading:
        self._fileRefCnt += 1
        zef_file = _SharedFile(self.fp, zinfo.header_offset,
                               self._fpclose, self._lock, lambda: self._writing)
        try:
            # Skip the file header:
            fheader = zef_file.read(sizeFileHeader)
            if len(fheader) != sizeFileHeader:
                raise BadZipFile("Truncated file header")
            fheader = struct.unpack(structFileHeader, fheader)
            if fheader[_FH_SIGNATURE] != stringFileHeader:
                raise BadZipFile("Bad magic number for file header")

            fname = zef_file.read(fheader[_FH_FILENAME_LENGTH])
            if fheader[_FH_EXTRA_FIELD_LENGTH]:
                zef_file.seek(fheader[_FH_EXTRA_FIELD_LENGTH], whence=1)

            if zinfo.flag_bits & _MASK_COMPRESSED_PATCH:
                # Zip 2.7: compressed patched data
                raise NotImplementedError("compressed patched data (flag bit 5)")

            if zinfo.flag_bits & _MASK_STRONG_ENCRYPTION:
                # strong encryption
                raise NotImplementedError("strong encryption (flag bit 6)")

            if fheader[_FH_GENERAL_PURPOSE_FLAG_BITS] & _MASK_UTF_FILENAME:
                # UTF-8 filename
                fname_str = fname.decode("utf-8")
            else:
                fname_str = fname.decode(self.metadata_encoding or "cp437")

            if fname_str != zinfo.orig_filename:
                raise BadZipFile(
                    'File name in directory %r and header %r differ.'
                    % (zinfo.orig_filename, fname))

            if (zinfo._end_offset is not None and
                zef_file.tell() + zinfo.compress_size > zinfo._end_offset):
                if zinfo._end_offset == zinfo.header_offset:
                    import warnings
                    warnings.warn(
                        f"Overlapped entries: {zinfo.orig_filename!r} "
                        f"(possible zip bomb)",
                        skip_file_prefixes=(os.path.dirname(__file__),))
                else:
                    raise BadZipFile(
                        f"Overlapped entries: {zinfo.orig_filename!r} "
                        f"(possible zip bomb)")

            # check for encrypted flag & handle password
            is_encrypted = zinfo.flag_bits & _MASK_ENCRYPTED
            if is_encrypted:
                if not pwd:
                    pwd = self.pwd
                if pwd and not isinstance(pwd, bytes):
                    raise TypeError("pwd: expected bytes, got %s" % type(pwd).__name__)
                if not pwd:
                    raise RuntimeError("File %r is encrypted, password "
                                       "required for extraction" % name)
            else:
                pwd = None

            return ZipExtFile(zef_file, mode + 'b', zinfo, pwd, True)
        except:
            zef_file.close()
            raise

    def _open_to_write(self, zinfo, force_zip64=False):
        if force_zip64 and not self._allowZip64:
            raise ValueError(
                "force_zip64 is True, but allowZip64 was False when opening "
                "the ZIP file."
            )
        if self._writing:
            raise ValueError("Can't write to the ZIP file while there is "
                             "another write handle open on it. "
                             "Close the first handle before opening another.")

        # Size and CRC are overwritten with correct data after processing the file
        zinfo.compress_size = 0
        zinfo.CRC = 0

        zinfo.flag_bits = 0x00
        if zinfo.compress_type == ZIP_LZMA:
            # Compressed data includes an end-of-stream (EOS) marker
            zinfo.flag_bits |= _MASK_COMPRESS_OPTION_1
        if not self._seekable:
            zinfo.flag_bits |= _MASK_USE_DATA_DESCRIPTOR

        if not zinfo.external_attr:
            zinfo.external_attr = 0o600 << 16  # permissions: ?rw-------

        # Compressed size can be larger than uncompressed size
        zip64 = force_zip64 or (zinfo.file_size * 1.05 > ZIP64_LIMIT)
        if not self._allowZip64 and zip64:
            raise LargeZipFile("Filesize would require ZIP64 extensions")

        if self._seekable:
            self.fp.seek(self.start_dir)
        zinfo.header_offset = self.fp.tell()

        self._writecheck(zinfo)
        self._didModify = True

        self.fp.write(zinfo.FileHeader(zip64))

        self._writing = True
        return _ZipWriteFile(self, zinfo, zip64)

    def extract(self, member, path=None, pwd=None):
        """Extract a member from the archive to the current working directory,
           using its full name. Its file information is extracted as accurately
           as possible. `member' may be a filename or a ZipInfo object. You can
           specify a different directory using `path'. You can specify the
           password to decrypt the file using 'pwd'.
        """
        if path is None:
            path = os.getcwd()
        else:
            path = os.fspath(path)

        return self._extract_member(member, path, pwd)

    def extractall(self, path=None, members=None, pwd=None):
        """Extract all members from the archive to the current working
           directory. `path' specifies a different directory to extract to.
           `members' is optional and must be a subset of the list returned
           by namelist(). You can specify the password to decrypt all files
           using 'pwd'.
        """
        if members is None:
            members = self.namelist()

        if path is None:
            path = os.getcwd()
        else:
            path = os.fspath(path)

        for zipinfo in members:
            self._extract_member(zipinfo, path, pwd)

    @classmethod
    def _sanitize_windows_name(cls, arcname, pathsep):
        """Replace bad characters and remove trailing dots from parts."""
        table = cls._windows_illegal_name_trans_table
        if not table:
            illegal = ':<>|"?*'
            table = str.maketrans(illegal, '_' * len(illegal))
            cls._windows_illegal_name_trans_table = table
        arcname = arcname.translate(table)
        # remove trailing dots and spaces
        arcname = (x.rstrip(' .') for x in arcname.split(pathsep))
        # rejoin, removing empty parts.
        arcname = pathsep.join(x for x in arcname if x)
        return arcname

    def _extract_member(self, member, targetpath, pwd):
        """Extract the ZipInfo object 'member' to a physical
           file on the path targetpath.
        """
        if not isinstance(member, ZipInfo):
            member = self.getinfo(member)

        # build the destination pathname, replacing
        # forward slashes to platform specific separators.
        arcname = member.filename.replace('/', os.path.sep)

        if os.path.altsep:
            arcname = arcname.replace(os.path.altsep, os.path.sep)
        # interpret absolute pathname as relative, remove drive letter or
        # UNC path, redundant separators, "." and ".." components.
        arcname = os.path.splitdrive(arcname)[1]
        invalid_path_parts = ('', os.path.curdir, os.path.pardir)
        arcname = os.path.sep.join(x for x in arcname.split(os.path.sep)
                                   if x not in invalid_path_parts)
        if os.path.sep == '\\':
            # filter illegal characters on Windows
            arcname = self._sanitize_windows_name(arcname, os.path.sep)

        if not arcname and not member.is_dir():
            raise ValueError("Empty filename.")

        targetpath = os.path.join(targetpath, arcname)
        targetpath = os.path.normpath(targetpath)

        # Create all upper directories if necessary.
        upperdirs = os.path.dirname(targetpath)
        if upperdirs and not os.path.exists(upperdirs):
            os.makedirs(upperdirs, exist_ok=True)

        if member.is_dir():
            if not os.path.isdir(targetpath):
                try:
                    os.mkdir(targetpath)
                except FileExistsError:
                    if not os.path.isdir(targetpath):
                        raise
            return targetpath

        with self.open(member, pwd=pwd) as source, \
             open(targetpath, "wb") as target:
            shutil.copyfileobj(source, target)

        return targetpath

    def _writecheck(self, zinfo):
        """Check for errors before writing a file to the archive."""
        if zinfo.filename in self.NameToInfo:
            import warnings
            warnings.warn('Duplicate name: %r' % zinfo.filename, stacklevel=3)
        if self.mode not in ('w', 'x', 'a'):
            raise ValueError("write() requires mode 'w', 'x', or 'a'")
        if not self.fp:
            raise ValueError(
                "Attempt to write ZIP archive that was already closed")
        _check_compression(zinfo.compress_type)
        if not self._allowZip64:
            requires_zip64 = None
            if len(self.filelist) >= ZIP_FILECOUNT_LIMIT:
                requires_zip64 = "Files count"
            elif zinfo.file_size > ZIP64_LIMIT:
                requires_zip64 = "Filesize"
            elif zinfo.header_offset > ZIP64_LIMIT:
                requires_zip64 = "Zipfile size"
            if requires_zip64:
                raise LargeZipFile(requires_zip64 +
                                   " would require ZIP64 extensions")

    def write(self, filename, arcname=None,
              compress_type=None, compresslevel=None):
        """Put the bytes from filename into the archive under the name
        arcname."""
        if not self.fp:
            raise ValueError(
                "Attempt to write to ZIP archive that was already closed")
        if self._writing:
            raise ValueError(
                "Can't write to ZIP archive while an open writing handle exists"
            )

        zinfo = ZipInfo.from_file(filename, arcname,
                                  strict_timestamps=self._strict_timestamps)

        if zinfo.is_dir():
            zinfo.compress_size = 0
            zinfo.CRC = 0
            self.mkdir(zinfo)
        else:
            if compress_type is not None:
                zinfo.compress_type = compress_type
            else:
                zinfo.compress_type = self.compression

            if compresslevel is not None:
                zinfo.compress_level = compresslevel
            else:
                zinfo.compress_level = self.compresslevel

            with open(filename, "rb") as src, self.open(zinfo, 'w') as dest:
                shutil.copyfileobj(src, dest, 1024*8)

    def writestr(self, zinfo_or_arcname, data,
                 compress_type=None, compresslevel=None):
        """Write a file into the archive.  The contents is 'data', which
        may be either a 'str' or a 'bytes' instance; if it is a 'str',
        it is encoded as UTF-8 first.
        'zinfo_or_arcname' is either a ZipInfo instance or
        the name of the file in the archive."""
        if isinstance(data, str):
            data = data.encode("utf-8")
        if not isinstance(zinfo_or_arcname, ZipInfo):
            zinfo = ZipInfo(filename=zinfo_or_arcname,
                            date_time=time.localtime(time.time())[:6])
            zinfo.compress_type = self.compression
            zinfo.compress_level = self.compresslevel
            if zinfo.filename.endswith('/'):
                zinfo.external_attr = 0o40775 << 16   # drwxrwxr-x
                zinfo.external_attr |= 0x10           # MS-DOS directory flag
            else:
                zinfo.external_attr = 0o600 << 16     # ?rw-------
        else:
            zinfo = zinfo_or_arcname

        if not self.fp:
            raise ValueError(
                "Attempt to write to ZIP archive that was already closed")
        if self._writing:
            raise ValueError(
                "Can't write to ZIP archive while an open writing handle exists."
            )

        if compress_type is not None:
            zinfo.compress_type = compress_type

        if compresslevel is not None:
            zinfo.compress_level = compresslevel

        zinfo.file_size = len(data)            # Uncompressed size
        with self._lock:
            with self.open(zinfo, mode='w') as dest:
                dest.write(data)

    def mkdir(self, zinfo_or_directory_name, mode=511):
        """Creates a directory inside the zip archive."""
        if isinstance(zinfo_or_directory_name, ZipInfo):
            zinfo = zinfo_or_directory_name
            if not zinfo.is_dir():
                raise ValueError("The given ZipInfo does not describe a directory")
        elif isinstance(zinfo_or_directory_name, str):
            directory_name = zinfo_or_directory_name
            if not directory_name.endswith("/"):
                directory_name += "/"
            zinfo = ZipInfo(directory_name)
            zinfo.compress_size = 0
            zinfo.CRC = 0
            zinfo.external_attr = ((0o40000 | mode) & 0xFFFF) << 16
            zinfo.file_size = 0
            zinfo.external_attr |= 0x10
        else:
            raise TypeError("Expected type str or ZipInfo")

        with self._lock:
            if self._seekable:
                self.fp.seek(self.start_dir)
            zinfo.header_offset = self.fp.tell()  # Start of header bytes
            if zinfo.compress_type == ZIP_LZMA:
            # Compressed data includes an end-of-stream (EOS) marker
                zinfo.flag_bits |= _MASK_COMPRESS_OPTION_1

            self._writecheck(zinfo)
            self._didModify = True

            self.filelist.append(zinfo)
            self.NameToInfo[zinfo.filename] = zinfo
            self.fp.write(zinfo.FileHeader(False))
            self.start_dir = self.fp.tell()

    def __del__(self):
        """Call the "close()" method in case the user forgot."""
        self.close()

    def close(self):
        """Close the file, and for mode 'w', 'x' and 'a' write the ending
        records."""
        if self.fp is None:
            return

        if self._writing:
            raise ValueError("Can't close the ZIP file while there is "
                             "an open writing handle on it. "
                             "Close the writing handle before closing the zip.")

        try:
            if self.mode in ('w', 'x', 'a') and self._didModify: # write ending records
                with self._lock:
                    if self._seekable:
                        self.fp.seek(self.start_dir)
                    self._write_end_record()
        finally:
            fp = self.fp
            self.fp = None
            self._fpclose(fp)

    def _write_end_record(self):
        for zinfo in self.filelist:         # write central directory
            dt = zinfo.date_time
            dosdate = (dt[0] - 1980) << 9 | dt[1] << 5 | dt[2]
            dostime = dt[3] << 11 | dt[4] << 5 | (dt[5] // 2)
            extra = []
            if zinfo.file_size > ZIP64_LIMIT \
               or zinfo.compress_size > ZIP64_LIMIT:
                extra.append(zinfo.file_size)
                extra.append(zinfo.compress_size)
                file_size = 0xffffffff
                compress_size = 0xffffffff
            else:
                file_size = zinfo.file_size
                compress_size = zinfo.compress_size

            if zinfo.header_offset > ZIP64_LIMIT:
                extra.append(zinfo.header_offset)
                header_offset = 0xffffffff
            else:
                header_offset = zinfo.header_offset

            extra_data = zinfo.extra
            min_version = 0
            if extra:
                # Append a ZIP64 field to the extra's
                extra_data = _Extra.strip(extra_data, (1,))
                extra_data = struct.pack(
                    '<HH' + 'Q'*len(extra),
                    1, 8*len(extra), *extra) + extra_data

                min_version = ZIP64_VERSION

            if zinfo.compress_type == ZIP_BZIP2:
                min_version = max(BZIP2_VERSION, min_version)
            elif zinfo.compress_type == ZIP_LZMA:
                min_version = max(LZMA_VERSION, min_version)

            extract_version = max(min_version, zinfo.extract_version)
            create_version = max(min_version, zinfo.create_version)
            filename, flag_bits = zinfo._encodeFilenameFlags()
            centdir = struct.pack(structCentralDir,
                                  stringCentralDir, create_version,
                                  zinfo.create_system, extract_version, zinfo.reserved,
                                  flag_bits, zinfo.compress_type, dostime, dosdate,
                                  zinfo.CRC, compress_size, file_size,
                                  len(filename), len(extra_data), len(zinfo.comment),
                                  0, zinfo.internal_attr, zinfo.external_attr,
                                  header_offset)
            self.fp.write(centdir)
            self.fp.write(filename)
            self.fp.write(extra_data)
            self.fp.write(zinfo.comment)

        pos2 = self.fp.tell()
        # Write end-of-zip-archive record
        centDirCount = len(self.filelist)
        centDirSize = pos2 - self.start_dir
        centDirOffset = self.start_dir
        requires_zip64 = None
        if centDirCount > ZIP_FILECOUNT_LIMIT:
            requires_zip64 = "Files count"
        elif centDirOffset > ZIP64_LIMIT:
            requires_zip64 = "Central directory offset"
        elif centDirSize > ZIP64_LIMIT:
            requires_zip64 = "Central directory size"
        if requires_zip64:
            # Need to write the ZIP64 end-of-archive records
            if not self._allowZip64:
                raise LargeZipFile(requires_zip64 +
                                   " would require ZIP64 extensions")
            zip64endrec = struct.pack(
                structEndArchive64, stringEndArchive64,
                44, 45, 45, 0, 0, centDirCount, centDirCount,
                centDirSize, centDirOffset)
            self.fp.write(zip64endrec)

            zip64locrec = struct.pack(
                structEndArchive64Locator,
                stringEndArchive64Locator, 0, pos2, 1)
            self.fp.write(zip64locrec)
            centDirCount = min(centDirCount, 0xFFFF)
            centDirSize = min(centDirSize, 0xFFFFFFFF)
            centDirOffset = min(centDirOffset, 0xFFFFFFFF)

        endrec = struct.pack(structEndArchive, stringEndArchive,
                             0, 0, centDirCount, centDirCount,
                             centDirSize, centDirOffset, len(self._comment))
        self.fp.write(endrec)
        self.fp.write(self._comment)
        if self.mode == "a":
            self.fp.truncate()
        self.fp.flush()

    def _fpclose(self, fp):
        assert self._fileRefCnt > 0
        self._fileRefCnt -= 1
        if not self._fileRefCnt and not self._filePassed:
            fp.close()


class PyZipFile(ZipFile):
    """Class to create ZIP archives with Python library files and packages."""

    def __init__(self, file, mode="r", compression=ZIP_STORED,
                 allowZip64=True, optimize=-1):
        ZipFile.__init__(self, file, mode=mode, compression=compression,
                         allowZip64=allowZip64)
        self._optimize = optimize

    def writepy(self, pathname, basename="", filterfunc=None):
        """Add all files from "pathname" to the ZIP archive.

        If pathname is a package directory, search the directory and
        all package subdirectories recursively for all *.py and enter
        the modules into the archive.  If pathname is a plain
        directory, listdir *.py and enter all modules.  Else, pathname
        must be a Python *.py file and the module will be put into the
        archive.  Added modules are always module.pyc.
        This method will compile the module.py into module.pyc if
        necessary.
        If filterfunc(pathname) is given, it is called with every argument.
        When it is False, the file or directory is skipped.
        """
        pathname = os.fspath(pathname)
        if filterfunc and not filterfunc(pathname):
            if self.debug:
                label = 'path' if os.path.isdir(pathname) else 'file'
                print('%s %r skipped by filterfunc' % (label, pathname))
            return
        dir, name = os.path.split(pathname)
        if os.path.isdir(pathname):
            initname = os.path.join(pathname, "__init__.py")
            if os.path.isfile(initname):
                # This is a package directory, add it
                if basename:
                    basename = "%s/%s" % (basename, name)
                else:
                    basename = name
                if self.debug:
                    print("Adding package in", pathname, "as", basename)
                fname, arcname = self._get_codename(initname[0:-3], basename)
                if self.debug:
                    print("Adding", arcname)
                self.write(fname, arcname)
                dirlist = sorted(os.listdir(pathname))
                dirlist.remove("__init__.py")
                # Add all *.py files and package subdirectories
                for filename in dirlist:
                    path = os.path.join(pathname, filename)
                    root, ext = os.path.splitext(filename)
                    if os.path.isdir(path):
                        if os.path.isfile(os.path.join(path, "__init__.py")):
                            # This is a package directory, add it
                            self.writepy(path, basename,
                                         filterfunc=filterfunc)  # Recursive call
                    elif ext == ".py":
                        if filterfunc and not filterfunc(path):
                            if self.debug:
                                print('file %r skipped by filterfunc' % path)
                            continue
                        fname, arcname = self._get_codename(path[0:-3],
                                                            basename)
                        if self.debug:
                            print("Adding", arcname)
                        self.write(fname, arcname)
            else:
                # This is NOT a package directory, add its files at top level
                if self.debug:
                    print("Adding files from directory", pathname)
                for filename in sorted(os.listdir(pathname)):
                    path = os.path.join(pathname, filename)
                    root, ext = os.path.splitext(filename)
                    if ext == ".py":
                        if filterfunc and not filterfunc(path):
                            if self.debug:
                                print('file %r skipped by filterfunc' % path)
                            continue
                        fname, arcname = self._get_codename(path[0:-3],
                                                            basename)
                        if self.debug:
                            print("Adding", arcname)
                        self.write(fname, arcname)
        else:
            if pathname[-3:] != ".py":
                raise RuntimeError(
                    'Files added with writepy() must end with ".py"')
            fname, arcname = self._get_codename(pathname[0:-3], basename)
            if self.debug:
                print("Adding file", arcname)
            self.write(fname, arcname)

    def _get_codename(self, pathname, basename):
        """Return (filename, archivename) for the path.

        Given a module name path, return the correct file path and
        archive name, compiling if necessary.  For example, given
        /python/lib/string, return (/python/lib/string.pyc, string).
        """
        def _compile(file, optimize=-1):
            import py_compile
            if self.debug:
                print("Compiling", file)
            try:
                py_compile.compile(file, doraise=True, optimize=optimize)
            except py_compile.PyCompileError as err:
                print(err.msg)
                return False
            return True

        file_py  = pathname + ".py"
        file_pyc = pathname + ".pyc"
        pycache_opt0 = importlib.util.cache_from_source(file_py, optimization='')
        pycache_opt1 = importlib.util.cache_from_source(file_py, optimization=1)
        pycache_opt2 = importlib.util.cache_from_source(file_py, optimization=2)
        if self._optimize == -1:
            # legacy mode: use whatever file is present
            if (os.path.isfile(file_pyc) and
                  os.stat(file_pyc).st_mtime >= os.stat(file_py).st_mtime):
                # Use .pyc file.
                arcname = fname = file_pyc
            elif (os.path.isfile(pycache_opt0) and
                  os.stat(pycache_opt0).st_mtime >= os.stat(file_py).st_mtime):
                # Use the __pycache__/*.pyc file, but write it to the legacy pyc
                # file name in the archive.
                fname = pycache_opt0
                arcname = file_pyc
            elif (os.path.isfile(pycache_opt1) and
                  os.stat(pycache_opt1).st_mtime >= os.stat(file_py).st_mtime):
                # Use the __pycache__/*.pyc file, but write it to the legacy pyc
                # file name in the archive.
                fname = pycache_opt1
                arcname = file_pyc
            elif (os.path.isfile(pycache_opt2) and
                  os.stat(pycache_opt2).st_mtime >= os.stat(file_py).st_mtime):
                # Use the __pycache__/*.pyc file, but write it to the legacy pyc
                # file name in the archive.
                fname = pycache_opt2
                arcname = file_pyc
            else:
                # Compile py into PEP 3147 pyc file.
                if _compile(file_py):
                    if sys.flags.optimize == 0:
                        fname = pycache_opt0
                    elif sys.flags.optimize == 1:
                        fname = pycache_opt1
                    else:
                        fname = pycache_opt2
                    arcname = file_pyc
                else:
                    fname = arcname = file_py
        else:
            # new mode: use given optimization level
            if self._optimize == 0:
                fname = pycache_opt0
                arcname = file_pyc
            else:
                arcname = file_pyc
                if self._optimize == 1:
                    fname = pycache_opt1
                elif self._optimize == 2:
                    fname = pycache_opt2
                else:
                    msg = "invalid value for 'optimize': {!r}".format(self._optimize)
                    raise ValueError(msg)
            if not (os.path.isfile(fname) and
                    os.stat(fname).st_mtime >= os.stat(file_py).st_mtime):
                if not _compile(file_py, optimize=self._optimize):
                    fname = arcname = file_py
        archivename = os.path.split(arcname)[1]
        if basename:
            archivename = "%s/%s" % (basename, archivename)
        return (fname, archivename)


def main(args=None):
    import argparse

    description = 'A simple command-line interface for zipfile module.'
    parser = argparse.ArgumentParser(description=description)
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-l', '--list', metavar='<zipfile>',
                       help='Show listing of a zipfile')
    group.add_argument('-e', '--extract', nargs=2,
                       metavar=('<zipfile>', '<output_dir>'),
                       help='Extract zipfile into target dir')
    group.add_argument('-c', '--create', nargs='+',
                       metavar=('<name>', '<file>'),
                       help='Create zipfile from sources')
    group.add_argument('-t', '--test', metavar='<zipfile>',
                       help='Test if a zipfile is valid')
    parser.add_argument('--metadata-encoding', metavar='<encoding>',
                        help='Specify encoding of member names for -l, -e and -t')
    args = parser.parse_args(args)

    encoding = args.metadata_encoding

    if args.test is not None:
        src = args.test
        with ZipFile(src, 'r', metadata_encoding=encoding) as zf:
            badfile = zf.testzip()
        if badfile:
            print("The following enclosed file is corrupted: {!r}".format(badfile))
        print("Done testing")

    elif args.list is not None:
        src = args.list
        with ZipFile(src, 'r', metadata_encoding=encoding) as zf:
            zf.printdir()

    elif args.extract is not None:
        src, curdir = args.extract
        with ZipFile(src, 'r', metadata_encoding=encoding) as zf:
            zf.extractall(curdir)

    elif args.create is not None:
        if encoding:
            print("Non-conforming encodings not supported with -c.",
                  file=sys.stderr)
            sys.exit(1)

        zip_name = args.create.pop(0)
        files = args.create

        def addToZip(zf, path, zippath):
            if os.path.isfile(path):
                zf.write(path, zippath, ZIP_DEFLATED)
            elif os.path.isdir(path):
                if zippath:
                    zf.write(path, zippath)
                for nm in sorted(os.listdir(path)):
                    addToZip(zf,
                             os.path.join(path, nm), os.path.join(zippath, nm))
            # else: ignore

        with ZipFile(zip_name, 'w') as zf:
            for path in files:
                zippath = os.path.basename(path)
                if not zippath:
                    zippath = os.path.basename(os.path.dirname(path))
                if zippath in ('', os.curdir, os.pardir):
                    zippath = ''
                addToZip(zf, path, zippath)


from ._path import (  # noqa: E402
    Path,

    # used privately for tests
    CompleteDirs,  # noqa: F401
)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    from . import main

if __name__ == "__main__":
    main()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .   .   +   ..  /    __init__.cpython-313.pyc0  È__main__.cpython-313.pyc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ó
    F\h,\ ã                   óô  • S r SSKrSSKrSSKrSSKrSSKrSSKrSSKrSSK	r	SSK
r
SSKr SSKr\R                  r SSKr SSKr/ SQr " S S\5      r " S S\5      r\=rrSrS	rS	rSrS
rSrSrSrSrSr Sr!Sr"Sr#Sr$\RJ                  " \#5      r&Sr'Sr(Sr)Sr*Sr+Sr,Sr-Sr.S
r/Sr0Sr1Sr2\RJ                  " \15      r3Sr4Sr5Sr6Sr7Sr8Sr9Sr:Sr;S
r<Sr=Sr>Sr?Sr@SrASrBS rCS!rDS"rES#rFSrGSrHS
rIS$rJS%rKS&rLS'rMS(rN\RJ                  " \M5      rOSrPSrQSrRSrSSrTSrUSrVSrWS
rXSrYSrZSr[S)r\S*r]\RJ                  " \\5      r^S+r_S,r`\RJ                  " \_5      raSrbSrcSrdSreSrfSrgSrhSriS
rjSrkS-rl " S. S/\m5      rnS0 roS1 rpS2 rqS3 rrS4 rs " S5 S65      rtSquS7 rvS8 rw " S9 S:5      rx " S; S<5      ry0 SS=_SS>_SS?_SS?_SS?_SS?_SS@_SSA_S
SB_SSC_SS@_SSD_SSE_S#SF_SGSH_SISJ_SKSL_rzSM r{S^SN jr|SO r} " SP SQ5      r~ " SR SS5      r " ST SU\GR                   5      r " SV SW\GR                   5      r‚ " SX SY5      rƒ " SZ S[\ƒ5      r„S^S\ jr…SS]K†J‡r‡Jˆrˆ  g! \ a    Sr\R                  r GNf = f! \ a    Sr GN&f = f! \ a    Sr GN0f = f)_zP
Read and write ZIP files.

XXX references to utf-8 need further investigation.
é    N)Ú
BadZipFileÚ
BadZipfileÚerrorÚ
ZIP_STOREDÚZIP_DEFLATEDÚ	ZIP_BZIP2ÚZIP_LZMAÚ
is_zipfileÚZipInfoÚZipFileÚ	PyZipFileÚLargeZipFileÚPathc                   ó   • \ rS rSrSrg)r   é'   © N)Ú__name__Ú
__module__Ú__qualname__Ú__firstlineno__Ú__static_attributes__r   ó    Ú'/usr/lib/python3.13/zipfile/__init__.pyr   r   '   s   † Úr   r   c                   ó   • \ rS rSrSrSrg)r   é+   zi
Raised when writing a zipfile, the zipfile requires ZIP64 extensions
and those extensions are disabled.
r   N)r   r   r   r   Ú__doc__r   r   r   r   r   r   +   s   † ôr   r   iÿÿÿéÿÿ  é   é   é   é   é-   é.   é?   s   <4s4H2LHs   PKé   é   é   é   é   é   é   é	   z<4s4B4HL2L5H2Ls   PKé
   é   é   é   é   é   é   é    é@   i   z<4s2B4HL2L2Hs   PKz<4sLQLs   PKz
<4sQ2H2L4Qs   PKiPKc                   óŠ   ^ • \ rS rSr\R
                  " S5      rS	U 4S jjrS	S jr\	S 5       r
\	S 5       r\	S 5       rSrU =r$ )
Ú_ExtraéÀ   ú<HHc                 ó"   >• [         TU ]  X5      $ ©N)ÚsuperÚ__new__)ÚclsÚvalÚidÚ	__class__s      €r   r=   Ú_Extra.__new__Ã   s   ø€ Ü‰w‰˜sÓ(Ð(r   c                 ó   • X l         g r;   ©r@   )Úselfr?   r@   s      r   Ú__init__Ú_Extra.__init__Æ   s   € Ør   c                 ó®   •  U R                   R                  US S 5      u  p#U " US SU-    U5      USU-   S  4$ ! [        R                   a    S nSn N1f = f)Nr(   r   )ÚFIELD_STRUCTÚunpackÚstructr   )r>   ÚrawÚxidÚxlens       r   Úread_oneÚ_Extra.read_oneÉ   sl   € ð	Ø×(Ñ(×/Ñ/°°B°Q°Ó8‰IˆCñ 3w˜˜$™< Ó% s¨1¨T©6¨7 |Ð3Ð3øô |‰|ó 	ØˆCØŠDð	ús   ‚ 9 ¹AÁAc              #   óz   #   • [        U5      nU(       a%  [        R                  U5      u  p2Uv •  U(       a  M$  g g 7fr;   )Ú
memoryviewr7   rO   )r>   ÚdataÚrestÚextras       r   ÚsplitÚ_Extra.splitÒ   s0   é € ô ˜$ÓˆÞÜ Ÿ/™/¨$Ó/‰KˆEØŠK÷ Šdùs   ‚5;¹;c                 óX   ^• SR                  U4S jU R                  U5       5       5      $ )z'Remove Extra fields with specified IDs.r   c              3   óL   >#   • U  H  nUR                   T;  d  M  Uv •  M     g 7fr;   rD   )Ú.0ÚexÚxidss     €r   Ú	<genexpr>Ú_Extra.strip.<locals>.<genexpr>Ý   s&   øé € ð 
â%Øu‰u˜DÑ ÷ ‰BÚ%ùs   ƒ$›	$)ÚjoinrV   )r>   rS   r\   s     `r   ÚstripÚ_Extra.stripÚ   s+   ø€ ð x‰xô 
à—i‘i ”oó
ó 
ð 	
r   rD   r;   )r   r   r   r   rK   ÚStructrI   r=   rF   ÚclassmethodrO   rV   r`   r   Ú__classcell__©rA   s   @r   r7   r7   À   sW   ø† Ø—=’= Ó'€L÷)ôð ñ4ó ð4ð ñó ðð ñ
ó ö
r   r7   c                 óJ   •  [        U 5      (       a  g g! [         a     gf = f)NTF)Ú_EndRecDataÚOSError©Úfps    r   Ú_check_zipfilerk   ä   s4   € ðÜr?‰?Øð ð øô ó ØØðús   ‚ •
"¡"c                 óÊ   • Sn [        U S5      (       a  [        U S9nU$ [        U S5       n[        U5      nSSS5        U$ ! , (       d  f       U$ = f! [         a     U$ f = f)z€Quickly see if a file is a ZIP file by checking the magic number.

The filename argument may be a file or file-like object too.
FÚreadri   ÚrbN)Úhasattrrk   Úopenrh   )ÚfilenameÚresultrj   s      r   r
   r
   ì   sx   € ð
 €FðÜ8˜V×$Ñ$Ü# xÑ0ˆFð €Mô	 h Ô%¨Ü'¨Ó+÷ &ð €M÷	 &Ô%ð €Mûô ó ØØ€Mðús2   „A  A ¬A¸A Á
AÁA ÁA Á
A"Á!A"c           
      ó–  •  U R                  U[        -
  S5        U R                  [        5      n[	        U5      [        :w  a  U$ [
        R                  " [        U5      u  pEpgU[        :w  a  U$ US:w  d  US:”  a  [        S5      eU R                  U[        -
  [        -
  S5        U R                  [        5      n[	        U5      [        :w  a  U$ [
        R                  " [        U5      u
  pHpšp¼pÞnnU[        :w  a  U$ XB[        '   X²[        '   XÂ[        '   XÒ[         '   Xâ["        '   Xò[$        '   UU[&        '   U$ ! [         a    Us $ f = f)zE
Read the ZIP64 end-of-archive records and use that to update endrec
r&   r   r%   z3zipfiles that span multiple disks are not supported)ÚseekÚsizeEndCentDir64Locatorrh   rm   ÚlenrK   rJ   ÚstructEndArchive64LocatorÚstringEndArchive64Locatorr   ÚsizeEndCentDir64ÚstructEndArchive64ÚstringEndArchive64Ú_ECD_SIGNATUREÚ_ECD_DISK_NUMBERÚ_ECD_DISK_STARTÚ_ECD_ENTRIES_THIS_DISKÚ_ECD_ENTRIES_TOTALÚ	_ECD_SIZEÚ_ECD_OFFSET)ÚfpinÚoffsetÚendrecrS   ÚsigÚdisknoÚreloffÚdisksÚszÚcreate_versionÚread_versionÚdisk_numÚdisk_dirÚdircountÚ	dircount2ÚdirsizeÚ	diroffsets                    r   Ú_EndRecData64r“   ü   sF  € ðØ	‰	&Ô2Ñ2°AÔ6ð 9‰9Ô,Ó-€DÜ
ˆ4ƒyÔ+Ó+ØˆÜ!'§¢Ô/HÈ$Ó!OÑ€CØ
Ô'Ó'Øˆàƒ{e˜a“iÜÐNÓOÐOð 	‡IIˆfÔ.Ñ.Ô1AÑAÀ1ÔEØ9‰9Ô%Ó&€DÜ
ˆ4ƒyÔ$Ó$Øˆô 	ŠÔ(¨$Ó/ñ0€Cˆ^¨8Ø˜W ià
Ô Ó Øˆð !Œ>ÑØ'ÔÑØ&Œ?ÑØ%-Ô!Ñ"Ø!*ÔÑØŒ9ÑØ#€FŒ;ÑØ€MøôE ó ð Šðús   ‚D9 Ä9EÅEc                 óÊ  • U R                  SS5        U R                  5       n U R                  [        * S5        U R	                  [        5      n[        U5      [        :X  aw  USS [        :X  aj  USS S:X  aa  [        R                  " [        U5      n[        U5      nUR                  S5        UR                  U[        -
  5        [        U [        * U5      $ [        U[        -
  [        -
  S5      nU R                  US5        U R	                  [        [        -   5      nUR                  [        5      nUS:¼  a—  X%U[        -    n[        U5      [        :w  a  g[        [        R                  " [        U5      5      nU[            nX%[        -   U[        -   U-    nUR                  U5        UR                  XE-   5        [        XU-   U-
  U5      $ g! [         a     gf = f)zÌReturn data from the "End of Central Directory" record, or None.

The data is a list of the nine items in the ZIP "End of central dir"
record followed by a tenth item, the file seek offset of this record.r   r&   Nr(   éþÿÿÿs     r   )rt   ÚtellÚsizeEndCentDirrh   rm   rv   ÚstringEndArchiverK   rJ   ÚstructEndArchiveÚlistÚappendr“   ÚmaxÚZIP_MAX_COMMENTÚrfindÚ_ECD_COMMENT_SIZE)	rƒ   ÚfilesizerS   r…   ÚmaxCommentStartÚstartÚrecDataÚcommentSizeÚcomments	            r   rg   rg   '  s°  € ð 	‡IIˆa„OØy‰y‹{€Hð
Ø	‰	”>/ 1Ô%ð 9‰9”^Ó$€DÜˆD‹	”^Ó#ØˆQˆqˆ	Ô%Ó%ØˆRˆSˆ	[Ó ä—’Ô/°Ó6ˆÜF‹|ˆð 	‰cÔØ‰h¤Ñ/Ô0ô ˜T¤N ?°FÓ;Ð;ô ˜(¤_Ñ4´~ÑEÀqÓI€OØ‡IIˆo˜qÔ!Ø9‰9”_¤~Ñ5Ó6€DØJ‰JÔ'Ó(€EØƒzà˜U¤>Ñ1Ð2ˆÜˆw‹<œ>Ó)àÜ”f—m’mÔ$4°gÓ>Ó?ˆØÔ.Ñ/ˆØœ^Ñ+¨E´.Ñ,@ÀÑ,LÐMˆØ‰gÔØ‰oÑ-Ô.ô ˜T°UÑ#:¸XÑ#EØ#ó%ð 	%ð øôW ó Ùðús   ¤G Ç
G"Ç!G"c                 óš  • U R                  [        S5      5      nUS:¼  a  U SU n [        R                  S:w  a4  [        R                  U ;   a   U R	                  [        R                  S5      n [        R
                  (       aH  [        R
                  S:w  a4  [        R
                  U ;   a   U R	                  [        R
                  S5      n U $ )zvTerminate the file name at the first null byte and
ensure paths always use forward slashes as the directory separator.r   Ú/)ÚfindÚchrÚosÚsepÚreplaceÚaltsep)rq   Ú	null_bytes     r   Ú_sanitize_filenamer¯   c  s   € ð —‘œc !›fÓ%€IØAƒ~Ø˜A˜iÐ(ˆô 
‡vvƒ}œŸ™ 8Ó+Ø×#Ñ#¤B§F¡F¨CÓ0ˆÜ	‡y‡y”R—Y‘Y #Ó%¬"¯)©)°xÓ*?Ø×#Ñ#¤B§I¡I¨sÓ3ˆØ€Or   c                   ó˜   • \ rS rSrSrSrSS jr\S 5       r\R                  S 5       rS r
SS	 jrS
 rS r\SSS.S jj5       rS rSrg)r   iv  z>Class with attributes describing each file in the ZIP archive.)Úorig_filenamerq   Ú	date_timeÚcompress_typeÚcompress_levelr¥   rU   Úcreate_systemr‹   Úextract_versionÚreservedÚ	flag_bitsÚvolumeÚinternal_attrÚexternal_attrÚheader_offsetÚCRCÚcompress_sizeÚ	file_sizeÚ	_raw_timeÚ_end_offsetc                 óˆ  • Xl         [        U5      nXl        X l        US   S:  a  [	        S5      e[
        U l        S U l        SU l        SU l	        [        R                  S:X  a  SU l        OSU l        [        U l        [        U l        SU l        SU l        SU l        SU l        SU l        SU l        SU l        S U l        g )Nr   é¼  z+ZIP does not support timestamps before 1980r   Úwin32r'   )r±   r¯   rq   r²   Ú
ValueErrorr   r³   r´   r¥   rU   ÚsysÚplatformrµ   ÚDEFAULT_VERSIONr‹   r¶   r·   r¸   r¹   rº   r»   r¾   r¿   rÁ   )rE   rq   r²   s      r   rF   ÚZipInfo.__init__‘  sÀ   € Ø%Ôô & hÓ/ˆà ŒØ"ŒàQ‰<˜$ÓÜÐJÓKÐKô (ˆÔØ"ˆÔØˆŒØˆŒ
Ü<‰<˜7Ó"Ø!"ˆDÕð "#ˆDÔÜ-ˆÔÜ.ˆÔØˆŒØˆŒØˆŒØˆÔØˆÔØˆÔØˆŒØˆÕr   c                 ó   • U R                   $ r;   ©r´   ©rE   s    r   Ú_compresslevelÚZipInfo._compresslevel·  s   € à×"Ñ"Ð"r   c                 ó   • Xl         g r;   rË   )rE   Úvalues     r   rÍ   rÎ   »  s   € à#Õr   c                 ó\  • SU R                   R                  < SU R                  < 3/nU R                  [        :w  a<  UR                  S[        R                  U R                  U R                  5      -  5        U R                  S-	  nU R                  S-  nU(       a(  UR                  S[        R                  " U5      -  5        U(       a  UR                  SU-  5        U R                  5       nU(       a  U R                  (       a  UR                  SU R                  -  5        U(       a  U R                  (       aL  U R                  [        :w  d  U R                  U R                  :w  a  UR                  S	U R                  -  5        UR                  S
5        SR                  U5      $ )NÚ<z
 filename=ú compress_type=%sr1   r   z filemode=%rz external_attr=%#xz file_size=%rz compress_size=%rÚ>Ú )rA   r   rq   r³   r   r›   Úcompressor_namesÚgetr»   ÚstatÚfilemodeÚis_dirr¿   r¾   r_   )rE   rr   ÚhiÚloÚisdirs        r   Ú__repr__ÚZipInfo.__repr__¿  s;   Ø'+§~¡~×'>Ô'>ÀÇÃÐNÐOˆØ×Ñ¤Ó+ØM‰MÐ-Ü*×.Ñ.¨t×/AÑ/AØ/3×/AÑ/AóCñCô Dð ×Ñ 2Ñ%ˆØ×Ñ &Ñ(ˆÞØM‰M˜.¬4¯=ª=¸Ó+<Ñ<Ô=ÞØM‰MÐ.°Ñ3Ô4Ø—‘“ˆÞ˜ŸŸØM‰M˜/¨D¯N©NÑ:Ô;Þ˜$×,×,Ø×Ñ¤:Ó-Ø^‰^˜t×1Ñ1Ó1ØM‰MÐ-°×0BÑ0BÑBÔCØ‰cÔØw‰wv‹Ðr   Nc                 óÂ  • U R                   nUS   S-
  S-  US   S-  -  US   -  nUS   S-  US	   S-  -  US   S-  -  nU R                  [        -  (       a  S=n=pgO$U R                  nU R                  nU R
                  nU R                  nSn	Uc  U[        :„  =(       d	    U[        :„  nU(       a?  S
n
U[        R                  " U
S[        R                  " U
5      S	-
  Xv5      -   nSnSn[        n	U R                  [        :X  a  [        [        U	5      n	O$U R                  [         :X  a  [        ["        U	5      n	[        XR$                  5      U l        [        XR&                  5      U l        U R)                  5       u  p¼[        R                  " [*        [,        U R$                  U R.                  UU R                  XCUXg[1        U5      [1        U5      5      nXÛ-   U-   $ )z½Return the per-file header as a bytes object.

When the optional zip64 arg is None rather than a bool, we will
decide based upon the file_size and compress_size, if known,
False otherwise.
r   rÃ   r,   r%   r)   r&   r'   r.   r(   z<HHQQì   ÿÿ )r²   r¸   Ú_MASK_USE_DATA_DESCRIPTORr½   r¾   r¿   rU   ÚZIP64_LIMITrK   ÚpackÚcalcsizeÚZIP64_VERSIONr³   r   rœ   ÚBZIP2_VERSIONr	   ÚLZMA_VERSIONr¶   r‹   Ú_encodeFilenameFlagsÚstructFileHeaderÚstringFileHeaderr·   rv   )rE   Úzip64ÚdtÚdosdateÚdostimer½   r¾   r¿   rU   Úmin_versionÚfmtrq   r¸   Úheaders                 r   Ú
FileHeaderÚZipInfo.FileHeaderÕ  sÀ  € ð ^‰^ˆØa‘5˜4‘< AÑ%¨¨1©°©
Ñ2°R¸±UÑ:ˆØQ‘%˜2‘+  1¡¨¡
Ñ*¨b°©e°q©jÑ9ˆØ>‰>Ô5×5à./Ð/ˆCÐ/- )à—(‘(ˆCØ ×.Ñ.ˆMØŸ™ˆIà—
‘
ˆàˆØ‰=ð ¤Ñ+×J¨}¼{Ñ/JˆEÞØˆCØœFŸKšK¨Ø()¬6¯?ª?¸3Ó+?ÀÑ+AÀ9ó]ñ ]ˆEà"ˆIØ&ˆMÜ'ˆKà×Ñ¤Ó*Üœm¨[Ó9‰KØ×Ñ¤8Ó+Üœl¨KÓ8ˆKä" ;×0DÑ0DÓEˆÔÜ! +×/BÑ/BÓCˆÔØ"×7Ñ7Ó9ÑˆÜ—’Ô-Ô/?Ø!×1Ñ1°4·=±=À)Ø!×/Ñ/°À3Ø*Ü  ›]¬C°«Jó	8ˆð
 Ñ  5Ñ(Ð(r   c                 óÎ   •  U R                   R                  S5      U R                  4$ ! [         a1    U R                   R                  S5      U R                  [        -  4s $ f = f)NÚasciiúutf-8)rq   Úencoder¸   ÚUnicodeEncodeErrorÚ_MASK_UTF_FILENAMErÌ   s    r   ré   ÚZipInfo._encodeFilenameFlags  s[   € ð	VØ—=‘=×'Ñ'¨Ó0°$·.±.Ð@Ð@øÜ!ó 	VØ—=‘=×'Ñ'¨Ó0°$·.±.ÔCUÑ2UÐUÒUð	Vús   ‚&) ©8A$Á#A$c                 ó¢  • U R                   n[        R                  n[        U5      S:¼  Ga:  U" SUS S 5      u  pEUS-   [        U5      :”  a  [	        SXE4-  5      eUS:X  aƒ  USUS-    n U R
                  S;   a  SnU" SUS S 5      u  U l        USS  nU R                  S	:X  a  S
nU" SUS S 5      u  U l        USS  nU R                  S	:X  a  SnU" SUS S 5      u  U l        OhUS:X  ab  USUS-    n U" SUS S 5      u  p‰US:X  aE  X‘:X  a@  USS  R                  S5      n
U
(       a  [        U
5      U l        OSS KnUR                  SSS9  X%S-   S  n[        U5      S:¼  a  GM9  g g ! [        R                   a    [	        SW S35      S ef = f! [        R                   a  n[	        S5      UeS nAf[         a  n[	        S5      UeS nAff = f)Nr(   r9   z"Corrupt extra field %04x (size=%d)r%   )l   ÿÿÿÿ rá   z	File sizez<Qr   rá   zCompress sizezHeader offsetzCorrupt zip64 extra field. z not found.iup  z<BLr)   r÷   r   z'Empty unicode path extra field (0x7075)r&   ©Ú
stacklevelz)Corrupt unicode path extra field (0x7075)z>Corrupt unicode path extra field (0x7075): invalid utf-8 bytes)rU   rK   rJ   rv   r   r¿   r¾   r¼   r   Údecoder¯   rq   ÚwarningsÚwarnÚUnicodeDecodeError)rE   Úfilename_crcrU   rJ   ÚtpÚlnrS   ÚfieldÚ
up_versionÚup_name_crcÚup_unicode_namer   Úes                r   Ú_decodeExtraÚZipInfo._decodeExtra  s  € à—
‘
ˆÜ—‘ˆÜ%‹j˜AŒoÙ˜E 5¨¨! 9Ó-‰FˆBØ!‰t”c˜%“jÓ Ü Ð!EÈÈÑ!PÓQÐQØV‹|Ø˜Q˜r !™t}ðFØ—~‘~Ð)MÓMØ +˜Ù*0°°t¸B¸Q°xÓ*@™˜œØ# A B˜x˜Ø×)Ñ)¨[Ó8Ø /˜Ù.4°T¸4ÀÀ¸8Ó.DÑ+˜Ô*Ø# A B˜x˜Ø×)Ñ)¨[Ó8Ø /˜Ù.4°T¸4ÀÀ¸8Ó.DÑ+˜Ô*øð v“Ø˜Q˜r !™t}ðnÙ.4°U¸DÀÀ!¸HÓ.EÑ+JØ! Q“¨;Ó+FØ*.¨q¨r¨(¯/©/¸'Ó*B˜Þ*Ü,>¸Ó,O˜DMã+Ø$ŸM™MÐ*SÐ`a˜MÑbð ˜Q™$˜%LˆEôO %‹j˜Aoˆoøô& —|‘|ó FÜ$Ð'BØ(- w¨kð&;ó <ØAEðFðFûô —|‘|ó YÜ$Ð%PÓQÐWXÐXûÜ)ó nÜ$Ð%eÓfÐlmÐmûðnús8   Á+A9E( Ã4AF Ä9F Å(%FÆGÆ$F0Æ0GÆ=G	Ç	GT©Ústrict_timestampsc                ód  • [        U[        R                  5      (       a  [        R                  " U5      n[        R                  " U5      n[        R
                  " UR                  5      n[        R                  " UR                  5      nUSS nU(       d  US   S:  a  SnOU(       d  US   S:”  a  SnUc  Un[        R                  R                  [        R                  R                  U5      S   5      nUS   [        R                  [        R                  4;   a.  USS nUS   [        R                  [        R                  4;   a  M.  U(       a  US	-  nU " X'5      nUR                  S
-  S-  Ul        U(       a  SUl        U=R                  S-  sl        U$ UR"                  Ul        U$ )a7  Construct an appropriate ZipInfo for a file on the filesystem.

filename should be the path to a file or directory on the filesystem.

arcname is the name which it will have within the archive (by default,
this will be the same as filename, but without a drive letter and with
leading path separators removed).
r   r*   rÃ   ©rÃ   r%   r%   r   r   r   é;  )r  r   é   é   é;   r  Nr%   r§   r   r1   )Ú
isinstancerª   ÚPathLikeÚfspathrØ   ÚS_ISDIRÚst_modeÚtimeÚ	localtimeÚst_mtimeÚpathÚnormpathÚ
splitdriver«   r­   r»   r¿   Úst_size)	r>   rq   Úarcnamer  ÚstrÝ   Úmtimer²   Úzinfos	            r   Ú	from_fileÚZipInfo.from_file8  sW  € ô h¤§¡×,Ñ,Ü—y’y Ó*ˆHÜWŠWXÓˆÜ—’˜RŸZ™ZÓ(ˆÜ—’˜rŸ{™{Ó+ˆØ˜!˜AJˆ	Þ  Y¨q¡\°DÓ%8Ø-‰IÞ" y°¡|°dÓ':Ø2ˆIà‰?ØˆGÜ—'‘'×"Ñ"¤2§7¡7×#5Ñ#5°gÓ#>¸qÑ#AÓBˆØa‰jœRŸV™V¤R§Y¡YÐ/Ó/Ø˜a˜bkˆGð a‰jœRŸV™V¤R§Y¡YÐ/Õ/æØs‰NˆGÙGÓ'ˆØ!Ÿz™z¨FÑ2°rÑ9ˆÔÞØˆEŒOØ×Ò 4Ñ'Õð ˆð !Ÿj™jˆEŒOàˆr   c                 ó  • U R                   R                  S5      (       a  g[        R                  R                  (       aM  U R                   R                  [        R                  R
                  [        R                  R                  45      $ g)z2Return True if this archive member is a directory.r§   TF)rq   Úendswithrª   r  r­   r«   rÌ   s    r   rÚ   ÚZipInfo.is_dir^  sT   € à=‰=×!Ñ! #×&Ñ&Øô
 7‰7>>Ø—=‘=×)Ñ)¬2¯7©7¯;©;¼¿¹¿¹Ð*GÓHÐHØr   )rÁ   r¥   r´   r¾   r³   rµ   r‹   r²   r»   rU   r¶   r¿   rq   r¸   r¼   rº   r±   r·   r¹   )ÚNoNamer  r;   )r   r   r   r   r   Ú	__slots__rF   ÚpropertyrÍ   ÚsetterrÞ   ró   ré   r  rc   r%  rÚ   r   r   r   r   r   r   v  sx   † ÙHð€Iô0  ðL ñ#ó ð#ð ×Ññ$ó ð$òô,.)ò`Vò+!ðZ ð#ÀDõ #ó ð#õJ
r   r   c                 ó\   • [        S5       H  nU S-  (       a
  U S-	  S-  n M  U S-  n M     U $ )Nr   r%   l    q[ )Úrange)ÚcrcÚjs     r   Ú_gen_crcr2  p  s5   € Ü1ŽXˆØ7Ø˜!‘8˜zÑ)ŠCàA‰IŠCñ	 ð
 €Jr   c                 óÊ   ^^^^^^• SmSmSm[         c"  [        [        [        [	        S5      5      5      q [         mU4S jmUUUU4S jmU  H  nT" U5        M     UU4S jnU$ )NixV4i‰gE#ixV4é   c                 ó$   >• US-	  TX-  S-     -  $ )z(Compute the CRC32 primitive on one byte.r   éÿ   r   )Úchr0  Úcrctables     €r   Úcrc32Ú_ZipDecrypter.<locals>.crc32Š  s   ø€ àq‘˜H c¡h°$Ñ%6Ñ7Ñ7Ð7r   c                 ó\   >• T" U T5      mTTS-  -   S-  mTS-  S-   S-  mT" TS-	  T5      mg )Nr6  rá   i„r%   é   r   )Úcr9  Úkey0Úkey1Úkey2s    €€€€r   Úupdate_keysÚ"_ZipDecrypter.<locals>.update_keysŽ  sE   ø€ áQ˜‹~ˆØ˜˜t™Ñ$¨
Ñ2ˆØyÑ  1Ñ$¨
Ñ2ˆÙT˜R‘Z Ó&‰r   c                 ó¢   >• [        5       nUR                  nU  H(  nTS-  nX4US-  -  S-	  S-  -  nT" U5        U" U5        M*     [        U5      $ )zDecrypt a bytes object.r&   r%   r   r6  )Ú	bytearrayr›   Úbytes)rS   rr   r›   r=  Úkr@  rA  s        €€r   Ú	decrypterÚ _ZipDecrypter.<locals>.decrypter˜  sZ   ø€ ä“ˆØ—‘ˆÛˆAØq‘ˆAØ˜˜!™‘9 Ñ" dÑ*Ñ*ˆAÙ˜ŒNÙ1ŽIñ	 ô
 V‹}Ðr   )Ú	_crctablerš   Úmapr2  r/  )	ÚpwdÚprG  r9  r8  r>  r?  r@  rA  s	      @@@@@@r   Ú_ZipDecrypterrM  €  sc   ý€ Ø€DØ€DØ€Dô ÑÜœœX¤u¨S£zÓ2Ó3ˆ	Ü€Hõ8÷'ð 'ó ˆÙAŽñ ö	ð Ðr   c                   ó,   • \ rS rSrS rS rS rS rSrg)ÚLZMACompressori¦  c                 ó   • S U l         g r;   ©Ú_comprÌ   s    r   rF   ÚLZMACompressor.__init__¨  s	   € Øˆ
r   c                 ó0  • [         R                  " S[         R                  05      n[         R                  " [         R                  [         R
                  " [         R                  U5      /S9U l        [        R                  " SSS[        U5      5      U-   $ )Nr@   ©Úfiltersz<BBHr,   r(   )
ÚlzmaÚ_encode_filter_propertiesÚFILTER_LZMA1rO  Ú
FORMAT_RAWÚ_decode_filter_propertiesrR  rK   rä   rv   )rE   Úpropss     r   Ú_initÚLZMACompressor._init«  sq   € Ü×.Ò.°´d×6GÑ6GÐ/HÓIˆÜ×(Ò(¬¯©Ü×*Ò*¬4×+<Ñ+<¸eÓDðC
ñ ˆŒ
ô {Š{˜6 1 a¬¨U«Ó4°uÑ<Ð<r   c                 óª   • U R                   c,  U R                  5       U R                   R                  U5      -   $ U R                   R                  U5      $ r;   )rR  r]  Úcompress©rE   rS   s     r   r`  ÚLZMACompressor.compress²  sA   € Ø:‰:ÑØ—:‘:“< $§*¡*×"5Ñ"5°dÓ";Ñ;Ð;Øz‰z×"Ñ" 4Ó(Ð(r   c                 ó¦   • U R                   c+  U R                  5       U R                   R                  5       -   $ U R                   R                  5       $ r;   )rR  r]  ÚflushrÌ   s    r   rd  ÚLZMACompressor.flush·  s=   € Ø:‰:ÑØ—:‘:“< $§*¡*×"2Ñ"2Ó"4Ñ4Ð4Øz‰z×ÑÓ!Ð!r   rQ  N)	r   r   r   r   rF   r]  r`  rd  r   r   r   r   rO  rO  ¦  s   † òò=ò)õ
"r   rO  c                   ó    • \ rS rSrS rS rSrg)ÚLZMADecompressori½  c                 ó.   • S U l         SU l        SU l        g )Nr   F©Ú_decompÚ_unconsumedÚeofrÌ   s    r   rF   ÚLZMADecompressor.__init__¿  s   € ØˆŒØˆÔØˆr   c           
      óP  • U R                   câ  U =R                  U-  sl        [        U R                  5      S::  a  g[        R                  " SU R                  SS 5      u  n[        U R                  5      SU-   ::  a  g[
        R                  " [
        R                  [
        R                  " [
        R                  U R                  SSU-    5      /S9U l         U R                  SU-   S  nU ?U R                   R                  U5      nU R                   R                  U l        U$ )Nr(   r   z<Hr&   rU  )rj  rk  rv   rK   rJ   rW  rg  rZ  r[  rY  Ú
decompressrl  )rE   rS   Úpsizerr   s       r   ro  ÚLZMADecompressor.decompressÄ  sý   € Ø<‰<ÑØ×Ò Ñ$ÕÜ4×#Ñ#Ó$¨Ó)ØÜ—]’] 4¨×)9Ñ)9¸!¸AÐ)>Ó?‰FˆEÜ4×#Ñ#Ó$¨¨E©	Ó1Øä×0Ò0´·±Ü×.Ò.¬t×/@Ñ/@Ø/3×/?Ñ/?ÀÀ!ÀeÁ)Ð/LóNðKñ ˆDŒLð ×#Ñ# A¨¡I JÐ/ˆDØÐ à—‘×(Ñ(¨Ó.ˆØ—<‘<×#Ñ#ˆŒØˆr   ri  N)r   r   r   r   rF   ro  r   r   r   r   rg  rg  ½  s   † òõ
r   rg  ÚstoreÚshrinkÚreduceÚimplodeÚtokenizeÚdeflateÚ	deflate64Úbzip2rW  Úterseé   Úlz77éa   Úwavpackéb   Úppmdc                 óô   • U [         :X  a  g U [        :X  a  [        (       d  [        S5      eg U [        :X  a  [
        (       d  [        S5      eg U [        :X  a  [        (       d  [        S5      eg [        S5      e)Nz.Compression requires the (missing) zlib modulez-Compression requires the (missing) bz2 modulez.Compression requires the (missing) lzma modulez(That compression method is not supported)	r   r   ÚzlibÚRuntimeErrorr   Úbz2r	   rW  ÚNotImplementedError)Úcompressions    r   Ú_check_compressionr‡  í  s‹   € Ø”jÓ ØØ	œÓ	$ßŠtÜØ@óBð Bð ð 
œ	Ó	!ßŠsÜØ?óAð Að ð 
œÓ	 ßŠtÜØ@óBð Bð ô "Ð"LÓMÐMr   c                 ój  • U [         :X  a]  Ub&  [        R                  " U[        R                  S5      $ [        R                  " [        R                  [        R                  S5      $ U [
        :X  a.  Ub  [        R                  " U5      $ [        R                  " 5       $ U [        :X  a
  [        5       $ g )Néñÿÿÿ)
r   r‚  ÚcompressobjÚDEFLATEDÚZ_DEFAULT_COMPRESSIONr   r„  ÚBZ2Compressorr	   rO  )r³   Úcompresslevels     r   Ú_get_compressorr     sŠ   € ØœÓ$ØÑ$Ü×#Ò# M´4·=±=À#ÓFÐFÜ×Ò¤× :Ñ :¼D¿M¹MÈ3ÓOÐOØ	œ)Ó	#ØÑ$Ü×$Ò$ ]Ó3Ð3Ü× Ò Ó"Ð"à	œ(Ó	"ÜÓÐàr   c                 óH  • [        U 5        U [        :X  a  g U [        :X  a  [        R                  " S5      $ U [
        :X  a  [        R                  " 5       $ U [        :X  a
  [        5       $ [        R                  U 5      nU(       a  [        SX4-  5      e[        SU 4-  5      e)Nr‰  zcompression type %d (%s)zcompression type %d)r‡  r   r   r‚  Údecompressobjr   r„  ÚBZ2Decompressorr	   rg  rÖ   r×   r…  )r³   Údescrs     r   Ú_get_decompressorr”    s‘   € Ü}Ô%Øœ
Ó"ØØ	œ,Ó	&Ü×!Ò! #Ó&Ð&Ø	œ)Ó	#Ü×"Ò"Ó$Ð$Ø	œ(Ó	"ÜÓ!Ð!ä ×$Ñ$ ]Ó3ˆÞÜ%Ð&@ÀMÐCYÑ&YÓZÐZä%Ð&;¸}Ð>NÑ&NÓOÐOr   c                   ó:   • \ rS rSrS rS rS	S jrS
S jrS rSr	g)Ú_SharedFilei"  c                 ób   • Xl         X l        X0l        X@l        XPl        UR
                  U l        g r;   )Ú_fileÚ_posÚ_closeÚ_lockÚ_writingÚseekable)rE   ÚfileÚposÚcloseÚlockÚwritings         r   rF   Ú_SharedFile.__init__#  s&   € ØŒ
ØŒ	ØŒØŒ
ØŒØŸ™ˆr   c                 ó   • U R                   $ r;   )r™  rÌ   s    r   r–   Ú_SharedFile.tell+  s   € Øy‰yÐr   c                 ó–  • U R                      U R                  5       (       a  [        S5      eU[        R                  :X  a)  U R
                  R                  U R                  U-   5        OU R
                  R                  X5        U R
                  R                  5       U l        U R                  sS S S 5        $ ! , (       d  f       g = f)Nz}Can't reposition in the ZIP file while there is an open writing handle on it. Close the writing handle before trying to read.)	r›  rœ  rÅ   rª   ÚSEEK_CURr˜  rt   r™  r–   )rE   r„   Úwhences      r   rt   Ú_SharedFile.seek.  sƒ   € ØZ‹ZØ}‰}‰Ü ð "Jó Kð Kð œŸ™Ó$Ø—
‘
—‘ §	¡	¨FÑ 2Õ3à—
‘
—‘ Ô/ØŸ
™
Ÿ™Ó)ˆDŒIØ—9‘9÷ ZZús   B#B:Â:
Cc                 óR  • U R                      U R                  5       (       a  [        S5      eU R                  R	                  U R
                  5        U R                  R                  U5      nU R                  R                  5       U l        UsS S S 5        $ ! , (       d  f       g = f)NúyCan't read from the ZIP file while there is an open writing handle on it. Close the writing handle before trying to read.)r›  rœ  rÅ   r˜  rt   r™  rm   r–   ©rE   ÚnrS   s      r   rm   Ú_SharedFile.read;  sp   € ØZ‹ZØ}‰}‰Ü ð "Jó Kð Kð J‰JO‰O˜DŸI™IÔ&Ø—:‘:—?‘? 1Ó%ˆDØŸ
™
Ÿ™Ó)ˆDŒIØ÷ ZZús   BBÂ
B&c                 óh   • U R                   b%  U R                   nS U l         U R                  U5        g g r;   )r˜  rš  )rE   Úfileobjs     r   r   Ú_SharedFile.closeF  s-   € Ø:‰:Ñ!Ø—j‘jˆGØˆDŒJØK‰K˜Õ ð "r   )rš  r˜  r›  r™  rœ  r  N)r   ©éÿÿÿÿ)
r   r   r   r   rF   r–   rt   rm   r   r   r   r   r   r–  r–  "  s   † ò&òôô	õ!r   r–  c                   ó2   • \ rS rSrS rS rS rS rS rSr	g)	Ú	_TellableiM  c                 ó   • Xl         SU l        g ©Nr   ©rj   r„   ©rE   rj   s     r   rF   Ú_Tellable.__init__N  s   € ØŒØˆr   c                 óf   • U R                   R                  U5      nU =R                  U-  sl        U$ r;   )rj   Úwriter„   )rE   rS   r­  s      r   r¼  Ú_Tellable.writeR  s'   € ØG‰GM‰M˜$ÓˆØŠqÑØˆr   c                 ó   • U R                   $ r;   )r„   rÌ   s    r   r–   Ú_Tellable.tellW  s   € Ø{‰{Ðr   c                 ó8   • U R                   R                  5         g r;   )rj   rd  rÌ   s    r   rd  Ú_Tellable.flushZ  ó   € Ø‰‰r   c                 ó8   • U R                   R                  5         g r;   )rj   r   rÌ   s    r   r   Ú_Tellable.close]  rÂ  r   r¸  N)
r   r   r   r   rF   r¼  r–   rd  r   r   r   r   r   rµ  rµ  M  s   † òòò
òõr   rµ  c                   óº   ^ • \ rS rSrSrSrSrSr  SS jrS r	S r
SS	 jrSS
 jrS rSS jrS rS rS rS rU 4S jrS r\R,                  4S jrS rSrU =r$ )Ú
ZipExtFileia  zOFile-like object for reading an archive member.
Is returned by ZipFile.open().
i   @i   i   c                 ó¨  • Xl         X@l        XPl        UR                  U l        UR
                  U l        UR                  U l        [        U R                  5      U l
        SU l        SU l        SU l        S U l        X l        UR                   U l        [%        US5      (       a"  UR&                  U l        [+        S5      U l        OS U l        SU l         UR1                  5       (       a`  UR3                  5       U l        UR
                  U l        UR                  U l        U R,                  U l        U R(                  U l        SU l        S U l         U(       ak  URB                  [D        -  (       a  URF                  S-	  S-  nOUR&                  S-	  S-  nU RI                  5       nXv:w  a  [K        S	URL                  -  5      eg g ! [>         a     N†f = f)
NFr   r   r½   Tr   r6  r<  zBad password for file %r)'Ú_fileobjÚ_pwdÚ_close_fileobjr³   Ú_compress_typer¾   Ú_compress_leftr¿   Ú_leftr”  Ú_decompressorÚ_eofÚ_readbufferÚ_offsetÚnewlinesÚmoderq   Únamero   r½   Ú_expected_crcr9  Ú_running_crcÚ	_seekabler  r–   Ú_orig_compress_startÚ_orig_compress_sizeÚ_orig_file_sizeÚ_orig_start_crcÚ	_orig_crcÚAttributeErrorÚ
_decrypterr¸   râ   rÀ   Ú_init_decrypterrƒ  r±   )rE   r°  rÓ  ÚzipinforK  Úclose_fileobjÚ
check_byteÚhs           r   rF   ÚZipExtFile.__init__o  sž  € àŒØŒ	Ø+Ôà%×3Ñ3ˆÔØ%×3Ñ3ˆÔØ×&Ñ&ˆŒ
ä.¨t×/BÑ/BÓCˆÔàˆŒ	ØˆÔØˆŒàˆŒàŒ	Ø×$Ñ$ˆŒ	ä7˜E×"Ñ"Ø!(§¡ˆDÔÜ % c£
ˆDÕà!%ˆDÔàˆŒð		Ø×Ñ×!Ñ!Ø,3¯L©L«NÔ)Ø+2×+@Ñ+@Ô(Ø'.×'8Ñ'8Ô$Ø'+×'8Ñ'8Ô$Ø!%×!3Ñ!3”Ø!%”ð ˆŒÞØ× Ñ Ô#<×<à%×/Ñ/°1Ñ4¸Ñ<‘
ð &Ÿk™k¨RÑ/°4Ñ7
Ø×$Ñ$Ó&ˆAØ‹Ü"Ð#=À×@UÑ@UÑ#UÓVÐVð ð øô	 ó 	Ùð	ús   ÃA5G Ç
GÇGc                 ó¾   • [        U R                  5      U l        U R                  R	                  S5      nU =R
                  S-  sl        U R                  U5      S   $ )Nr   r.   )rM  rÉ  rÞ  rÈ  rm   rÌ  )rE   rò   s     r   rß  ÚZipExtFile._init_decrypter£  sM   € Ü'¨¯	©	Ó2ˆŒð —‘×#Ñ# BÓ'ˆØ×Ò˜rÑ!ÕØ‰˜vÓ& rÑ*Ð*r   c                 óÐ  • SU R                   R                  < SU R                   R                  < 3/nU R                  (       dp  UR	                  SU R
                  < 35        U R                  [        :w  a<  UR	                  S[        R                  U R                  U R                  5      -  5        OUR	                  S5        UR	                  S5        SR                  U5      $ )NrÒ   Ú.z name=rÓ   ú	 [closed]rÔ   rÕ   )rA   r   r   Úclosedr›   rÔ  rË  r   rÖ   r×   r_   ©rE   rr   s     r   rÞ   ÚZipExtFile.__repr__®  s¯    Ø"Ÿn™n×7Ô7Ø"Ÿn™n×9Ó9ð;ð <ˆà{{ØMŠM¨¯	«	Ð3Ô4Ø×"Ñ"¤jÓ0Ø—‘Ð1Ü.×2Ñ2°4×3FÑ3FØ37×3FÑ3FóHñHô Iøð M‰M˜+Ô&Ø‰cÔØw‰wv‹Ðr   c                 óì   • US:  aP  U R                   R                  SU R                  5      S-   nUS:”  a!  U R                   U R                  U nX l        U$ [        R                  R                  X5      $ )zbRead and return a line from the stream.

If limit is specified, at most limit bytes will be read.
r   ó   
r%   )rÐ  r¨   rÑ  ÚioÚBufferedIOBaseÚreadline)rE   ÚlimitÚiÚlines       r   rñ  ÚZipExtFile.readline¼  sj   € ð 1‹9à× Ñ ×%Ñ% e¨T¯\©\Ó:¸QÑ>ˆAØ1‹uØ×'Ñ'¨¯©°aÐ8Ø ”Øä× Ñ ×)Ñ)¨$Ó6Ð6r   c                 óz  • U[        U R                  5      U R                  -
  :”  ap  U R                  U5      n[        U5      U R                  :”  a(  X R                  U R                  S -   U l        SU l        OU =R                  [        U5      -  sl        U R                  U R                  U R                  S-    $ )z6Returns buffered bytes without advancing the position.Nr   i   )rv   rÐ  rÑ  rm   )rE   r­  Úchunks      r   ÚpeekÚZipExtFile.peekÌ  s’   € àŒs4×#Ñ#Ó$ t§|¡|Ñ3Ó3Ø—I‘I˜a“LˆEÜ5‹z˜DŸL™LÓ(Ø#(×+;Ñ+;¸D¿L¹L¸MÐ+JÑ#JÔ Ø •à—’¤ E£
Ñ*•ð ×Ñ §¡¨d¯l©l¸SÑ.@ÐAÐAr   c                 ó<   • U R                   (       a  [        S5      eg)NúI/O operation on closed file.T)rê  rÅ   rÌ   s    r   ÚreadableÚZipExtFile.readableÙ  s   € Ø;;ÜÐ<Ó=Ð=Ør   c                 ó"  • U R                   (       a  [        S5      eUb  US:  aj  U R                  U R                  S nSU l        SU l        U R                  (       d0  X R                  U R                  5      -  nU R                  (       d  M0  U$ XR                  -   nU[        U R                  5      :  a!  U R                  U R                  U nX0l        U$ U[        U R                  5      -
  nU R                  U R                  S nSU l        SU l        US:”  ar  U R                  (       da  U R                  U5      nU[        U5      :  a  X@l        Xl        X$SU -  n U$ X$-  nU[        U5      -  nUS:”  a  U R                  (       d  Ma  U$ )z~Read and return up to n bytes.
If the argument is omitted, None, or negative, data is read and returned until EOF is reached.
zread from closed file.Nr   r   )rê  rÅ   rÐ  rÑ  rÏ  Ú_read1ÚMAX_Nrv   )rE   r­  ÚbufÚendrS   s        r   rm   ÚZipExtFile.readÞ  sa  € ð ;;ÜÐ5Ó6Ð6Ø‰9˜˜A›Ø×"Ñ" 4§<¡< =Ð1ˆCØ"ˆDÔØˆDŒLØ—i—iØ—{‘{ 4§:¡:Ó.Ñ.ð —i—i‘iàˆJà—,‘,ÑˆØ”T×%Ñ%Ó&Ó&Ø×"Ñ" 4§<¡<°Ð4ˆCØŒLØˆJà”#d×&Ñ&Ó'Ñ'ˆØ×Ñ˜tŸ|™|˜}Ð-ˆØˆÔØˆŒØ!‹e˜DŸIŸIØ—;‘;˜q“>ˆDØ”3t“9‹}Ø#'Ô Ø ”Ø˜B˜Qx‘Øð ˆ
ð ‰KˆCØ”T“‰NˆAð !‹e˜DŸIŸI™Ið ˆ
r   c                 óÜ   • U R                   c  g [        XR                  5      U l        U R                  (       a3  U R                  U R                   :w  a  [	        SU R
                  -  5      eg g )NzBad CRC-32 for file %r)rÕ  r9  rÖ  rÏ  r   rÔ  )rE   Únewdatas     r   Ú_update_crcÚZipExtFile._update_crc  s[   € à×ÑÑ%àÜ! '×+<Ñ+<Ó=ˆÔà99˜×*Ñ*¨d×.@Ñ.@Ó@ÜÐ5¸¿	¹	ÑAÓBÐBð Aˆ9r   c                 óî  • Ub  US:  av  U R                   U R                  S nSU l         SU l        U R                  (       d<  U R                  U R                  5      nU(       a  X#-  n U$ U R                  (       d  M<  U$ XR                  -   nU[        U R                   5      :  a!  U R                   U R                  U nX@l        U$ U[        U R                   5      -
  nU R                   U R                  S nSU l         SU l        US:”  ah  U R                  (       dW  U R                  U5      nU[        U5      :  a  X0l         Xl        X#SU -  n U$ U(       a  X#-  n U$ U R                  (       d  MW  U$ )z7Read up to n bytes with at most one read() system call.Nr   r   )rÐ  rÑ  rÏ  rÿ  r   rv   )rE   r­  r  rS   r  s        r   Úread1ÚZipExtFile.read1  sX  € ð ‰9˜˜A›Ø×"Ñ" 4§<¡< =Ð1ˆCØ"ˆDÔØˆDŒLØ—i—iØ—{‘{ 4§:¡:Ó.ÞØ‘KCØØˆJð —i—i‘ið
 ˆJà—,‘,ÑˆØ”T×%Ñ%Ó&Ó&Ø×"Ñ" 4§<¡<°Ð4ˆCØŒLØˆJà”#d×&Ñ&Ó'Ñ'ˆØ×Ñ˜tŸ|™|˜}Ð-ˆØˆÔØˆŒØˆq‹5Ø—i—iØ—{‘{ 1“~Ø”s˜4“y“=Ø'+Ô$Ø#$”LØ  ˜8‘OCØð ˆ
ö Ø‘KCØØˆ
ð —i—i‘ið ˆ
r   c                 ó*  • U R                   (       d  US::  a  gU R                  [        :X  aE  U R                  R                  nU[        U5      :”  a  X R                  U[        U5      -
  5      -  nOU R                  U5      nU R                  [        :X  a  U R                  S:*  U l         GOU R                  [        :X  a±  [        XR                  5      nU R                  R                  X!5      nU R                  R                  =(       d1    U R                  S:*  =(       a    U R                  R                  (       + U l         U R                   (       a  X R                  R                  5       -  nOLU R                  R                  U5      nU R                  R                  =(       d    U R                  S:*  U l         US U R                   nU =R                  [        U5      -  sl        U R                  S::  a  SU l         U R                  U5        U$ )Nr   r   T)rÏ  rË  r   rÎ  Úunconsumed_tailrv   Ú_read2r   rÌ  rœ   ÚMIN_READ_SIZEro  rl  rd  rÍ  r  r¬  s      r   rÿ  ÚZipExtFile._read10  sž  € ð 99˜˜Q›Øð ×Ñ¤,Ó.à×%Ñ%×5Ñ5ˆDØ”3t“9‹}ØŸ™ A¬¨D«	¡MÓ2Ñ2øà—;‘;˜q“>ˆDà×Ñ¤*Ó,Ø×+Ñ+¨qÑ0ˆDŽIØ× Ñ ¤LÓ0ÜA×)Ñ)Ó*ˆAØ×%Ñ%×0Ñ0°Ó9ˆDØ×+Ñ+×/Ñ/÷ @Ø×,Ñ,°Ñ1÷ @Ø!×/Ñ/×?Ñ?Ô?ð ŒIð yyØ×*Ñ*×0Ñ0Ó2Ñ2øà×%Ñ%×0Ñ0°Ó6ˆDØ×*Ñ*×.Ñ.×J°$×2EÑ2EÈÑ2JˆDŒIàKT—Z‘ZÐ ˆØ
Š
”c˜$“iÑ
Ø:‰:˜‹?ØˆDŒIØ×Ñ˜ÔØˆr   c                 óD  • U R                   S::  a  g[        XR                  5      n[        XR                   5      nU R                  R                  U5      nU =R                   [        U5      -  sl         U(       d  [        eU R                  b  U R                  U5      nU$ )Nr   r   )	rÌ  rœ   r  ÚminrÈ  rm   rv   ÚEOFErrorrÞ  r¬  s      r   r  ÚZipExtFile._read2T  s   € Ø×Ñ !Ó#Øä×%Ñ%Ó&ˆÜ×&Ñ&Ó'ˆà}‰}×!Ñ! !Ó$ˆØ×Òœs 4›yÑ(ÕÞÜˆNà?‰?Ñ&Ø—?‘? 4Ó(ˆDØˆr   c                 ó    >•  U R                   (       a  U R                  R                  5         [        TU ]	  5         g ! [        TU ]	  5         f = fr;   )rÊ  rÈ  r   r<   )rE   rA   s    €r   r   ÚZipExtFile.closed  s4   ø€ ð	Ø×"×"Ø—‘×#Ñ#Ô%ä‰G‰MOøŒE‰G‰MOús	   ƒ+= ½Ac                 óR   • U R                   (       a  [        S5      eU R                  $ ©Nrû  )rê  rÅ   r×  rÌ   s    r   r  ÚZipExtFile.seekablek  s   € Ø;;ÜÐ<Ó=Ð=Ø~‰~Ðr   c                 óÆ  • U R                   (       a  [        S5      eU R                  (       d  [        R                  " S5      eU R                  5       nU[        R                  :X  a  UnOHU[        R                  :X  a  X1-   nO/U[        R                  :X  a  U R                  U-   nO[        S5      eX@R                  :”  a  U R                  nUS:  a  SnXC-
  nXPR                  -   nUS:¼  a#  U[        U R                  5      :  a
  X`l        SnGO‰U R                  [        :X  a¸  U R                   c«  US:w  a¥  S U l        U[        U R                  5      U R                  -
  -  nU R$                  R'                  U[        R                  5        U =R(                  U-  sl        U =R*                  U-  sl        U R(                  S:*  U l        SnSU l        SU l        O½US:  a·  U R$                  R'                  U R.                  5        U R0                  U l        U R4                  U l        U R6                  U l        U R                  U l        SU l        SU l        [9        U R                  5      U l        SU l        UnU R                   b  U R=                  5         US:”  a3  [?        U R@                  U5      nU RC                  U5        XW-  nUS:”  a  M3  U R                  5       $ )Nzseek on closed file.ú!underlying stream is not seekablezCwhence must be os.SEEK_SET (0), os.SEEK_CUR (1), or os.SEEK_END (2)r   r   F)"rê  rÅ   r×  rï  ÚUnsupportedOperationr–   rª   ÚSEEK_SETr§  ÚSEEK_ENDrÚ  rÑ  rv   rÐ  rË  r   rÞ  rÕ  rÈ  rt   rÍ  rÌ  rÏ  rØ  rÛ  rÖ  rÜ  rÙ  r”  rÎ  rß  r  ÚMAX_SEEK_READrm   )rE   r„   r¨  Úcurr_posÚnew_posÚread_offsetÚbuff_offsetÚread_lens           r   rt   ÚZipExtFile.seekp  sg  € Ø;;ÜÐ3Ó4Ð4Ø~~Ü×)Ò)Ð*MÓNÐNØ—9‘9“;ˆØ”R—[‘[Ó Ø‰GØ”r—{‘{Ó"ØÑ'‰GØ”r—{‘{Ó"Ø×*Ñ*¨VÑ3‰Gäð Có Dð Dð ×)Ñ)Ó)Ø×*Ñ*ˆGàQ‹;ØˆGàÑ(ˆØ!§L¡LÑ0ˆà˜!Ó ¬c°$×2BÑ2BÓ.CÓ Cà&ŒLØŠKà× Ñ ¤JÓ.°4·?±?Ñ3JÈ{Ð^_ÓO_à!%ˆDÔàœ3˜t×/Ñ/Ó0°4·<±<Ñ?Ñ?ˆKØM‰M×Ñ˜{¬B¯K©KÔ8ØJŠJ˜+Ñ%JØ×Ò ;Ñ.ÕØŸ
™
 a™ˆDŒIØˆKà"ˆDÔØˆDLØ˜1‹_àM‰M×Ñ˜t×8Ñ8Ô9Ø $× 4Ñ 4ˆDÔØ!%§¡ˆDÔØ"&×":Ñ":ˆDÔØ×-Ñ-ˆDŒJØ"ˆDÔØˆDŒLÜ!2°4×3FÑ3FÓ!GˆDÔØˆDŒIØ!ˆKØ‰Ñ*Ø×$Ñ$Ô&à˜A‹oÜ˜4×-Ñ-¨{Ó;ˆHØI‰IhÔØÑ#ˆKð ˜Aoð
 y‰y‹{Ðr   c                 ó  • U R                   (       a  [        S5      eU R                  (       d  [        R                  " S5      eU R
                  U R                  -
  [        U R                  5      -
  U R                  -   nU$ )Nztell on closed file.r  )
rê  rÅ   r×  rï  r  rÚ  rÍ  rv   rÐ  rÑ  )rE   Úfileposs     r   r–   ÚZipExtFile.tell±  s`   € Ø;;ÜÐ3Ó4Ð4Ø~~Ü×)Ò)Ð*MÓNÐNØ×&Ñ&¨¯©Ñ3´c¸$×:JÑ:JÓ6KÑKÈdÏlÉlÑZˆØˆr   )rÊ  rÌ  rË  rÎ  rÞ  rÏ  rÕ  rÈ  rÍ  rÑ  rÙ  rØ  rÜ  rÚ  rÛ  rÉ  rÐ  rÖ  r×  rÓ  rÔ  rÒ  )NFr²  ©r%   )r   r   r   r   r   r   r  r  rF   rß  rÞ   rñ  rø  rü  rm   r  r	  rÿ  r  r   r  rª   r  rt   r–   r   rd   re   s   @r   rÆ  rÆ  a  s„   ø† ñð
 €Eð €Mð €Mà37Ø$ô1Wòh	+òô7ô Bòô
!òFCò#òJ"òHõ òð
 #%§+¡+ô ?÷Bð r   rÆ  c                   ój   ^ • \ rS rSrS r\S 5       r\S 5       r\S 5       rS r	S r
U 4S jrS	rU =r$ )
Ú_ZipWriteFileiº  c                 óœ   • X l         X0l        Xl        [        UR                  UR
                  5      U l        SU l        SU l        SU l	        g r·  )
Ú_zinfoÚ_zip64Ú_zipfiler  r³   r´   Ú_compressorÚ
_file_sizeÚ_compress_sizeÚ_crc)rE   Úzfr$  rì   s       r   rF   Ú_ZipWriteFile.__init__»  sF   € ØŒØŒØŒÜ*¨5×+>Ñ+>Ø+0×+?Ñ+?óAˆÔàˆŒØˆÔØˆ	r   c                 ó.   • U R                   R                  $ r;   )r.  rj   rÌ   s    r   rÈ  Ú_ZipWriteFile._fileobjÅ  s   € à}‰}×ÑÐr   c                 ó.   • U R                   R                  $ r;   )r,  rq   rÌ   s    r   rÔ  Ú_ZipWriteFile.nameÉ  s   € à{‰{×#Ñ#Ð#r   c                 ó   • g)NÚwbr   rÌ   s    r   rÓ  Ú_ZipWriteFile.modeÍ  s   € àr   c                 ó   • g)NTr   rÌ   s    r   ÚwritableÚ_ZipWriteFile.writableÑ  s   € Ør   c                 óâ  • U R                   (       a  [        S5      e[        U[        [        45      (       a  [        U5      nO[        U5      nUR                  nU =R                  U-  sl        [        XR                  5      U l
        U R                  (       a9  U R                  R                  U5      nU =R                  [        U5      -  sl        U R                  R                  U5        U$ r  )rê  rÅ   r  rE  rD  rv   rR   Únbytesr0  r9  r2  r/  r`  r1  rÈ  r¼  )rE   rS   r@  s      r   r¼  Ú_ZipWriteFile.writeÔ  s®   € Ø;;ÜÐ<Ó=Ð=ô dœU¤IÐ.×/Ñ/Ü˜“Y‰Fä˜dÓ#ˆDØ—[‘[ˆFØŠ˜6Ñ!ä˜$§	¡	Ó*ˆŒ	Ø××Ø×#Ñ#×,Ñ,¨TÓ2ˆDØ×Ò¤3 t£9Ñ,ÕØ‰×Ñ˜DÔ!Øˆr   c           	      óÔ  >• U R                   (       a  g  [        TU ]	  5         U R                  (       ao  U R                  R	                  5       nU =R
                  [        U5      -  sl        U R                  R                  U5        U R
                  U R                  l
        OU R                  U R                  l
        U R                  U R                  l        U R                  U R                  l        U R                  (       d>  U R                  [         :”  a  [#        S5      eU R
                  [         :”  a  [#        S5      eU R                  R$                  [&        -  (       a²  U R                  (       a  SOSnU R                  R                  [(        R*                  " U[,        U R                  R                  U R                  R                  U R                  R                  5      5        U R                  R/                  5       U R0                  l        OÅU R                  R/                  5       U R0                  l        U R                  R5                  U R                  R6                  5        U R                  R                 ~Ÿ  Ÿ  €Ÿ  Ÿ  ‚Ÿ  ƒŸ  „Ÿ  …Ÿ  †Ÿ  ‡Ÿ  ˆŸ  ‰Ÿ  ŠŸ  ‹Ÿ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           U R                  R9                  U R                  5      5        U R                  R5                  U R0                  R2                  5        U R0                  R:                  R=                  U R                  5        U R                  U R0                  R>                  U R                  R@                  '   SU R0                  l!        g ! SU R0                  l!        f = f)Nz*File size too large, try using force_zip64z0Compressed size too large, try using force_zip64z<LLQQz<LLLLF)"rê  r<   r   r/  rd  r1  rv   rÈ  r¼  r,  r¾   r0  r2  r½   r¿   r-  rã   rƒ  r¸   râ   rK   rä   Ú_DD_SIGNATUREr–   r.  Ú	start_dirrt   r¼   ró   Úfilelistr›   Ú
NameToInforq   rœ  )rE   r  rñ   rA   s      €r   r   Ú_ZipWriteFile.closeç  s+  ø€ Ø;;Øð(	+Ü‰G‰MŒOà××Ø×&Ñ&×,Ñ,Ó.Ø×#Ò#¤s¨3£xÑ/Õ#Ø—‘×#Ñ# CÔ(Ø,0×,?Ñ,?—‘Õ)à,0¯O©O—‘Ô)Ø"Ÿi™iˆDK‰KŒOØ$(§O¡OˆDK‰KÔ!à—;—;Ø—?‘?¤[Ó0Ü&Ð'SÓTÐTØ×&Ñ&¬Ó4Ü&Ð'YÓZÐZð {‰{×$Ñ$Ô'@×@à!%§§‘g°'Ø—‘×#Ñ#¤F§K¢K°´]ÀDÇKÁKÇOÁOØ—K‘K×-Ñ-¨t¯{©{×/DÑ/Dó%Fô Gà*.¯-©-×*<Ñ*<Ó*>—‘Õ'ð +/¯-©-×*<Ñ*<Ó*>—‘Ô'Ø—‘×"Ñ" 4§;¡;×#<Ñ#<Ô=Ø—‘×#Ñ# D§K¡K×$:Ñ$:¸4¿;¹;Ó$GÔHØ—‘×"Ñ" 4§=¡=×#:Ñ#:Ô;ð M‰M×"Ñ"×)Ñ)¨$¯+©+Ô6Ø=A¿[¹[ˆDM‰M×$Ñ$ T§[¡[×%9Ñ%9Ñ:à%*ˆDM‰MÕ"ø UˆDM‰MÕ"ús   •L-M ÍM')r1  r/  r2  r0  r,  r-  r.  )r   r   r   r   rF   r,  rÈ  rÔ  rÓ  r=  r¼  r   r   rd   re   s   @r   r*  r*  º  sX   ø† òð ñ ó ð ð ñ$ó ð$ð ñó ðòò÷&++ó ++r   r*  c                   óB  • \ rS rSrSrSrSrS\SS4SSS.S jjrS r	S	 r
S
 rS rS rS rS&S jrS rS rS r\S 5       r\R*                  S 5       rS&S jrS'SS.S jjrS(S jrS)S jrS*S jr\S 5       rS rS r  S*S jr S)S jr S+S  jr!S! r"S" r#S# r$S$ r%S%r&g),r   i  a$  Class with methods to open, read, write, close, list zip files.

z = ZipFile(file, mode="r", compression=ZIP_STORED, allowZip64=True,
            compresslevel=None)

file: Either the path to the file, or a file-like object.
      If it is a path, the file will be opened and closed by ZipFile.
mode: The mode can be either read 'r', write 'w', exclusive create 'x',
      or append 'a'.
compression: ZIP_STORED (no compression), ZIP_DEFLATED (requires zlib),
             ZIP_BZIP2 (requires bz2) or ZIP_LZMA (requires lzma).
allowZip64: if True ZipFile will create files with ZIP64 extensions when
            needed, otherwise it will raise an exception when this would
            be necessary.
compresslevel: None (default for the given compression type) or an integer
               specifying the level to pass to the compressor.
               When using ZIP_STORED or ZIP_LZMA this keyword has no effect.
               When using ZIP_DEFLATED integers 0 through 9 are accepted.
               When using ZIP_BZIP2 integers 1 through 9 are accepted.

NÚrT)r  Úmetadata_encodingc                ó
  • US;  a  [        S5      e[        U5        X@l        SU l        SU l        0 U l        / U l        X0l        XPl        X l	        SU l
        SU l        X`l        Xpl        U R                  (       a  US:w  a  [        S5      e[        U[        R                   5      (       a  [        R"                  " U5      n[        U[$        5      (       a9  SU l        Xl        S	S
SSS
SSS.nX‚   n	  [*        R,                  " X5      U l        OSU l        Xl        [3        USS5      U l        SU l        [6        R8                  " 5       U l        SU l        SU l         US:X  a  U RA                  5         gUS;   aN  SU l         U R.                  RC                  5       U l"         U R.                  RG                  U RD                  5        gUS:X  a7   U RA                  5         U R.                  RG                  U RD                  5        g[        S5      e! [0         a    X˜;   a  X‰   n	 GM7  e f = f! [H        [0        4 a
    SU l         gf = f! [H        [0        4 a+    [K        U R.                  5      U l        SU l"        SU l         gf = f! [L         aE    U R.                  RG                  SS5        SU l        U R.                  RC                  5       U l"         gf = f!   U R.                  n
SU l        U RO                  U
5        e = f)zUOpen the ZIP file with mode read 'r', write 'w', exclusive create 'x',
or append 'a'.)rI  ÚwÚxÚaz+ZipFile requires mode 'r', 'w', 'x', or 'a'Fr   Nr   rI  z5metadata_encoding is only supported for reading filesrn   úw+búx+búr+br:  Úxb)rI  rL  rM  rN  rQ  rO  rP  Tr%   rÔ  )rL  rM  rN  r&   z"Mode must be 'r', 'w', 'x', or 'a')(rÅ   r‡  Ú_allowZip64Ú
_didModifyÚdebugrF  rE  r†  rŽ  rÓ  rK  Ú_commentÚ_strict_timestampsrJ  r  rª   r  r  ÚstrÚ_filePassedrq   rï  rp   rj   rh   ÚgetattrÚ_fileRefCntÚ	threadingÚRLockr›  r×  rœ  Ú_RealGetContentsr–   rD  rt   rÝ  rµ  r   Ú_fpclose)rE   rž  rÓ  r†  Ú
allowZip64rŽ  r  rJ  ÚmodeDictrÙ   rj   s              r   rF   ÚZipFile.__init__0  s³  € ð Ð+Ó+ÜÐJÓKÐKä˜;Ô'à%ÔØˆŒØˆŒ
ØˆŒØˆŒØ&ÔØ*ÔØŒ	ØˆŒØˆŒØ"3ÔØ!2Ôð ×!×! d¨c£kÜØGóIð Iô dœBŸK™K×(Ñ(Ü—9’9˜T“?ˆDÜdœC× Ñ à ˆDÔØ ŒMØ"¨°UÀ%Ø$¨T¸$ñ@ˆHà‘~ˆHØðÜ Ÿgšg dÓ5D”Gð à ˆDÔØŒGÜ# D¨&°$Ó7ˆDŒMØˆÔÜ—_’_Ó&ˆŒ
ØˆŒØˆŒð'	Øs‹{Ø×%Ñ%Õ'Ø˜Ó#ð #'”ð/Ø%)§W¡W§\¡\£^D”Nð/ØŸ™Ÿ™ T§^¡^Õ4ð ˜“ð4à×)Ñ)Ô+à—G‘G—L‘L §¡Õ0ô !Ð!EÓFÐFøôc ó ØÓ+Ø#+Ñ#5˜Û Øð	ûô@ +¬GÐ4ó /Ø).˜žð/ûô '¬Ð0ó +Ü'¨¯©Ó0D”GØ%&D”NØ%*D–Nð+ûô  "ó 4à—G‘G—L‘L  AÔ&ð '+D”OØ%)§W¡W§\¡\£^D–Nð4ûð	Ø—‘ˆBØˆDŒGØM‰M˜"ÔØús‹   Ã4H ÅK Å6K ÆI Æ$%H. Ç
K Ç5J	 ÈK ÈH+È)H+È.IÉK ÉIÉK É8JÊK ÊJÊK Ê	AKËK ËKËK Ë'Lc                 ó   • U $ r;   r   rÌ   s    r   Ú	__enter__ÚZipFile.__enter__  s   € Øˆr   c                 ó$   • U R                  5         g r;   ©r   )rE   ÚtyperÐ   Ú	tracebacks       r   Ú__exit__ÚZipFile.__exit__“  s   € Ø
‰
r   c                 óÜ  • SU R                   R                  < SU R                   R                  < 3/nU R                  bz  U R                  (       a  UR                  SU R                  -  5        O+U R                  b  UR                  SU R                  -  5        UR                  SU R                  -  5        OUR                  S5        UR                  S5        SR                  U5      $ )	NrÒ   rè  z file=%rz filename=%rz mode=%rré  rÔ   rÕ   )	rA   r   r   rj   rY  r›   rq   rÓ  r_   rë  s     r   rÞ   ÚZipFile.__repr__–  sª    Ø"Ÿn™n×7Ô7Ø"Ÿn™n×9Ó9ð;ð <ˆà7‰7ÑØ××Ø—‘˜j¨4¯7©7Ñ2Õ3Ø—‘Ñ*Ø—‘˜n¨t¯}©}Ñ<Ô=ØM‰M˜* t§y¡yÑ0Õ1àM‰M˜+Ô&Ø‰cÔØw‰wv‹Ðr   c                 óH  • U R                   n [        U5      nU(       d  [        S5      eU R                  S:”  a  [        U5        U[           nU[           nU[           U l	        U[           U-
  U-
  nU[           [        :X  a  U[        [        -   -  nU R                  S:”  a  XT-   n[        SXFU5        XE-   U l        U R                  S:  a  [        S5      eUR!                  U R                  S5        UR#                  U5      n[$        R&                  " U5      nSnXƒ:  Ga   UR#                  [(        5      n	[+        U	5      [(        :w  a  [        S5      e[,        R.                  " [0        U	5      n	U	[2           [4     